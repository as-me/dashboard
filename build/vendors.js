(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define(["React"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("React")) : factory(root["React"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};

/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		1:0
/******/ 	};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}

/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);

/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;

/******/ 			script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};

/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2);\n__webpack_require__(1);\nmodule.exports = __webpack_require__(3);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi vendors\n ** module id = 0\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///multi_vendors?");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"React\"\n ** module id = 1\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///external_%22React%22?");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\n * Event\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2010 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * A collection of Classes that are shared across all the CreateJS libraries.  The classes are included in the minified\n * files of each library and are available on the createsjs namespace directly.\n *\n * <h4>Example</h4>\n *\n *      myObject.addEventListener(\"change\", createjs.proxy(myMethod, scope));\n *\n * @module CreateJS\n * @main CreateJS\n */\n\n// namespace:\nif (typeof window === 'undefined') {\n    this.createjs = this.createjs || {};\n} else {\n    window.createjs = window.createjs || {};\n}\n\n(function () {\n    \"use strict\";\n\n    // constructor:\n    /**\n     * Contains properties and methods shared by all events for use with\n     * {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n     *\n     * Note that Event objects are often reused, so you should never\n     * rely on an event object's state outside of the call stack it was received in.\n     * @class Event\n     * @param {String} type The event type.\n     * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.\n     * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.\n     * @constructor\n     **/\n    function Event(type, bubbles, cancelable) {\n\n\n        // public properties:\n        /**\n         * The type of event.\n         * @property type\n         * @type String\n         **/\n        this.type = type;\n\n        /**\n         * The object that generated an event.\n         * @property target\n         * @type Object\n         * @default null\n         * @readonly\n         */\n        this.target = null;\n\n        /**\n         * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n         * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n         * is generated from childObj, then a listener on parentObj would receive the event with\n         * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n         * @property currentTarget\n         * @type Object\n         * @default null\n         * @readonly\n         */\n        this.currentTarget = null;\n\n        /**\n         * For bubbling events, this indicates the current event phase:<OL>\n         * \t<LI> capture phase: starting from the top parent to the target</LI>\n         * \t<LI> at target phase: currently being dispatched from the target</LI>\n         * \t<LI> bubbling phase: from the target to the top parent</LI>\n         * </OL>\n         * @property eventPhase\n         * @type Number\n         * @default 0\n         * @readonly\n         */\n        this.eventPhase = 0;\n\n        /**\n         * Indicates whether the event will bubble through the display list.\n         * @property bubbles\n         * @type Boolean\n         * @default false\n         * @readonly\n         */\n        this.bubbles = !!bubbles;\n\n        /**\n         * Indicates whether the default behaviour of this event can be cancelled via\n         * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n         * @property cancelable\n         * @type Boolean\n         * @default false\n         * @readonly\n         */\n        this.cancelable = !!cancelable;\n\n        /**\n         * The epoch time at which this event was created.\n         * @property timeStamp\n         * @type Number\n         * @default 0\n         * @readonly\n         */\n        this.timeStamp = (new Date()).getTime();\n\n        /**\n         * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n         * on this event.\n         * @property defaultPrevented\n         * @type Boolean\n         * @default false\n         * @readonly\n         */\n        this.defaultPrevented = false;\n\n        /**\n         * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n         * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n         * @property propagationStopped\n         * @type Boolean\n         * @default false\n         * @readonly\n         */\n        this.propagationStopped = false;\n\n        /**\n         * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n         * on this event.\n         * @property immediatePropagationStopped\n         * @type Boolean\n         * @default false\n         * @readonly\n         */\n        this.immediatePropagationStopped = false;\n\n        /**\n         * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n         * @property removed\n         * @type Boolean\n         * @default false\n         * @readonly\n         */\n        this.removed = false;\n    }\n    var p = Event.prototype;\n\n    /**\n     * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n     * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n     * for details.\n     *\n     * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n     *\n     * @method initialize\n     * @protected\n     * @deprecated\n     */\n    // p.initialize = function() {}; // searchable for devs wondering where it is.\n\n    // public methods:\n    /**\n     * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true.\n     * Mirrors the DOM event standard.\n     * @method preventDefault\n     **/\n    p.preventDefault = function () {\n        this.defaultPrevented = this.cancelable && true;\n    };\n\n    /**\n     * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n     * Mirrors the DOM event standard.\n     * @method stopPropagation\n     **/\n    p.stopPropagation = function () {\n        this.propagationStopped = true;\n    };\n\n    /**\n     * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n     * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n     * Mirrors the DOM event standard.\n     * @method stopImmediatePropagation\n     **/\n    p.stopImmediatePropagation = function () {\n        this.immediatePropagationStopped = this.propagationStopped = true;\n    };\n\n    /**\n     * Causes the active listener to be removed via removeEventListener();\n     *\n     * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n     * \t\t\t// do stuff...\n     * \t\t\tevt.remove(); // removes this listener.\n     * \t\t});\n     *\n     * @method remove\n     **/\n    p.remove = function () {\n        this.removed = true;\n    };\n\n    /**\n     * Returns a clone of the Event instance.\n     * @method clone\n     * @return {Event} a clone of the Event instance.\n     **/\n    p.clone = function () {\n        return new Event(this.type, this.bubbles, this.cancelable);\n    };\n\n    /**\n     * Provides a chainable shortcut method for setting a number of properties on the instance.\n     *\n     * @method set\n     * @param {Object} props A generic object containing properties to copy to the instance.\n     * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n     * @chainable\n     */\n    p.set = function (props) {\n        for (var n in props) {\n            this[n] = props[n];\n        }\n        return this;\n    };\n\n    /**\n     * Returns a string representation of this object.\n     * @method toString\n     * @return {String} a string representation of the instance.\n     **/\n    p.toString = function () {\n        return \"[Event (type=\" + this.type + \")]\";\n    };\n\n    createjs.Event = Event;\n}());\n/*\n * EventDispatcher\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2010 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @module CreateJS\n */\n\n// namespace:\nif (typeof window === 'undefined') {\n    this.createjs = this.createjs || {};\n} else {\n    window.createjs = window.createjs || {};\n}\n\n(function () {\n    \"use strict\";\n\n\n    // constructor:\n    /**\n     * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n     *\n     * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n     * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\n     *\n     * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n     * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n     * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n     *\n     * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\n     * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The\n     * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\n     * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\n     *\n     * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\n     * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also\n     * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\n     *\n     * <h4>Example</h4>\n     * Add EventDispatcher capabilities to the \"MyClass\" class.\n     *\n     *      EventDispatcher.initialize(MyClass.prototype);\n     *\n     * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\n     *\n     *      instance.addEventListener(\"eventName\", handlerMethod);\n     *      function handlerMethod(event) {\n     *          console.log(event.target + \" Was Clicked\");\n     *      }\n     *\n     * <b>Maintaining proper scope</b><br />\n     * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\n     * method to subscribe to events simplifies this.\n     *\n     *      instance.addEventListener(\"click\", function(event) {\n     *          console.log(instance == this); // false, scope is ambiguous.\n     *      });\n     *\n     *      instance.on(\"click\", function(event) {\n     *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\n     *      });\n     *\n     * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.\n     *\n     *\n     * @class EventDispatcher\n     * @constructor\n     **/\n    function EventDispatcher() {\n\n\n        // private properties:\n        /**\n         * @protected\n         * @property _listeners\n         * @type Object\n         **/\n        this._listeners = null;\n\n        /**\n         * @protected\n         * @property _captureListeners\n         * @type Object\n         **/\n        this._captureListeners = null;\n    }\n    var p = EventDispatcher.prototype;\n\n    /**\n     * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.\n     * See {{#crossLink \"Utility Methods/extend\"}}{{/crossLink}} and {{#crossLink \"Utility Methods/promote\"}}{{/crossLink}}\n     * for details.\n     *\n     * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.\n     *\n     * @method initialize\n     * @protected\n     * @deprecated\n     */\n    // p.initialize = function() {}; // searchable for devs wondering where it is.\n\n\n    // static public methods:\n    /**\n     * Static initializer to mix EventDispatcher methods into a target object or prototype.\n     *\n     * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n     * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\n     *\n     * @method initialize\n     * @static\n     * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n     * prototype.\n     **/\n    EventDispatcher.initialize = function (target) {\n        target.addEventListener = p.addEventListener;\n        target.on = p.on;\n        target.removeEventListener = target.off = p.removeEventListener;\n        target.removeAllEventListeners = p.removeAllEventListeners;\n        target.hasEventListener = p.hasEventListener;\n        target.dispatchEvent = p.dispatchEvent;\n        target._dispatchEvent = p._dispatchEvent;\n        target.willTrigger = p.willTrigger;\n    };\n\n\n    // public methods:\n    /**\n     * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n     * multiple callbacks getting fired.\n     *\n     * <h4>Example</h4>\n     *\n     *      displayObject.addEventListener(\"click\", handleClick);\n     *      function handleClick(event) {\n     *         // Click happened.\n     *      }\n     *\n     * @method addEventListener\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n     * the event is dispatched.\n     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     * @return {Function | Object} Returns the listener for chaining or assignment.\n     **/\n    p.addEventListener = function (type, listener, useCapture) {\n        var listeners;\n        if (useCapture) {\n            listeners = this._captureListeners = this._captureListeners || {};\n        } else {\n            listeners = this._listeners = this._listeners || {};\n        }\n        var arr = listeners[type];\n        if (arr) {\n            this.removeEventListener(type, listener, useCapture);\n        }\n        arr = listeners[type]; // remove may have deleted the array\n        if (!arr) {\n            listeners[type] = [listener];\n        } else {\n            arr.push(listener);\n        }\n        return listener;\n    };\n\n    /**\n     * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n     * only run once, associate arbitrary data with the listener, and remove the listener.\n     *\n     * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n     * The created anonymous function is returned for use with .removeEventListener (or .off).\n     *\n     * <h4>Example</h4>\n     *\n     * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\n     * \t\tfunction handleClick(evt, data) {\n     * \t\t\tdata.count -= 1;\n     * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\n     * \t\t\tif (data.count == 0) {\n     * \t\t\t\talert(\"clicked 3 times!\");\n     * \t\t\t\tmyBtn.off(\"click\", listener);\n     * \t\t\t\t// alternately: evt.remove();\n     * \t\t\t}\n     * \t\t}\n     *\n     * @method on\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n     * the event is dispatched.\n     * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n     * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n     * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n     * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n     **/\n    p.on = function (type, listener, scope, once, data, useCapture) {\n        if (listener.handleEvent) {\n            scope = scope || listener;\n            listener = listener.handleEvent;\n        }\n        scope = scope || this;\n        return this.addEventListener(type, function (evt) {\n            listener.call(scope, evt, data);\n            once && evt.remove();\n        }, useCapture);\n    };\n\n    /**\n     * Removes the specified event listener.\n     *\n     * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n     * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n     * closure will not work.\n     *\n     * <h4>Example</h4>\n     *\n     *      displayObject.removeEventListener(\"click\", handleClick);\n     *\n     * @method removeEventListener\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener The listener function or object.\n     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     **/\n    p.removeEventListener = function (type, listener, useCapture) {\n        var listeners = useCapture ? this._captureListeners : this._listeners;\n        if (!listeners) {\n            return;\n        }\n        var arr = listeners[type];\n        if (!arr) {\n            return;\n        }\n        for (var i = 0, l = arr.length; i < l; i++) {\n            if (arr[i] == listener) {\n                if (l == 1) {\n                    delete(listeners[type]);\n                } // allows for faster checks.\n                else {\n                    arr.splice(i, 1);\n                }\n                break;\n            }\n        }\n    };\n\n    /**\n     * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n     * .on method.\n     *\n     * @method off\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener The listener function or object.\n     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     **/\n    p.off = p.removeEventListener;\n\n    /**\n     * Removes all listeners for the specified type, or all listeners of all types.\n     *\n     * <h4>Example</h4>\n     *\n     *      // Remove all listeners\n     *      displayObject.removeAllEventListeners();\n     *\n     *      // Remove all click listeners\n     *      displayObject.removeAllEventListeners(\"click\");\n     *\n     * @method removeAllEventListeners\n     * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n     **/\n    p.removeAllEventListeners = function (type) {\n        if (!type) {\n            this._listeners = this._captureListeners = null;\n        } else {\n            if (this._listeners) {\n                delete(this._listeners[type]);\n            }\n            if (this._captureListeners) {\n                delete(this._captureListeners[type]);\n            }\n        }\n    };\n\n    /**\n     * Dispatches the specified event to all listeners.\n     *\n     * <h4>Example</h4>\n     *\n     *      // Use a string event\n     *      this.dispatchEvent(\"complete\");\n     *\n     *      // Use an Event instance\n     *      var event = new createjs.Event(\"progress\");\n     *      this.dispatchEvent(event);\n     *\n     * @method dispatchEvent\n     * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\n     * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n     * dispatchEvent will construct an Event instance with the specified type.\n     * @return {Boolean} Returns the value of eventObj.defaultPrevented.\n     **/\n    p.dispatchEvent = function (eventObj) {\n        if (typeof eventObj == \"string\") {\n            // won't bubble, so skip everything if there's no listeners:\n            var listeners = this._listeners;\n            if (!listeners || !listeners[eventObj]) {\n                return false;\n            }\n            eventObj = new createjs.Event(eventObj);\n        } else if (eventObj.target && eventObj.clone) {\n            // redispatching an active event object, so clone it:\n            eventObj = eventObj.clone();\n        }\n        try {\n            eventObj.target = this;\n        } catch (e) {} // try/catch allows redispatching of native events\n\n        if (!eventObj.bubbles || !this.parent) {\n            this._dispatchEvent(eventObj, 2);\n        } else {\n            var top = this,\n                list = [top];\n            while (top.parent) {\n                list.push(top = top.parent);\n            }\n            var i, l = list.length;\n\n            // capture & atTarget\n            for (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) {\n                list[i]._dispatchEvent(eventObj, 1 + (i == 0));\n            }\n            // bubbling\n            for (i = 1; i < l && !eventObj.propagationStopped; i++) {\n                list[i]._dispatchEvent(eventObj, 3);\n            }\n        }\n        return eventObj.defaultPrevented;\n    };\n\n    /**\n     * Indicates whether there is at least one listener for the specified event type.\n     * @method hasEventListener\n     * @param {String} type The string type of the event.\n     * @return {Boolean} Returns true if there is at least one listener for the specified event.\n     **/\n    p.hasEventListener = function (type) {\n        var listeners = this._listeners,\n            captureListeners = this._captureListeners;\n        return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));\n    };\n\n    /**\n     * Indicates whether there is at least one listener for the specified event type on this object or any of its\n     * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n     * specified type is dispatched from this object, it will trigger at least one listener.\n     *\n     * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\n     * event flow for a listener, not just this object.\n     * @method willTrigger\n     * @param {String} type The string type of the event.\n     * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n     **/\n    p.willTrigger = function (type) {\n        var o = this;\n        while (o) {\n            if (o.hasEventListener(type)) {\n                return true;\n            }\n            o = o.parent;\n        }\n        return false;\n    };\n\n    /**\n     * @method toString\n     * @return {String} a string representation of the instance.\n     **/\n    p.toString = function () {\n        return \"[EventDispatcher]\";\n    };\n\n\n    // private methods:\n    /**\n     * @method _dispatchEvent\n     * @param {Object | String | Event} eventObj\n     * @param {Object} eventPhase\n     * @protected\n     **/\n    p._dispatchEvent = function (eventObj, eventPhase) {\n        var l, listeners = (eventPhase == 1) ? this._captureListeners : this._listeners;\n        if (eventObj && listeners) {\n            var arr = listeners[eventObj.type];\n            if (!arr || !(l = arr.length)) {\n                return;\n            }\n            try {\n                eventObj.currentTarget = this;\n            } catch (e) {}\n            try {\n                eventObj.eventPhase = eventPhase;\n            } catch (e) {}\n            eventObj.removed = false;\n\n            arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n            for (var i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {\n                var o = arr[i];\n                if (o.handleEvent) {\n                    o.handleEvent(eventObj);\n                } else {\n                    o(eventObj);\n                }\n                if (eventObj.removed) {\n                    this.off(eventObj.type, o, eventPhase == 1);\n                    eventObj.removed = false;\n                }\n            }\n        }\n    };\n\n\n    createjs.EventDispatcher = EventDispatcher;\n}());\n/*\n * Ticker\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2010 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/**\n * @module CreateJS\n */\n\n// namespace:\nif (typeof window === 'undefined') {\n    this.createjs = this.createjs || {};\n} else {\n    window.createjs = window.createjs || {};\n}\n\n(function () {\n    \"use strict\";\n\n\n    // constructor:\n    /**\n     * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n     * event to be notified when a set time interval has elapsed.\n     *\n     * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n     * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n     * can not be instantiated.\n     *\n     * <h4>Example</h4>\n     *\n     *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n     *      function handleTick(event) {\n     *          // Actions carried out each tick (aka frame)\n     *          if (!event.paused) {\n     *              // Actions carried out when the Ticker is not paused.\n     *          }\n     *      }\n     *\n     * @class Ticker\n     * @uses EventDispatcher\n     * @static\n     **/\n    function Ticker() {\n        throw \"Ticker cannot be instantiated.\";\n    }\n\n\n    // constants:\n    /**\n     * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n     * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n     * dispatches the tick when the time is within a certain threshold.\n     *\n     * This mode has a higher variance for time between frames than TIMEOUT, but does not require that content be time\n     * based as with RAF while gaining the benefits of that API (screen synch, background throttling).\n     *\n     * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n     * framerates of 10, 12, 15, 20, and 30 work well.\n     *\n     * Falls back on TIMEOUT if the requestAnimationFrame API is not supported.\n     * @property RAF_SYNCHED\n     * @static\n     * @type {String}\n     * @default \"synched\"\n     * @readonly\n     **/\n    Ticker.RAF_SYNCHED = \"synched\";\n\n    /**\n     * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n     * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n     * You can leverage {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} and the tick event object's \"delta\" properties\n     * to make this easier.\n     *\n     * Falls back on TIMEOUT if the requestAnimationFrame API is not supported.\n     * @property RAF\n     * @static\n     * @type {String}\n     * @default \"raf\"\n     * @readonly\n     **/\n    Ticker.RAF = \"raf\";\n\n    /**\n     * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n     * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n     * @property TIMEOUT\n     * @static\n     * @type {String}\n     * @default \"timer\"\n     * @readonly\n     **/\n    Ticker.TIMEOUT = \"timeout\";\n\n\n    // static events:\n    /**\n     * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n     * {{#crossLink \"Ticker/setPaused\"}}{{/crossLink}}.\n     *\n     * <h4>Example</h4>\n     *\n     *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n     *      function handleTick(event) {\n     *          console.log(\"Paused:\", event.paused, event.delta);\n     *      }\n     *\n     * @event tick\n     * @param {Object} target The object that dispatched the event.\n     * @param {String} type The event type.\n     * @param {Boolean} paused Indicates whether the ticker is currently paused.\n     * @param {Number} delta The time elapsed in ms since the last tick.\n     * @param {Number} time The total time in ms since Ticker was initialized.\n     * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n     * \tyou could determine the amount of time that the Ticker has been paused since initialization with time-runTime.\n     * @since 0.6.0\n     */\n\n\n    // public static properties:\n    /**\n     * Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will\n     * use {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} by default.\n     * @deprecated Deprecated in favour of {{#crossLink \"Ticker/timingMode\"}}{{/crossLink}}.\n     * @property useRAF\n     * @static\n     * @type {Boolean}\n     * @default false\n     **/\n    Ticker.useRAF = false;\n\n    /**\n     * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n     * {{#crossLink \"Ticker/TIMEOUT\"}}{{/crossLink}}, {{#crossLink \"Ticker/RAF\"}}{{/crossLink}}, and\n     * {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} for mode details.\n     * @property timingMode\n     * @static\n     * @type {String}\n     * @default Ticker.TIMEOUT\n     **/\n    Ticker.timingMode = null;\n\n    /**\n     * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n     * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n     * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n     * (ex. maxDelta=50 when running at 40fps).\n     *\n     * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n     * when using both delta and other values.\n     *\n     * If 0, there is no maximum.\n     * @property maxDelta\n     * @static\n     * @type {number}\n     * @default 0\n     */\n    Ticker.maxDelta = 0;\n\n    /**\n     * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property of the event will be false.\n     * Also, while paused the `runTime` will not increase. See {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}},\n     * {{#crossLink \"Ticker/getTime\"}}{{/crossLink}}, and {{#crossLink \"Ticker/getEventTime\"}}{{/crossLink}} for more info.\n     *\n     * <h4>Example</h4>\n     *\n     *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n     *      createjs.Ticker.paused = true;\n     *      function handleTick(event) {\n     *          console.log(event.paused,\n     *          \tcreatejs.Ticker.getTime(false),\n     *          \tcreatejs.Ticker.getTime(true));\n     *      }\n     *\n     * @property paused\n     * @static\n     * @type {Boolean}\n     * @default false\n     **/\n    Ticker.paused = false;\n\n\n    // mix-ins:\n    // EventDispatcher methods:\n    Ticker.removeEventListener = null;\n    Ticker.removeAllEventListeners = null;\n    Ticker.dispatchEvent = null;\n    Ticker.hasEventListener = null;\n    Ticker._listeners = null;\n    createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.\n    Ticker._addEventListener = Ticker.addEventListener;\n    Ticker.addEventListener = function () {\n        !Ticker._inited && Ticker.init();\n        return Ticker._addEventListener.apply(Ticker, arguments);\n    };\n\n\n    // private static properties:\n    /**\n     * @property _inited\n     * @static\n     * @type {Boolean}\n     * @protected\n     **/\n    Ticker._inited = false;\n\n    /**\n     * @property _startTime\n     * @static\n     * @type {Number}\n     * @protected\n     **/\n    Ticker._startTime = 0;\n\n    /**\n     * @property _pausedTime\n     * @static\n     * @type {Number}\n     * @protected\n     **/\n    Ticker._pausedTime = 0;\n\n    /**\n     * The number of ticks that have passed\n     * @property _ticks\n     * @static\n     * @type {Number}\n     * @protected\n     **/\n    Ticker._ticks = 0;\n\n    /**\n     * The number of ticks that have passed while Ticker has been paused\n     * @property _pausedTicks\n     * @static\n     * @type {Number}\n     * @protected\n     **/\n    Ticker._pausedTicks = 0;\n\n    /**\n     * @property _interval\n     * @static\n     * @type {Number}\n     * @protected\n     **/\n    Ticker._interval = 50;\n\n    /**\n     * @property _lastTime\n     * @static\n     * @type {Number}\n     * @protected\n     **/\n    Ticker._lastTime = 0;\n\n    /**\n     * @property _times\n     * @static\n     * @type {Array}\n     * @protected\n     **/\n    Ticker._times = null;\n\n    /**\n     * @property _tickTimes\n     * @static\n     * @type {Array}\n     * @protected\n     **/\n    Ticker._tickTimes = null;\n\n    /**\n     * Stores the timeout or requestAnimationFrame id.\n     * @property _timerId\n     * @static\n     * @type {Number}\n     * @protected\n     **/\n    Ticker._timerId = null;\n\n    /**\n     * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n     * if that property changed and a tick hasn't fired.\n     * @property _raf\n     * @static\n     * @type {Boolean}\n     * @protected\n     **/\n    Ticker._raf = true;\n\n\n    // static getter / setters:\n    /**\n     * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n     * @method setInterval\n     * @static\n     * @param {Number} interval\n     * @deprecated\n     **/\n    Ticker.setInterval = function (interval) {\n        Ticker._interval = interval;\n        if (!Ticker._inited) {\n            return;\n        }\n        Ticker._setupTick();\n    };\n\n    /**\n     * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n     * @method getInterval\n     * @static\n     * @return {Number}\n     * @deprecated\n     **/\n    Ticker.getInterval = function () {\n        return Ticker._interval;\n    };\n\n    /**\n     * Use the {{#crossLink \"Ticker/framerate:property\"}}{{/crossLink}} property instead.\n     * @method setFPS\n     * @static\n     * @param {Number} value\n     * @deprecated\n     **/\n    Ticker.setFPS = function (value) {\n        Ticker.setInterval(1000 / value);\n    };\n\n    /**\n     * Use the {{#crossLink \"Ticker/interval:property\"}}{{/crossLink}} property instead.\n     * @method getFPS\n     * @static\n     * @return {Number}\n     * @deprecated\n     **/\n    Ticker.getFPS = function () {\n        return 1000 / Ticker._interval;\n    };\n\n    /**\n     * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n     * Note that actual time between ticks may be more than specified depending on CPU load.\n     * This property is ignored if the ticker is using the `RAF` timing mode.\n     * @property interval\n     * @static\n     * @type {Number}\n     **/\n\n    /**\n     * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where\n     * `framerate == 1000/interval`.\n     * @property framerate\n     * @static\n     * @type {Number}\n     **/\n    try {\n        Object.defineProperties(Ticker, {\n            interval: {\n                get: Ticker.getInterval,\n                set: Ticker.setInterval\n            },\n            framerate: {\n                get: Ticker.getFPS,\n                set: Ticker.setFPS\n            }\n        });\n    } catch (e) {\n        console.log(e);\n    }\n\n\n    // public static methods:\n    /**\n     * Starts the tick. This is called automatically when the first listener is added.\n     * @method init\n     * @static\n     **/\n    Ticker.init = function () {\n        if (Ticker._inited) {\n            return;\n        }\n        Ticker._inited = true;\n        Ticker._times = [];\n        Ticker._tickTimes = [];\n        Ticker._startTime = Ticker._getTime();\n        Ticker._times.push(Ticker._lastTime = 0);\n        Ticker.interval = Ticker._interval;\n    };\n\n    /**\n     * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n     * @method reset\n     * @static\n     **/\n    Ticker.reset = function () {\n        if (Ticker._raf) {\n            var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n            f && f(Ticker._timerId);\n        } else {\n            clearTimeout(Ticker._timerId);\n        }\n        Ticker.removeAllEventListeners(\"tick\");\n        Ticker._timerId = Ticker._times = Ticker._tickTimes = null;\n        Ticker._startTime = Ticker._lastTime = Ticker._ticks = 0;\n        Ticker._inited = false;\n    };\n\n    /**\n     * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n     * because it only measures the time spent within the tick execution stack.\n     *\n     * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between\n     * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that\n     * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n     *\n     * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n     * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n     * other than the tick is using ~80ms (another script, DOM rendering, etc).\n     * @method getMeasuredTickTime\n     * @static\n     * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n     * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n     * @return {Number} The average time spent in a tick in milliseconds.\n     **/\n    Ticker.getMeasuredTickTime = function (ticks) {\n        var ttl = 0,\n            times = Ticker._tickTimes;\n        if (!times || times.length < 1) {\n            return -1;\n        }\n\n        // by default, calculate average for the past ~1 second:\n        ticks = Math.min(times.length, ticks || (Ticker.getFPS() | 0));\n        for (var i = 0; i < ticks; i++) {\n            ttl += times[i];\n        }\n        return ttl / ticks;\n    };\n\n    /**\n     * Returns the actual frames / ticks per second.\n     * @method getMeasuredFPS\n     * @static\n     * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n     * Defaults to the number of ticks per second.\n     * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n     * from the target frames per second.\n     **/\n    Ticker.getMeasuredFPS = function (ticks) {\n        var times = Ticker._times;\n        if (!times || times.length < 2) {\n            return -1;\n        }\n\n        // by default, calculate fps for the past ~1 second:\n        ticks = Math.min(times.length - 1, ticks || (Ticker.getFPS() | 0));\n        return 1000 / ((times[0] - times[ticks]) / ticks);\n    };\n\n    /**\n     * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n     * @method setPaused\n     * @static\n     * @param {Boolean} value\n     * @deprecated\n     **/\n    Ticker.setPaused = function (value) {\n        // TODO: deprecated.\n        Ticker.paused = value;\n    };\n\n    /**\n     * Use the {{#crossLink \"Ticker/paused:property\"}}{{/crossLink}} property instead.\n     * @method getPaused\n     * @static\n     * @return {Boolean}\n     * @deprecated\n     **/\n    Ticker.getPaused = function () {\n        // TODO: deprecated.\n        return Ticker.paused;\n    };\n\n    /**\n     * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink \"Ticker/init\"}}.\n     * Returns -1 if Ticker has not been initialized. For example, you could use\n     * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n     * @method getTime\n     * @static\n     * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n     * If false, the value returned will be total time elapsed since the first tick event listener was added.\n     * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n     **/\n    Ticker.getTime = function (runTime) {\n        return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;\n    };\n\n    /**\n     * Similar to getTime(), but returns the time on the most recent tick event object.\n     * @method getEventTime\n     * @static\n     * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n     * @returns {number} The time or runTime property from the most recent tick event or -1.\n     */\n    Ticker.getEventTime = function (runTime) {\n        return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;\n    };\n\n    /**\n     * Returns the number of ticks that have been broadcast by Ticker.\n     * @method getTicks\n     * @static\n     * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast\n     * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n     * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n     * value. The default value is false.\n     * @return {Number} of ticks that have been broadcast.\n     **/\n    Ticker.getTicks = function (pauseable) {\n        return Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);\n    };\n\n\n    // private static methods:\n    /**\n     * @method _handleSynch\n     * @static\n     * @protected\n     **/\n    Ticker._handleSynch = function () {\n        Ticker._timerId = null;\n        Ticker._setupTick();\n\n        // run if enough time has elapsed, with a little bit of flexibility to be early:\n        if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval - 1) * 0.97) {\n            Ticker._tick();\n        }\n    };\n\n    /**\n     * @method _handleRAF\n     * @static\n     * @protected\n     **/\n    Ticker._handleRAF = function () {\n        Ticker._timerId = null;\n        Ticker._setupTick();\n        Ticker._tick();\n    };\n\n    /**\n     * @method _handleTimeout\n     * @static\n     * @protected\n     **/\n    Ticker._handleTimeout = function () {\n        Ticker._timerId = null;\n        Ticker._setupTick();\n        Ticker._tick();\n    };\n\n    /**\n     * @method _setupTick\n     * @static\n     * @protected\n     **/\n    Ticker._setupTick = function () {\n        if (Ticker._timerId != null) {\n            return;\n        } // avoid duplicates\n\n        var mode = Ticker.timingMode || (Ticker.useRAF && Ticker.RAF_SYNCHED);\n        if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {\n            var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n            if (f) {\n                Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);\n                Ticker._raf = true;\n                return;\n            }\n        }\n        Ticker._raf = false;\n        Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);\n    };\n\n    /**\n     * @method _tick\n     * @static\n     * @protected\n     **/\n    Ticker._tick = function () {\n        var paused = Ticker.paused;\n        var time = Ticker._getTime();\n        var elapsedTime = time - Ticker._lastTime;\n        Ticker._lastTime = time;\n        Ticker._ticks++;\n\n        if (paused) {\n            Ticker._pausedTicks++;\n            Ticker._pausedTime += elapsedTime;\n        }\n\n        if (Ticker.hasEventListener(\"tick\")) {\n            var event = new createjs.Event(\"tick\");\n            var maxDelta = Ticker.maxDelta;\n            event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;\n            event.paused = paused;\n            event.time = time;\n            event.runTime = time - Ticker._pausedTime;\n            Ticker.dispatchEvent(event);\n        }\n\n        Ticker._tickTimes.unshift(Ticker._getTime() - time);\n        while (Ticker._tickTimes.length > 100) {\n            Ticker._tickTimes.pop();\n        }\n\n        Ticker._times.unshift(time);\n        while (Ticker._times.length > 100) {\n            Ticker._times.pop();\n        }\n    };\n\n    /**\n     * @method _getTime\n     * @static\n     * @protected\n     **/\n    var now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);\n    Ticker._getTime = function () {\n        return ((now && now.call(performance)) || (new Date().getTime())) - Ticker._startTime;\n    };\n\n\n    createjs.Ticker = Ticker;\n}());\n/*\n    Weave (Web-based Analysis and Visualization Environment)\n    Copyright (C) 2008-2011 University of Massachusetts Lowell\n    This file is a part of Weave.\n    Weave is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, Version 3,\n    as published by the Free Software Foundation.\n    Weave is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n    You should have received a copy of the GNU General Public License\n    along with Weave.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// namespace\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This provides a set of useful static functions for Object Comparison.\n * All Static functions are Ported from  Apache Flex mx.utils.ObjectUtil - ActionScript Code\n * @author sanjay1909\n */\n(function () {\n    \"use strict\";\n\n    //constructor\n    function ObjectUtil() {\n        throw \"ObjectUtil cannot be instantiated.\";\n    }\n\n    /**\n     *  Compares two numeric values.\n     *  @param a First number.\n     *  @param b Second number.\n     *  @return 0 is both numbers are NaN.\n     *  1 if only <code>a</code> is a NaN.\n     *  -1 if only <code>b</code> is a NaN.\n     *  -1 if <code>a</code> is less than <code>b</code>.\n     *  1 if <code>a</code> is greater than <code>b</code>.\n     */\n    ObjectUtil.numericCompare = function (a, b) {\n        if (isNaN(a) && isNaN(b))\n            return 0;\n\n        if (isNaN(a))\n            return 1;\n\n        if (isNaN(b))\n            return -1;\n\n        if (a < b)\n            return -1;\n\n        if (a > b)\n            return 1;\n\n        return 0;\n    };\n\n    /**\n     *  Compares two String values.\n     *  @param a First String value.\n     *  @param b Second String value.\n     *  @param caseInsensitive Specifies to perform a case insensitive compare,\n     *  <code>true</code>, or not, <code>false</code>.\n     *\n     *  @return 0 is both Strings are null.\n     *  1 if only <code>a</code> is null.\n     *  -1 if only <code>b</code> is null.\n     *  -1 if <code>a</code> precedes <code>b</code>.\n     *  1 if <code>b</code> precedes <code>a</code>.\n     */\n    ObjectUtil.stringCompare = function (a, b, caseInsensitive) {\n        if ((a === null || a === undefined) && (b === null || b === undefined))\n            return 0;\n\n        if (a === null || a === undefined)\n            return 1;\n\n        if (b === null || b === undefined)\n            return -1;\n\n        // Convert to lowercase if we are case insensitive.\n        if (caseInsensitive) {\n            a = a.toLocaleLowerCase();\n            b = b.toLocaleLowerCase();\n        }\n\n        var result = a.localeCompare(b);\n\n        if (result < -1)\n            result = -1;\n        else if (result > 1)\n            result = 1;\n\n        return result;\n    };\n\n    /**\n     *  Compares the two Date objects and returns an integer value\n     *  indicating if the first Date object is before, equal to,\n     *  or after the second item.\n     *  @param a Date object.\n     *  @param b Date object.\n     *  @return 0 if <code>a</code> and <code>b</code> are equal\n     *  (or both are <code>null</code>);\n     *  -1 if <code>a</code> is before <code>b</code>\n     *  (or <code>b</code> is <code>null</code>);\n     *  1 if <code>a</code> is after <code>b</code>\n     *  (or <code>a</code> is <code>null</code>);\n     *  0 is both dates getTime's are NaN;\n     *  1 if only <code>a</code> getTime is a NaN;\n     *  -1 if only <code>b</code> getTime is a NaN.\n     */\n    ObjectUtil.dateCompare = function (a, b) {\n        if ((a === null || a === undefined) && (b === null || b === undefined))\n            return 0;\n\n        if (a === null || undefined)\n            return 1;\n\n        if (b === null || undefined)\n            return -1;\n\n        var na = a.getTime();\n        var nb = b.getTime();\n\n        if (na < nb)\n            return -1;\n\n        if (na > nb)\n            return 1;\n\n        if (isNaN(na) && isNaN(nb))\n            return 0;\n\n        if (isNaN(na))\n            return 1;\n\n        if (isNaN(nb))\n            return -1;\n\n        return 0;\n    };\n\n    weavecore.ObjectUtil = ObjectUtil;\n\n}());\n\n/*\n    Weave (Web-based Analysis and Visualization Environment)\n    Copyright (C) 2008-2011 University of Massachusetts Lowell\n    This file is a part of Weave.\n    Weave is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, Version 3,\n    as published by the Free Software Foundation.\n    Weave is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n    You should have received a copy of the GNU General Public License\n    along with Weave.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// namespace\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This provides a set of useful static functions.\n * All the functions defined in this class are pure functions,\n * meaning they always return the same result with the same arguments, and they have no side-effects.\n *\n * @author adufilie\n * @author sanbalag\n */\n(function () {\n    \"use strict\";\n\n    //constructor\n    function StandardLib() {\n        throw \"StandardLib cannot be instantiated.\";\n    }\n\n    /**\n     * This compares two dynamic objects or primitive values and is much faster than ObjectUtil.compare().\n     * Does not check for circular refrences.\n     * @param a First dynamic object or primitive value.\n     * @param b Second dynamic object or primitive value.\n     * @return A value of zero if the two objects are equal, nonzero if not equal.\n     */\n    StandardLib.compare = function (a, b) {\n        var c;\n        var ObjectUtil = weavecore.ObjectUtil;\n        if (a === b)\n            return 0;\n        if (a === null || a === undefined)\n            return 1;\n        if (b === null || b === undefined)\n            return -1;\n        var typeA = typeof (a);\n        var typeB = typeof (b);\n        if (typeA !== typeB)\n            return weavecore.ObjectUtil.stringCompare(typeA, typeB);\n        if (typeA === 'boolean')\n            return weavecore.ObjectUtil.numericCompare(Number(a), Number(b));\n        if (typeA === 'number')\n            return weavecore.ObjectUtil.numericCompare(a, b);\n        if (typeA === 'string')\n            return weavecore.ObjectUtil.stringCompare(a, b);\n\n        if (typeA !== 'object')\n            return 1;\n\n        if (a instanceof Date && b instanceof Date)\n            return weavecore.ObjectUtil.dateCompare(a, b);\n\n        if (a.constructor === Array && b.constructor === Array) {\n            var an = a.length;\n            var bn = b.length;\n            if (an < bn)\n                return -1;\n            if (an > bn)\n                return 1;\n            for (var i = 0; i < an; i++) {\n                c = StandardLib.compare(a[i], b[i]);\n                if (c !== 0)\n                    return c;\n            }\n            return 0;\n        }\n\n        var qna = a.constructor.name;\n        var qnb = b.constructor.name;\n\n        if (qna != qnb)\n            return weavecore.ObjectUtil.stringCompare(qna, qnb);\n\n        var p;\n\n        // test if objects are dynamic\n        try {\n            a[''];\n            b[''];\n        } catch (e) {\n            return 1; // not dynamic objects\n        }\n\n        // if there are properties in a not found in b, return -1\n        for (p in a) {\n            if (!b.hasOwnProperty(p))\n                return -1;\n        }\n        for (p in b) {\n            // if there are properties in b not found in a, return 1\n            if (!a.hasOwnProperty(p))\n                return 1;\n\n            c = StandardLib.compare(a[p], b[p]);\n            if (c !== 0)\n                return c;\n        }\n\n        return 0;\n    };\n\n    weavecore.StandardLib = StandardLib;\n}());\n/**\n * @module weavecore\n */\n\n//namesapce\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n(function () {\n    \"use strict\";\n\n    // constructor\n    /**\n     * Utility Class to create Dynamic state objects with three properties: objectName, className, sessionState\n     * @class DynamicState\n     */\n    function DynamicState() {\n        throw \"DynamicState cannot be instantiated.\";\n    }\n\n    // Static Public Const Properties\n    /**\n     * The name of the property containing the name assigned to the object when the session state is generated.\n     * @static\n     * @public\n     * @property OBJECT_NAME\n     * @readOnly\n     * @default \"objectName\"\n     * @type String\n     */\n    Object.defineProperty(DynamicState, 'OBJECT_NAME', {\n        value: \"objectName\"\n    });\n\n    /**\n     * The name of the property containing the qualified class name of the original object providing the session state.\n     * @static\n     * @public\n     * @property CLASS_NAME\n     * @readOnly\n     * @default \"className\"\n     * @type String\n     */\n    Object.defineProperty(DynamicState, 'CLASS_NAME', {\n        value: \"className\"\n    });\n\n    /**\n     * The name of the property containing the session state for an object of the type specified by className.\n     * @static\n     * @public\n     * @property SESSION_STATE\n     * @readOnly\n     * @default \"sessionState\"\n     * @type String\n     */\n    Object.defineProperty(DynamicState, 'SESSION_STATE', {\n        value: \"sessionState\"\n    });\n\n    //static Public Methods\n    /**\n     * Creates an Object having three properties: objectName, className, sessionState\n     * @method create\n     * @static\n     * @param {String} objectName The name assigned to the object when the session state is generated.\n     * @param {String} className The qualified class name of the original object providing the session state.\n     * @param {Object} sessionState The session state for an object of the type specified by className.\n     */\n    DynamicState.create = function (objectName, className, sessionState) {\n        var obj = {};\n        // convert empty strings (\"\") to null\n        obj[DynamicState.OBJECT_NAME] = objectName || null;\n        obj[DynamicState.CLASS_NAME] = className || null;\n        obj[DynamicState.SESSION_STATE] = sessionState;\n        return obj;\n    };\n\n    /**\n     * This function can be used to detect dynamic state objects within nested, untyped session state objects.\n     * This function will check if the given object has the three properties of a dynamic state object.\n     * @method isDynamicState\n     * @static\n     * @param {Object} object An object to check.\n     * @return {Boolean} true if the object has all three properties and no extras.\n     */\n    DynamicState.isDynamicState = function (object) {\n        var matchCount = 0;\n        for (var name in object) {\n            if (name === DynamicState.OBJECT_NAME || name === DynamicState.CLASS_NAME || name === DynamicState.SESSION_STATE)\n                matchCount++;\n            else\n                return false;\n        }\n        return (matchCount == 3); // must match all three properties with no extras\n    };\n\n    /**\n     * This function checks whether or not a session state is an Array containing at least one\n     * object that looks like a DynamicState and has no other non-String items.\n     * @method isDynamicStateArray\n     * @static\n     * @param {Object} state\n     * @return {Boolean} A value of true if the Array looks like a dynamic session state or diff.\n     */\n    DynamicState.isDynamicStateArray = function (state) {\n        if (!Array.isArray(state))\n            return false;\n        var result = false;\n        for (var i = 0; i < state.length; i++) {\n            var item = state[i];\n            if (typeof item == 'string' || item instanceof String)\n                continue; // dynamic state diffs can contain String values.\n            if (DynamicState.isDynamicState(item))\n                result = true;\n            else\n                return false;\n        }\n        return result;\n    };\n\n    weavecore.DynamicState = DynamicState;\n\n}());\n/**\n * @module weavecore\n */\n\n//namesapce\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n(function () {\n    \"use strict\";\n\n    // constructor:\n    /**\n     * An object that implements this empty interface has an associated CallbackCollection and session state,\n     * accessible through the global functions in the WeaveAPI Object. In order for an ILinkableObject to\n     * be created dynamically at runtime, it must not require any constructor parameters.\n     * @class ILinkableObject\n     * @constructor\n     */\n    function ILinkableObject() {}\n\n    weavecore.ILinkableObject = ILinkableObject;\n\n}());\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This is an interface to a composite object with dynamic state, meaning child objects can be dynamically added or removed.\n * The session state for this type of object is defined as an Array of DynamicState objects.\n * DynamicState objects are defined as having exactly three properties: objectName, className, and sessionState.\n * @see DynamicState\n *\n * @author adufilie\n * @author sanjay1909\n */\n(function () {\n    function ILinkableCompositeObject() {\n\n    }\n\n\n\n    ILinkableCompositeObject.prototype = new weavecore.ILinkableObject();\n    ILinkableCompositeObject.prototype.constructor = ILinkableCompositeObject;\n\n    // Prototypes\n    var p = ILinkableCompositeObject.prototype;\n\n    /**\n     * This gets the session state of this composite object.\n     * @return An Array of DynamicState objects which compose the session state for this object.\n     * @see weave.api.core.DynamicState\n     */\n    p.getSessionState = function () {};\n\n    /**\n     * This sets the session state of this composite object.\n     * @param newState An Array of child name Strings or DynamicState objects containing the new values and types for child ILinkableObjects.\n     * @param removeMissingDynamicObjects If true, this will remove any child objects that do not appear in the session state.\n     *     As a special case, a null session state will result in no change regardless of the removeMissingDynamicObjects value.\n     * @see weave.api.core.DynamicState\n     */\n    p.setSessionState = function (newState, removeMissingDynamicObjects) {};\n\n    weavecore.ILinkableCompositeObject = ILinkableCompositeObject;\n\n}());\n/**\n * @module weavecore\n */\n\n//namesapce\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n\n(function () {\n    \"use strict\";\n\n    // Static Public Const Properties\n    /**\n     * The name of the property containing the name assigned to the object when the session state is generated.\n     * @static\n     * @public\n     * @property DEFAULT_TRIGGER_COUNT\n     * @readOnly\n     * @default 1\n     * @type number\n     */\n    Object.defineProperty(CallbackCollection, 'DEFAULT_TRIGGER_COUNT', {\n        value: 1\n    });\n\n    // constructor:\n    /**\n     * This class manages a list of callback functions.\n     * If specified, the preCallback function will be called immediately before running each\n     * callback using the parameters passed to _runCallbacksImmediately(). This means if there\n     * are five callbacks added, preCallback() gets called five times whenever\n     * _runCallbacksImmediately() is called.  An example usage of this is to make sure a relevant\n     * variable is set to the appropriate value while each callback is running.  The preCallback\n     * function will not be called before grouped callbacks.\n     * @class CallbackCollection\n     * @param {Function} preCallback An optional function to call before each immediate callback.\n     * @constructor\n     */\n\n    function CallbackCollection(preCallback) {\n\n        weavecore.ILinkableObject.call(this);\n\n        //private properties:\n\n        /**\n         * for debugging only... will be set when debug==true\n         * @private\n         * @property _linkableObject\n         * @type ILinkableObject\n         **/\n        this._linkableObject;\n\n        /**\n         * for debugging only... will be set when debug==true\n         * @private\n         * @property _lastTriggerStackTrace\n         * @type string\n         **/\n        this._lastTriggerStackTrace; //\n        /**\n         * @private\n         * @property _oldEntries\n         * @type Array\n         **/\n        this._oldEntries;\n\n        /**\n         * This is a list of CallbackEntry objects in the order they were created.\n         * @private\n         * @property _callbackEntries\n         * @type Array\n         **/\n        this._callbackEntries = [];\n\n        /**\n         * This is the function that gets called immediately before every callback.\n         * @protected\n         * @property _precallback\n         * @type function\n         **/\n        this._preCallback = preCallback;\n\n        /**\n         * If this is true, it means triggerCallbacks() has been called while delayed was true.\n         * @private\n         * @property _runCallbacksIsPending\n         * @defaut false\n         * @type boolean\n         **/\n        this._runCallbacksIsPending = false;\n\n        /**\n         * This is the number of times delayCallbacks() has been called without a matching call to resumeCallbacks().\n         * While this is greater than zero, effects of triggerCallbacks() will be delayed.\n         * @private\n         * @property _delayCount\n         * @type number\n         * @default 0\n         **/\n        this._delayCount = 0;\n\n        /**\n         * This value keeps track of how many times callbacks were triggered, and is returned by the public triggerCounter accessor function.\n         * The value starts at 1 to simplify code that compares the counter to a previous value.\n         * This allows the previous value to be set to zero so change will be detected the first time the counter is compared.\n         * This fixes potential bugs where the base case of zero is not considered.\n         * @private\n         * @property _runCallbacksIsPending\n         * @type boolean\n         **/\n        this._triggerCounter = CallbackCollection.DEFAULT_TRIGGER_COUNT;\n\n        /**\n         * A list of CallbackEntry objects for when dispose() is called.\n         * @private\n         * @property _disposeCallbackEntries\n         * @type Array\n         */\n        this._disposeCallbackEntries = [];\n        /**\n         * This value is used internally to remember if dispose() was called.\n         * @private\n         * @property _wasDisposed\n         * @type Boolean\n         * @default false\n         */\n        this._wasDisposed = false;\n\n        /**\n         * This flag is used in _runCallbacksImmediately() to detect when a recursive call has completed running all the callbacks.\n         * @private\n         * @property _runCallbacksCompleted\n         * @type Boolean\n         */\n        this._runCallbacksCompleted;\n\n        // public properties:\n        // readonly Properties\n\n        /**\n         * This counter gets incremented at the time that callbacks are triggered and before they are actually called.\n         * It is necessary in some situations to check this counter to determine if cached data should be used.\n         * @public\n         * @property triggerCounter\n         * @readOnly\n         * @type Number\n         */\n        Object.defineProperty(this, 'triggerCounter', {\n            get: function () {\n                return this._triggerCounter;\n            }\n        });\n\n        /**\n         * While this is true, it means the delay count is greater than zero and the effects of\n         * triggerCallbacks() are delayed until resumeCallbacks() is called to reduce the delay count.\n         * @public\n         * @property callbacksAreDelayed\n         * @readOnly\n         * @type Boolean\n         */\n        Object.defineProperty(this, 'callbacksAreDelayed', {\n            get: function () {\n                return this._delayCount > 0;\n            }\n        });\n\n        /**\n         * This flag becomes true after dispose() is called.\n         * @public\n         * @property wasDisposed\n         * @readOnly\n         * @type Boolean\n         */\n        Object.defineProperty(this, 'wasDisposed', {\n            get: function () {\n                return this._wasDisposed;\n            }\n        });\n\n    }\n\n    CallbackCollection.prototype = new weavecore.ILinkableObject();\n    CallbackCollection.prototype.constructor = CallbackCollection;\n\n    // Prototypes\n    var p = CallbackCollection.prototype;\n    // public methods:\n    /**\n     * This adds the given function as a callback.  The function must not require any parameters.\n     * The callback function will not be called recursively as a result of it triggering callbacks recursively.\n     * @method addImmediateCallback\n     * @param {Object} relevantContext If this is not null, then the callback will be removed when the relevantContext object is disposed via SessionManager.dispose().  This parameter is typically a 'this' pointer.\n     * @param {Function} callback The function to call when callbacks are triggered.\n     * @param {Boolean} runCallbackNow If this is set to true, the callback will be run immediately after it is added.\n     * @param {Boolean} alwaysCallLast If this is set to true, the callback will be always be called after any callbacks that were added with alwaysCallLast=false.  Use this to establish the desired child-to-parent triggering order.\n     */\n    p.addImmediateCallback = function (contextObj, callback, runCallbackNow, alwaysCallLast) {\n        if (callback === null || callback === undefined)\n            return;\n\n        // set default value for parameters\n        if (runCallbackNow === null || runCallbackNow === undefined)\n            runCallbackNow = false;\n\n        if (alwaysCallLast === null || alwaysCallLast === undefined)\n            alwaysCallLast = false;\n\n        // remove the callback if it was previously added\n        this.removeCallback(callback);\n\n        var entry = new CallbackEntry(contextObj, callback);\n        if (alwaysCallLast) // this will run the callback in second round of callback entries\n            entry.schedule = 1; //mostly parent.triggercallback are called last.\n        this._callbackEntries.push(entry);\n\n        if (runCallbackNow) {\n            // increase the recursion count while the function is running\n            entry.recursionCount++;\n            callback.call(this);\n            entry.recursionCount--;\n        }\n    };\n\n    /**\n     * This will trigger every callback function to be called with their saved arguments.\n     * If the delay count is greater than zero, the callbacks will not be called immediately.\n     * @method triggerCallbacks\n     */\n    p.triggerCallbacks = function () {\n\n        if (CallbackCollection.debug) {\n            if (arguments)\n                console.log(\"triggerCallbacks\", arguments);\n            else\n                console.log(\"triggerCallbacks\", this);\n\n            this._lastTriggerStackTrace = new Error(CallbackCollection.STACK_TRACE_TRIGGER).stack;\n        }\n\n        if (this._delayCount > 0) {\n            // we still want to increase the counter even if callbacks are delayed\n            this._triggerCounter++;\n            if (CallbackCollection.debug) console.log(\"triggerCallbacks: _runCallbacksIsPending ->true\", this._delayCount, this._triggerCounter);\n            this._runCallbacksIsPending = true;\n            return;\n        }\n        this._runCallbacksImmediately.call(this);\n    };\n\n\n    /**\n     * This function runs callbacks immediately, ignoring any delays.\n     * The preCallback function will be called with the specified preCallbackParams arguments.\n     * @method _runCallbacksImmediately\n     * @param preCallbackParams The arguments to pass to the preCallback function given in the constructor.\n     * @protected\n     * @final\n     */\n    p._runCallbacksImmediately = function () {\n        if (CallbackCollection.debug) {\n            if (arguments.length > 1) console.log(\"_runCallbacksImmediately: \", arguments);\n        }\n        var preCallbackParams = arguments;\n        //increase the counter immediately\n        this._triggerCounter++;\n        this._runCallbacksIsPending = false;\n\n        // This flag is set to false before running the callbacks.  When it becomes true, the loop exits.\n        this._runCallbacksCompleted = false;\n\n        for (var schedule = 0; schedule < 2; schedule++) {\n            // run the callbacks in the order they were added\n            for (var i = 0; i < this._callbackEntries.length; i++) {\n                // If this flag is set to true, it means a recursive call has finished running callbacks.\n                // If _preCallback is specified, we don't want to exit the loop because that cause a loss of information.\n                if (this._runCallbacksCompleted && (this._preCallback === undefined || this._preCallback === null))\n                    break;\n\n                var entry = this._callbackEntries[i];\n\n                // if we haven't reached the matching schedule yet, skip this callback\n                if (entry.schedule != schedule)\n                    continue;\n                // Remove the entry if the context was disposed by SessionManager.\n                var shouldRemoveEntry;\n                if (entry.callback === null || entry.callback === undefined)\n                    shouldRemoveEntry = true;\n                else if (entry.context instanceof CallbackCollection) // special case\n                    shouldRemoveEntry = entry.context.wasDisposed;\n                else\n                    shouldRemoveEntry = WeaveAPI.SessionManager.objectWasDisposed(entry.context);\n                if (shouldRemoveEntry) {\n                    if (CallbackCollection.debug) {\n                        if (arguments.length > 1) console.log(\"Entry is disposed\");\n                    }\n                    entry.dispose();\n                    // remove the empty callback reference from the list\n                    var removed = this._callbackEntries.splice(i--, 1); // decrease i because remaining entries have shifted\n                    if (CallbackCollection.debug)\n                        this._oldEntries = this._oldEntries ? this._oldEntries.concat(removed) : removed;\n                    continue;\n                }\n                // if _preCallback is specified, we don't want to limit recursion because that would cause a loss of information.\n                if (entry.recursionCount === 0 || (this._preCallback !== undefined && this._preCallback !== null)) {\n                    entry.recursionCount++; // increase count to signal that we are currently running this callback.\n                    if (this._preCallback !== undefined && this._preCallback !== null)\n                        this._preCallback.apply(this, preCallbackParams);\n                    if (CallbackCollection.debug) {\n                        if (arguments.length > 1) console.log([\"callback executed\"]);\n                    }\n                    entry.callback.call();\n\n                    entry.recursionCount--; // decrease count because the callback finished.\n                }\n            }\n        }\n        // This flag is now set to true in case this function was called recursively.  This causes the outer call to exit its loop.\n        this._runCallbacksCompleted = true;\n    };\n\n    /**\n     * This function will remove a callback that was previously added.\n     * @method removeCallback\n     * @param {Function} callback The function to remove from the list of callbacks.\n     */\n    p.removeCallback = function (callback) {\n        // if the callback was added as a grouped callback, we need to remove the trigger function\n        GroupedCallbackEntry.removeGroupedCallback(this, callback);\n        // find the matching CallbackEntry, if any\n        for (var outerLoop = 0; outerLoop < 2; outerLoop++) {\n            var entries = outerLoop === 0 ? this._callbackEntries : this._disposeCallbackEntries;\n            for (var index = 0; index < entries.length; index++) {\n                var entry = entries[index];\n                if (entry !== null && entry !== undefined && callback === entry.callback) {\n                    // Remove the callback by setting the function pointer to null.\n                    // This is done instead of removing the entry because we may be looping over the _callbackEntries Array right now.\n                    entry.dispose();\n                }\n            }\n        }\n    };\n\n\n\n    /**\n     * This will increase the delay count by 1.  To decrease the delay count, use resumeCallbacks().\n     * As long as the delay count is greater than zero, effects of triggerCallbacks() will be delayed.\n     * @method delayCallbacks\n     */\n    p.delayCallbacks = function () {\n        this._delayCount++;\n    };\n\n    /**\n     * This will decrease the delay count by one if it is greater than zero.\n     * If triggerCallbacks() was called while the delay count was greater than zero, immediate callbacks will be called now.\n     * @method resumeCallbacks\n     */\n    p.resumeCallbacks = function () {\n        if (this._delayCount > 0)\n            this._delayCount--;\n\n        if (this._delayCount === 0 && this._runCallbacksIsPending)\n            this.triggerCallbacks(\"resume Callbacks\");\n    };\n\n    /**\n     * This will add a callback that will only be called once, when this callback collection is disposed.\n     * @method addDisposeCallback\n     * @param {Object} relevantContext If this is not null, then the callback will be removed when the relevantContext object is disposed via SessionManager.dispose().  This parameter is typically a 'this' pointer.\n     * @param callback {Function} The function to call when this callback collection is disposed.\n     */\n    p.addDisposeCallback = function (relevantContext, callback) {\n        // don't do anything if the dispose callback was already added\n        for (var i = 0; i < this._disposeCallbackEntries.length; i++) {\n            var entry = this._disposeCallbackEntries[i];\n            if (entry.callback === callback)\n                return;\n        }\n\n\n        this._disposeCallbackEntries.push(new CallbackEntry(relevantContext, callback));\n    };\n\n\n    /**\n     * This function will be called automatically when the object is no longer needed, and should not be called directly.\n     * Use disposeObject() instead so parent-child relationships get cleaned up automatically.\n     * @method dispose\n     */\n    p.dispose = function () {\n        // remove all callbacks\n        if (CallbackCollection.debug)\n            this._oldEntries = this._oldEntries ? this._oldEntries.concat(this._callbackEntries) : this._callbackEntries.concat();\n\n        this._callbackEntries.length = 0;\n        this._wasDisposed = true;\n\n        // run & remove dispose callbacks\n        while (this._disposeCallbackEntries.length) {\n            var entry = this._disposeCallbackEntries.shift();\n            if (entry.callback !== null && entry.callback !== undefined && !WeaveAPI.SessionManager.objectWasDisposed(entry.context)) {\n                entry.callback();\n            }\n        }\n    };\n\n\n\n    /**\n     * Adds a callback that will only be called during a scheduled time each frame.  Grouped callbacks use a central trigger list,\n     * meaning that if multiple ICallbackCollections trigger the same grouped callback before the scheduled time, it will behave as\n     * if it were only triggered once.  For this reason, grouped callback functions cannot have any parameters.  Adding a grouped\n     * callback to a ICallbackCollection will undo any previous effects of addImmediateCallback() or addDisposeCallback() made to the\n     * same ICallbackCollection.  The callback function will not be called recursively as a result of it triggering callbacks recursively.\n     * @method addGroupedCallback\n     * @param relevantContext {Object} If this is not null, then the callback will be removed when the relevantContext object is disposed via SessionManager.dispose().  This parameter is typically a 'this' pointer.\n     * @param groupedCallback {Function} The callback function that will only be allowed to run during a scheduled time each frame.  It must not require any parameters.\n     * @param triggerCallbackNow {Boolean} If this is set to true, the callback will be triggered to run during the scheduled time after it is added.\n     */\n    p.addGroupedCallback = function (relevantContext, groupedCallback, triggerCallbackNow) {\n        //set default value for parameters\n        if (triggerCallbackNow === null || triggerCallbackNow === undefined)\n            triggerCallbackNow = false;\n        GroupedCallbackEntry.addGroupedCallback(this, relevantContext, groupedCallback, triggerCallbackNow);\n    };\n\n\n\n    weavecore.CallbackCollection = CallbackCollection;\n\n\n    // constructor:\n    /**\n     * Internal Class used in {{#crossLink \"CallbackCollection\"}}{{/crossLink}}\n     * @class CallbackEntry\n     * @for CallbackCollection\n     * @param {Object} context\n     * @param {Function} callback\n     * @constructor\n     */\n    function CallbackEntry(context, callback) {\n        /**\n         * This is the context in which the callback function is relevant.\n         * When the context is disposed, the callback should not be called anymore.\n         * @public\n         * @property context\n         * @type Object\n         */\n        this.context = context;\n        /**\n         * This is the callback function.\n         * @public\n         * @property callback\n         * @type Function\n         */\n        this.callback = callback;\n        /**\n         * This is the current recursion depth.\n         * If this is greater than zero, it means the function is currently running.\n         * @public\n         * @property recursionCount\n         * @type number\n         */\n        this.recursionCount = 0;\n        /**\n         * This is 0 if the callback was added with alwaysCallLast=false, or 1 for alwaysCallLast=true\n         * @public\n         * @property schedule\n         * @type number\n         */\n        this.schedule = 0;\n\n        /**\n         * This is a stack trace from when the callback was added.\n         * @public\n         * @property addCallback_stackTrace\n         * @type string\n         */\n        this.addCallback_stackTrace;\n        /**\n         * This is a stack trace from when the callback was removed.\n         * @public\n         * @property removeCallback_stackTrace\n         * @type string\n         */\n        this.removeCallback_stackTrace;\n\n        if (CallbackCollection.debug)\n            this.addCallback_stackTrace = new Error(CallbackEntry.STACK_TRACE_ADD).stack;\n    }\n\n    //Static Properties:\n    /**\n     * Internal Static const properties for Debugging\n     * @private\n     * @static\n     * @property STACK_TRACE_TRIGGER\n     * @readOnly\n     * @default \"This is the stack trace from when the callbacks were last triggered.\"\n     * @type string\n     */\n    Object.defineProperty(CallbackEntry, 'STACK_TRACE_TRIGGER', {\n        value: \"This is the stack trace from when the callbacks were last triggered.\"\n    });\n    /**\n     * Internal Static const properties for Debugging\n     * @private\n     * @static\n     * @property STACK_TRACE_ADD\n     * @readOnly\n     * @default \"This is the stack trace from when the callback was added.\"\n     * @type string\n     */\n    Object.defineProperty(CallbackEntry, 'STACK_TRACE_ADD', {\n        value: \"This is the stack trace from when the callback was added.\"\n    });\n    /**\n     * Internal Static const properties for Debugging\n     * @private\n     * @static\n     * @property STACK_TRACE_REMOVE\n     * @readOnly\n     * @default \"This is the stack trace from when the callback was removed.\"\n     * @type string\n     */\n    Object.defineProperty(CallbackEntry, 'STACK_TRACE_REMOVE', {\n        value: \"This is the stack trace from when the callback was removed.\"\n    });\n\n    /**\n     * Call this when the callback entry is no longer needed.\n     * @method dispose\n     */\n    CallbackEntry.prototype.dispose = function () {\n        if (CallbackCollection.debug && this.callback !== null && this.callback !== undefined)\n            this.removeCallback_stackTrace = new Error(CallbackEntry.STACK_TRACE_REMOVE).stack;\n\n        this.context = null;\n        this.callback = null;\n    };\n\n    weavecore.CallbackEntry = CallbackEntry;\n\n\n    // constructor:\n    /**\n     * Internal Class used in {{#crossLink \"CallbackCollection\"}}{{/crossLink}}\n     * @class GroupedCallbackEntry\n     * @extends CallbackEntry\n     * @for CallbackCollection\n     * @param {Function} groupedCallback\n     * @constructor\n     */\n    function GroupedCallbackEntry(groupedCallback) {\n\n        CallbackEntry.call(this, [], groupedCallback);\n        /**\n         * If true, the callback was triggered this frame.\n         * @public\n         * @property triggered\n         * @type Boolean\n         * @default false\n         */\n        this.triggered = false;\n\n        /**\n         * If true, the callback was triggered again from another grouped callback.\n         * @public\n         * @property triggeredAgain\n         * @type Boolean\n         * @default false\n         */\n        this.triggeredAgain = false;\n\n\n        if (!GroupedCallbackEntry._initialized) {\n            weavecore.StageUtils.addEventCallback(\"tick\", null, GroupedCallbackEntry._handleGroupedCallbacks.bind(this));\n            GroupedCallbackEntry._initialized = true;\n        }\n    }\n\n    //Static Properties:\n    /**\n     * True while handling grouped callbacks.\n     * @private\n     * @static\n     * @property _handlingGroupedCallbacks\n     * @default false\n     * @type Boolean\n     */\n    GroupedCallbackEntry._handlingGroupedCallbacks = false;\n\n    /**\n     * True while handling grouped callbacks called recursively from other grouped callbacks.\n     * @private\n     * @static\n     * @property _handlingRecursiveGroupedCallbacks\n     * @default false\n     * @type Boolean\n     */\n    GroupedCallbackEntry._handlingRecursiveGroupedCallbacks = false;\n\n    /**\n     * This gets set to true when the static _handleGroupedCallbacks() callback has been added as a frame listener.\n     * @private\n     * @static\n     * @property _initialized\n     * @default false\n     * @type Boolean\n     */\n    GroupedCallbackEntry._initialized = false;\n\n    /**\n     * This maps a groupedCallback function to its corresponding GroupedCallbackEntry.\n     * @private\n     * @static\n     * @readOnly\n     * @property _entryLookup\n     * @type Map\n     */\n    Object.defineProperty(GroupedCallbackEntry, '_entryLookup', {\n        value: new Map()\n    });\n\n    /**\n     * This is a list of GroupedCallbackEntry objects in the order they were triggered.\n     * @private\n     * @static\n     * @readOnly\n     * @property _triggeredEntries\n     * @type Array\n     */\n    Object.defineProperty(GroupedCallbackEntry, '_triggeredEntries', {\n        value: []\n    });\n\n    //Static Methods:\n\n    /**\n     * @method addGroupedCallback\n     * @static\n     * @param {CallbackCollection} callbackCollection\n     * @param {Object} relevantContext\n     * @param {Function} groupedCallback\n     * @param {Boolean} triggerCallbackNow\n     */\n    GroupedCallbackEntry.addGroupedCallback = function (callbackCollection, relevantContext, groupedCallback, triggerCallbackNow) {\n        // get (or create) the shared entry for the groupedCallback\n        var entry = GroupedCallbackEntry._entryLookup.get(groupedCallback);\n        if (!entry) {\n            entry = new GroupedCallbackEntry(groupedCallback);\n            GroupedCallbackEntry._entryLookup.set(groupedCallback, entry);\n        }\n\n        // context shouldn't be null because we use it to determine when to clean up the GroupedCallbackEntry.\n        if (relevantContext === null || relevantContext === undefined)\n            relevantContext = callbackCollection;\n\n        // add this context to the list of relevant contexts\n        entry.context.push(relevantContext);\n\n\n        // make sure the actual function is not already added as a callback.\n        callbackCollection.removeCallback(groupedCallback);\n\n        // add the trigger function as a callback\n        // The relevantContext parameter is set to null for entry.trigger so the same callback can be added multiple times to the same\n        // target using different contexts without having the side effect of losing the callback when one of those contexts is disposed.\n        // The entry.trigger function will be removed once all contexts are disposed.\n        callbackCollection.addImmediateCallback(null, entry.trigger.bind(entry), triggerCallbackNow);\n    };\n\n    /**\n     * @method removeGroupedCallback\n     * @static\n     * @param {CallbackCollection} callbackCollection\n     * @param {Function} groupedCallback\n     */\n    GroupedCallbackEntry.removeGroupedCallback = function (callbackCollection, groupedCallback) {\n        // remove the trigger function as a callback\n        var entry = GroupedCallbackEntry._entryLookup.get(groupedCallback);\n        if (entry)\n            callbackCollection.removeCallback(entry.trigger);\n    };\n\n    /**\n     * This function gets called once per frame and allows grouped callbacks to run.\n     * @method _handleGroupedCallbacks\n     * @static\n     * @private\n     */\n    GroupedCallbackEntry._handleGroupedCallbacks = function () {\n        var i;\n        var entry;\n\n        GroupedCallbackEntry._handlingGroupedCallbacks = true; {\n            // Handle grouped callbacks in the order they were triggered,\n            // anticipating that more may be added to the end of the list in the process.\n            // This first pass does not allow grouped callbacks to call each other immediately.\n            for (i = 0; i < GroupedCallbackEntry._triggeredEntries.length; i++) {\n                entry = GroupedCallbackEntry._triggeredEntries[i];\n                entry.handleGroupedCallback();\n            }\n\n            // after all grouped callbacks have been handled once, run those which were triggered recursively and allow them to call other grouped callbacks immediately.\n            GroupedCallbackEntry._handlingRecursiveGroupedCallbacks = true; {\n                // handle grouped callbacks that were triggered recursively\n                for (i = 0; i < GroupedCallbackEntry._triggeredEntries.length; i++) {\n                    entry = GroupedCallbackEntry._triggeredEntries[i];\n                    if (entry.triggeredAgain)\n                        entry.handleGroupedCallback();\n                }\n            }\n            GroupedCallbackEntry._handlingRecursiveGroupedCallbacks = false;\n        }\n        GroupedCallbackEntry._handlingGroupedCallbacks = false;\n\n        // reset for next frame\n        for (i = 0; i < GroupedCallbackEntry._triggeredEntries.length; i++) {\n            entry = GroupedCallbackEntry._triggeredEntries[i];\n            entry.triggered = entry.triggeredAgain = false;\n        }\n        GroupedCallbackEntry._triggeredEntries.length = 0;\n\n    };\n\n    GroupedCallbackEntry.prototype = new CallbackEntry();\n    GroupedCallbackEntry.prototype.constructor = GroupedCallbackEntry;\n\n    var gcP = GroupedCallbackEntry.prototype;\n\n    /**\n     * Marks the entry to be handled later (unless already triggered this frame).\n     * This also takes care of preventing recursion.\n     * @method trigger\n     */\n    gcP.trigger = function () {\n        // if handling recursive callbacks, call now\n        if (GroupedCallbackEntry._handlingRecursiveGroupedCallbacks) {\n            this.handleGroupedCallback();\n        } else if (!this.triggered) {\n            // not previously triggered\n            GroupedCallbackEntry._triggeredEntries.push(this);\n            this.triggered = true;\n        } else if (GroupedCallbackEntry._handlingGroupedCallbacks) {\n            // triggered recursively - call later\n            this.triggeredAgain = true;\n        }\n    };\n\n\n    /**\n     * Checks the context(s) before calling groupedCallback\n     * @method handleGroupedCallback\n     */\n    gcP.handleGroupedCallback = function () {\n        if (!this.context)\n            return;\n\n        // first, make sure there is at least one relevant context for this callback.\n        var allContexts = this.context;\n        // remove the contexts that have been disposed.\n        for (var i = 0; i < allContexts.length; i++)\n            if (WeaveAPI.SessionManager.objectWasDisposed(allContexts[i]))\n                allContexts.splice(i--, 1);\n            // if there are no more relevant contexts for this callback, don't run it.\n        if (allContexts.length === 0) {\n            this.dispose();\n            GroupedCallbackEntry._entryLookup.delete(this.callback);\n            return;\n        }\n\n        // avoid immediate recursion\n        if (this.recursionCount === 0) {\n            this.recursionCount++;\n            this.callback.apply();\n            this.recursionCount--;\n        }\n        // avoid delayed recursion\n        this.triggeredAgain = false;\n    };\n\n    weavecore.GroupedCallbackEntry = GroupedCallbackEntry;\n\n}());\n/**\n * @module weavecore\n */\n\n// namespace\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n\n(function () {\n    \"use strict\";\n\n    // constructor:\n    /**\n     * Session manager contains core functions related to session state.\n     * @class SessionManager\n     * @constructor\n     */\n    function SessionManager() {\n\n        //const properties - writable default to false.\n        /**\n         * @private\n         * @readOnly\n         * @property _childToParentMap\n         * @type Map\n         * This maps a child ILinkableObject to a Dictionary, which maps each of its registered parent ILinkableObjects to a value of true if the child should appear in the session state automatically or false if not.\n         */\n        Object.defineProperty(this, \"_childToParentMap\", {\n            value: new Map()\n        });\n\n        /**\n         * @private\n         * @readOnly\n         * @property _parentToChildMap\n         * @type Map\n         * This maps a parent ILinkableObject to a Dictionary, which maps each of its registered child ILinkableObjects to a value of true if the child should appear in the session state automatically or false if not.\n         */\n        Object.defineProperty(this, \"_parentToChildMap\", {\n            value: new Map()\n        });\n\n        /**\n         * @private\n         * @readOnly\n         * @property _ownerToChildMap\n         * @type Map\n         * This maps a parent ILinkableObject to a Dictionary, which maps each child ILinkableObject it owns to a value of true.\n         */\n        Object.defineProperty(this, \"_ownerToChildMap\", {\n            value: new Map()\n        });\n\n        /**\n         * This maps a child ILinkableObject to its registered owner.\n         * @private\n         * @readOnly\n         * @property _childToOwnerMap\n         * @type Map\n         */\n        Object.defineProperty(this, \"_childToOwnerMap\", {\n            value: new Map()\n        });\n\n        this.debug = false;\n\n        this.linkableObjectToCallbackCollectionMap = new Map();\n        this.debugBusyTasks = false;\n\n        /**\n         * @private\n         * @readOnly\n         * @property _disposedObjectsMap\n         * @type Map\n         */\n        Object.defineProperty(this, \"_disposedObjectsMap\", {\n            value: new Map()\n        });\n\n        /**\n         * @private\n         * @readOnly\n         * @property _treeCallbacks\n         * @type CallbackCollection\n         */\n        Object.defineProperty(this, \"_treeCallbacks\", {\n            value: new weavecore.CallbackCollection()\n        });\n\n        /**\n         * @private\n         * @readOnly\n         * @property _classNameToSessionedPropertyNames\n         * @type Object\n         */\n        Object.defineProperty(this, \"_classNameToSessionedPropertyNames\", {\n            value: {}\n        });\n\n        /**\n         * keeps track of which objects are currently being traversed\n         * @private\n         * @readOnly\n         * @property _getSessionStateIgnoreList\n         * @type Map\n         */\n        Object.defineProperty(this, \"_getSessionStateIgnoreList\", {\n            value: new Map()\n        });\n\n    }\n\n    var p = SessionManager.prototype;\n\n\n\n    /**\n     * This function tells the SessionManager that the session state of the specified child should appear in the\n     * session state of the specified parent, and the child should be disposed when the parent is disposed.\n     *\n     * There is one other requirement for the child session state to appear in the parent session state -- the child\n     * must be accessible through a public variable of the parent or through an accessor function of the parent.\n     *\n     * This function will add callbacks to the sessioned children that cause the parent callbacks to run.\n     *\n     * If a callback function is given, the callback will be added to the child and cleaned up when the parent is disposed.\n     *\n     * @method registerLinkableChild\n     * @param {Object} linkableParent A parent ILinkableObject that the child will be registered with.\n     * @param {ILinkableObject} linkableChild The child ILinkableObject to register as a child.\n     * @param {Function} callback A callback with no parameters that will be added to the child that will run before the parent callbacks are triggered, or during the next ENTER_FRAME event if a grouped callback is used.\n     * @param {Boolean} useGroupedCallback If this is true, addGroupedCallback() will be used instead of addImmediateCallback().\n     * @return {Object} The linkableChild object that was passed to the function.\n     * @example usage:    const foo = registerLinkableChild(this, someLinkableNumber, handleFooChange);\n     */\n    p.registerLinkableChild = function (linkableParent, linkableChild, callback, useGroupedCallback) {\n        //set default values for parameters\n        if (useGroupedCallback === undefined)\n            useGroupedCallback = false;\n        if (!(linkableParent instanceof weavecore.ILinkableObject)) {\n            console.log(\"registerLinkableChild(): Parent does not inherit ILinkableObject.\");\n            return;\n        }\n\n        if (!(linkableChild instanceof weavecore.ILinkableObject)) {\n            console.log(\"registerLinkableChild(): child does not inherit ILinkableObject.\");\n            return;\n        }\n\n        if (callback !== null && callback !== undefined) {\n            var cc = this.getCallbackCollection.call(this, linkableChild);\n            if (useGroupedCallback)\n                cc.addGroupedCallback(linkableParent, callback);\n            else\n                cc.addImmediateCallback(linkableParent, callback);\n        }\n\n        // if the child doesn't have an owner yet, this parent is the owner of the child\n        // and the child should be disposed when the parent is disposed.\n        // registerDisposableChild() also initializes the required Dictionaries.\n        this.registerDisposableChild(linkableParent, linkableChild);\n\n        if (this._childToParentMap.get(linkableChild).get(linkableParent) === undefined) {\n            // remember this child-parent relationship\n            this._childToParentMap.get(linkableChild).set(linkableParent, true);\n            this._parentToChildMap.get(linkableParent).set(linkableChild, true);\n\n            // make child changes trigger parent callbacks\n            var parentCC = this.getCallbackCollection(linkableParent);\n            // set alwaysCallLast=true for triggering parent callbacks, so parent will be triggered after all the other child callbacks\n            this.getCallbackCollection(linkableChild).addImmediateCallback(linkableParent, parentCC.triggerCallbacks.bind(parentCC, \"Parent's -triggerCallback\"), false, true); // parent-child relationship\n        }\n\n        this._treeCallbacks.triggerCallbacks(\"Session Tree: Child Registered\");\n\n        return linkableChild;\n    };\n\n    /**\n     * This will register a child of a parent and cause the child to be disposed when the parent is disposed.\n     * Use this function when a child object can be disposed but you do not want to link the callbacks.\n     * The child will be disposed when the parent is disposed.\n     *\n     * @method registerDisposableChild\n     * @example usage:    const foo = registerDisposableChild(this, someLinkableNumber);\n     *\n     * @param {Object} disposableParent A parent disposable object that the child will be registered with.\n     * @param {Object} disposableChild The disposable object to register as a child of the parent.\n     * @return {Object} The linkableChild object that was passed to the function.\n     */\n    p.registerDisposableChild = function (disposableParent, disposableChild) {\n        if (this._ownerToChildMap.get(disposableParent) === undefined) {\n            this._ownerToChildMap.set(disposableParent, new Map());\n            this._parentToChildMap.set(disposableParent, new Map());\n        }\n        // if this child has no owner yet...\n        if (this._childToOwnerMap.get(disposableChild) === undefined) {\n            // make this first parent the owner\n            this._childToOwnerMap.set(disposableChild, disposableParent);\n            this._ownerToChildMap.get(disposableParent).set(disposableChild, true);\n            // initialize the parent dictionary for this child\n            this._childToParentMap.set(disposableChild, new Map());\n        }\n        return disposableChild;\n    };\n\n    /**\n     * Use this function with care.  This will remove child objects from the session state of a parent and\n     * stop the child from triggering the parent callbacks.\n     * @method unregisterLinkableChild\n     * @param {ILinkableChild} parent A parent that the specified child objects were previously registered with.\n     * @param {ILinkableChild} child The child object to unregister from the parent.\n     */\n    p.unregisterLinkableChild = function (parent, child) {\n        if (this._childToParentMap.get(child))\n            this._childToParentMap.get(child).delete(parent);\n        if (this._parentToChildMap.get(parent))\n            this._parentToChildMap(parent).delete(child);\n        this.getCallbackCollection(child).removeCallback(this.getCallbackCollection(parent).triggerCallbacks.bind(parent));\n\n        this._treeCallbacks.triggerCallbacks(\"Session Tree: Child un-Registered\");\n    };\n\n\n    /**\n     * This function will add or remove child objects from the session state of a parent.  Use this function\n     * with care because the child will no longer be \"sessioned.\"  The child objects will continue to trigger the\n     * callbacks of the parent object, but they will no longer be considered a part of the parent's session state.\n     * If you are not careful, this will break certain functionalities that depend on the session state of the parent.\n     * @method excludeLinkableChildFromSessionState\n     * @param {ILinkableChild} parent A parent that the specified child objects were previously registered with.\n     * @param {ILinkableChild} child The child object to remove from the session state of the parent.\n     */\n    p.excludeLinkableChildFromSessionState = function (parent, child) {\n        if (parent === null || child === null || parent === undefined || child === undefined) {\n            console.log(\"SessionManager.excludeLinkableChildFromSessionState(): Parameters cannot be null.\");\n            return;\n        }\n        if (this._childToParentMap.get(child) !== undefined && this._childToParentMap.get(child).get(parent))\n            this._childToParentMap.get(child).set(parent, false);\n        if (this._parentToChildMap.get(parent) !== undefined && this._parentToChildMap.get(parent).get(child))\n            this._parentToChildMap.get(parent).set(child, false);\n    };\n\n    /**\n     * @method _getRegisteredChildren\n     * @private\n     * This function will return all the child objects that have been registered with a parent.\n     * @param {ILinkableChild} parent A parent object to get the registered children of.\n     * @return {Array} An Array containing a list of linkable objects that have been registered as children of the specified parent.\n     *         This list includes all children that have been registered, even those that do not appear in the session state.\n     */\n    p._getRegisteredChildren = function (parent) {\n        var result = [];\n        if (this._parentToChildMap.get(parent) !== undefined)\n            for (var child in this._parentToChildMap.get(parent))\n                result.push(child);\n        return result;\n    };\n\n    /**\n     * This function gets the owner of a linkable object.  The owner of an object is defined as its first registered parent.\n     * @method getLinkableOwner\n     * @param {ILinkableObject} child An ILinkableObject that was registered as a child of another ILinkableObject.\n     * @return {ILinkableObject} The owner of the child object (the first parent that was registered with the child), or null if the child has no owner.\n     * See {{#crossLink \"SessionManager/getLinkableDescendants:method\"}}{{/crossLink}}\n     */\n    p.getLinkableOwner = function (child) {\n        return this._childToOwnerMap.get(child);\n    };\n\n    /**\n     * This function will return all the descendant objects that implement ILinkableObject.\n     * If the filter parameter is specified, the results will contain only those objects that extend or implement the filter class.\n     * @method getLinkableDescendants\n     * @param {ILinkableObject} root A root object to get the descendants of.\n     * @param {Class} filter An optional Class definition which will be used to filter the results.\n     * @return {Array} An Array containing a list of descendant objects.\n     * See {{#crossLink \"SessionManager/getLinkableOwner:method\"}}{{/crossLink}}\n     */\n    p.getLinkableDescendants = function (root, filter) { //TODO: Port getLinkableDescendants\n        //return this._childToOwnerMap.get(child);\n    };\n    //TODO: Port Busy task from As3\n\n    /**\n     * @method getSessionStateTree\n     * @param {ILinkableObject} root The linkable object to be placed at the root node of the tree.\n     * @param {String} objectName\n     * @param {Object} objectTypeFilter\n     * @return {WeaveTreeItem} A tree of nodes with the properties \"label\", \"object\", and \"children\"\n     */\n    p.getSessionStateTree = function (root, objectName, objectTypeFilter) {\n        var treeItem = new weavecore.WeaveTreeItem();\n        treeItem.label = objectName;\n        treeItem.source = root;\n        treeItem.children = SessionManager.prototype._getTreeItemChildren.bind(this);\n        treeItem.data = objectTypeFilter;\n        return treeItem;\n    };\n\n    /**\n     * @method _getTreeItemChildren\n     * @param {WeaveTreeItem} treeItem\n     * @return {Array}\n     */\n    p._getTreeItemChildren = function (treeItem) {\n        var object = treeItem.source;\n        var objectTypeFilter = treeItem.data;\n        var children = [];\n        var names = [];\n        var childObject;\n        var subtree;\n        var ignoreList = new Map();\n        if (object instanceof weavecore.LinkableHashMap) {\n            names = object.getNames();\n            var childObjects = object.getObjects();\n            for (var i = 0; i < names.length; i++) {\n                childObject = childObjects[i];\n                if (this._childToParentMap.get(childObject) && this._childToParentMap.get(childObject).get(object)) {\n                    if (ignoreList.get(childObject) !== undefined)\n                        continue;\n                    ignoreList.set(childObject, true);\n\n                    subtree = this.getSessionStateTree(childObject, names[i], objectTypeFilter);\n                    if (subtree !== null && subtree !== undefined)\n                        children.push(subtree);\n                }\n            }\n        } else {\n            var deprecatedLookup = null;\n            //TODO: support for Linkable dynamic object\n            console.log(\"Linkable dynamic object not yet supported - only Linkablehashmap\");\n        }\n        if (children.length === 0)\n            children = null;\n        if (objectTypeFilter === null || objectTypeFilter === undefined)\n            return children;\n        if ((children === null || children === undefined) && !(object instanceof objectTypeFilter))\n            return null;\n        return children;\n    };\n\n    /**\n     * Adds a grouped callback that will be triggered when the session state tree changes.\n     * USE WITH CARE. The groupedCallback should not run computationally-expensive code.\n     * @method addTreeCallback\n     * @param {Object} relevantContext\n     * @param {Function} groupedCallback\n     * @param {Boolean} triggerCallbackNow\n     */\n    p.addTreeCallback = function (relevantContext, groupedCallback, triggerCallbackNow) {\n        if (triggerCallbackNow === undefined) triggerCallbackNow = false;\n        this._treeCallbacks.addGroupedCallback(relevantContext, groupedCallback, triggerCallbackNow);\n    };\n\n    /**\n     * @method removeTreeCallback\n     * @param {Function} groupedCallback\n     */\n    p.removeTreeCallback = function (groupedCallback) {\n        this._treeCallbacks.removeCallback(groupedCallback);\n    };\n\n    /**\n     * This function will copy the session state from one sessioned object to another.\n     * If the two objects are of different types, the behavior of this function is undefined.\n     * @method copySessionState\n     * @param {ILinkableObject} source A sessioned object to copy the session state from.\n     * @param {ILinkableObject} destination A sessioned object to copy the session state to.\n     * see {{#crossLink \"SessionManager/getSessionState:method\"}}{{/crossLink}}\n     * see {{#crossLink \"SessionManager/setSessionState:method\"}}{{/crossLink}}\n     */\n    p.copySessionState = function (source, destination) {\n        var sessionState = this.getSessionState(source);\n        this.setSessionState(destination, sessionState, true);\n    };\n\n    /**\n     * @method _applyDiff\n     * @private\n     * @param {Object} base\n     * @param {Object} diff\n     */\n    p._applyDiff = function (base, diff) {\n        if (base === null || base === undefined || typeof (base) !== 'object')\n            return diff;\n\n        for (var key in diff)\n            base[key] = this._applyDiff(base[key], diff[key]);\n\n        return base;\n    };\n\n    /**\n     * Sets the session state of an ILinkableObject.\n     * @method setSessionState\n     * @param {ILinkableObject} linkableObject An object containing sessioned properties (sessioned objects may be nested).\n     * @param {Object} newState An object containing the new values for sessioned properties in the sessioned object.\n     * @param {Boolean} removeMissingDynamicObjects If true, this will remove any properties from an ILinkableCompositeObject that do not appear in the session state.\n     * see {{#crossLink \"SessionManager/getSessionState:method\"}}{{/crossLink}}\n     */\n    p.setSessionState = function (linkableObject, newState, removeMissingDynamicObjects) {\n        if (removeMissingDynamicObjects === undefined) removeMissingDynamicObjects = true;\n        if (linkableObject === null) {\n            console.log(\"SessionManager.setSessionState(): linkableObject cannot be null.\");\n            return;\n        }\n\n        if (linkableObject === undefined) {\n            console.log(\"SessionManager.setSessionState(): linkableObject cannot be undefined.\");\n            return;\n        }\n\n        // special cases: for Explicit and Composite Session Object\n        if (linkableObject instanceof weavecore.LinkableVariable) {\n            var lv = linkableObject;\n            if (removeMissingDynamicObjects === false && newState && newState.constructor.name === 'Object') {\n                lv.setSessionState.call(lv, this._applyDiff.call(this, Object.create(lv.getSessionState(lv)), newState));\n            } else {\n                lv.setSessionState.call(lv, newState);\n            }\n            return;\n        }\n        //linkableHashmap is handled, In As3 version it implements ILinkableCompositeObject\n        // in jS we couldnt do that, thats why linkableObject.setSessionState is used\n        if (linkableObject instanceof weavecore.ILinkableCompositeObject || linkableObject.setSessionState) {\n            if (newState.constructor.name === \"String\")\n                newState = [newState];\n\n            if (newState !== null && !(newState instanceof Array)) {\n                var array = [];\n                for (var key in newState)\n                    array.push(weavecore.DynamicState.create(key, null, newState[key]));\n                newState = array;\n            }\n\n            linkableObject.setSessionState(newState, removeMissingDynamicObjects);\n            return;\n        }\n\n        if (newState === null || newState === undefined)\n            return;\n\n        // delay callbacks before setting session state\n        var objectCC = this.getCallbackCollection(linkableObject);\n        objectCC.delayCallbacks();\n\n        // cache property names if necessary\n        var className = (linkableObject.constructor.name);\n        if (!this._classNameToSessionedPropertyNames[className])\n            this._cacheClassInfo(linkableObject, className);\n\n        // set session state\n        var foundMissingProperty = false;\n        var propertyNames;\n\n        propertyNames = this._classNameToSessionedPropertyNames[className];\n\n        for (var i = 0; i < propertyNames.length; i++) {\n            var name = propertyNames[i];\n            if (!newState.hasOwnProperty(name)) {\n                if (removeMissingDynamicObjects) //&& linkableObject is ILinkableObjectWithNewProperties\n                    foundMissingProperty = true;\n                continue;\n            }\n\n            var property = null;\n            try {\n                property = linkableObject[name];\n            } catch (e) {\n                console.log('SessionManager.setSessionState(): Unable to get property \"' + name + '\" of class \"' + linkableObject.constructor.name + '\"', e);\n            }\n\n            if (property === null)\n                continue;\n\n            this.setSessionState(property, newState[name], removeMissingDynamicObjects);\n        }\n\n        // TODO: handle properties appearing in session state that do not appear in the linkableObject\n        /*if (linkableObject instanceof ILinkableObjectWithNewProperties)\n\t\t\t\tfor (name in newState)\n\t\t\t\t\tif (!deprecatedLookup.hasOwnProperty(name))\n\t\t\t\t\t\tlinkableObject.handleMissingSessionStateProperty(newState, name);*/\n\n        // handle properties missing from absolute session state\n        if (foundMissingProperty)\n            propertyNames.forEach(function (name) {\n                if (!newState.hasOwnProperty(name))\n                    linkableObject.handleMissingSessionStateProperty(newState, name);\n            });\n\n        // resume callbacks after setting session state\n        objectCC.resumeCallbacks();\n\n    };\n\n    /**\n     * Gets the session state of an ILinkableObject.\n     * @method getSessionState\n     * @param {IlinkableObject} linkableObject An object containing sessioned properties (sessioned objects may be nested).\n     * @return {Object} An object containing the values from the sessioned properties.\n     * see {{#crossLink \"SessionManager/setSessionState:method\"}}{{/crossLink}}\n     */\n    p.getSessionState = function (linkableObject) {\n        if (linkableObject === null) {\n            console.log(\"SessionManager.getSessionState(): linkableObject cannot be null.\");\n            return null;\n        }\n\n        if (linkableObject === undefined) {\n            console.log(\"SessionManager.getSessionState(): linkableObject cannot be undefined.\");\n            return null;\n        }\n\n        var result = null;\n\n        // special cases (explicit session state)\n        if (linkableObject instanceof weavecore.LinkableVariable) {\n            result = linkableObject.getSessionState();\n        }\n        //linkableHashmap is handled, In As3 version it implements ILinkableCompositeObject\n        // in jS we couldnt do that, thats why linkableObject.setSessionState is used\n        else if (linkableObject instanceof weavecore.ILinkableCompositeObject || linkableObject.getSessionState) {\n            result = linkableObject.getSessionState();\n        } else {\n            // implicit session state\n            // first pass: get property names\n\n            // cache property names if necessary\n            var className = linkableObject.constructor.name;\n\n            if (!this._classNameToSessionedPropertyNames[className])\n                this._cacheClassInfo(linkableObject, className);\n\n            var propertyNames = this._classNameToSessionedPropertyNames[className];\n            var resultNames = [];\n            var resultProperties = [];\n            var property = null;\n            var i;\n            for (i = 0; i < propertyNames.length; i++) {\n                var name = propertyNames[i];\n\n                try {\n                    property = null; // must set this to null first because accessing the property may fail\n                    property = linkableObject[name];\n                } catch (e) {\n                    console.log('Unable to get property \"' + name + '\" of class \"' + linkableObject.constructor.name + '\"');\n                }\n\n                // first pass: set result[name] to the ILinkableObject\n                if (property !== null && !this._getSessionStateIgnoreList[property]) {\n                    // skip this property if it should not appear in the session state under the parent.\n                    if (this._childToParentMap[property] === undefined || !this._childToParentMap[property][linkableObject])\n                        continue;\n                    // avoid infinite recursion in implicit session states\n                    this._getSessionStateIgnoreList[property] = true;\n                    resultNames.push(name);\n                    resultProperties.push(property);\n                } else {\n                    if (debug) {\n                        if (property !== null)\n                            console.log(\"ignoring duplicate object:\", name, property);\n                    }\n\n\n                }\n\n            }\n\n            // special case if there are no child objects -- return null\n            if (resultNames.length > 0) {\n                // second pass: get values from property names\n                result = {};\n                for (i = 0; i < resultNames.length; i++) {\n                    var value = this.getSessionState(resultProperties[i]);\n                    property = resultProperties[i];\n                    // do not include objects that have a null implicit session state (no child objects)\n                    if (value === null && !(property instanceof weavecore.LinkableVariable) && !(property instanceof weavecore.ILinkableCompositeObject) && !(property.getSessionState))\n                        continue;\n                    result[resultNames[i]] = value;\n\n                    if (debug)\n                        console.log(\"getState\", sessionedObject.constructor.name, resultNames[i], result[resultNames[i]]);\n                }\n            }\n        }\n\n        this._getSessionStateIgnoreList[linkableObject] = undefined;\n\n        return result;\n    };\n\n\n    /**\n     * @method _cacheClassInfo\n     * @private\n     * @param {ILinkableObject} linkableObject\n     * @param {String} className\n     */\n    p._cacheClassInfo = function (linkableObject, className) {\n        // linkable property names\n        var propertyNames = Object.getOwnPropertyNames(linkableObject);\n        var sessionedPublicProperties = propertyNames.filter(function (propName) {\n            if (propName.charAt(0) === '_')\n                return false; //Private properties are ignored\n            else\n                return linkableObject[propName] instanceof weavecore.ILinkableObject;\n        });\n\n        this._classNameToSessionedPropertyNames[className] = sessionedPublicProperties.sort();\n    };\n\n    /**\n     * This function gets a list of sessioned property names so accessor functions for non-sessioned properties do not have to be called.\n     * @method getLinkablePropertyNames\n     * @param {ILinkableObject} linkableObject An object containing sessioned properties.\n     * @param {Boolean} filtered If set to true, filters out deprecated, null, and excluded properties.\n     * @return {Array} An Array containing the names of the sessioned properties of that object class.\n     */\n    p.getLinkablePropertyNames = function (linkableObject, filtered) {\n        if (filtered === undefined) //default parameter value\n            filtered = false;\n\n        if (linkableObject === null) {\n            console.log(\"SessionManager.getLinkablePropertyNames(): linkableObject cannot be null.\");\n            return [];\n        }\n\n        if (linkableObject === undefined) {\n            console.log(\"SessionManager.getLinkablePropertyNames(): linkableObject cannot be undefined.\");\n            return [];\n        }\n\n        var className = linkableObject.constructor.name;\n        var propertyNames = this._classNameToSessionedPropertyNames[className];\n        if (propertyNames === null || propertyNames === undefined) {\n            this._cacheClassInfo(linkableObject, className);\n            propertyNames = this._classNameToSessionedPropertyNames[className];\n        }\n\n        if (filtered) {\n            var filteredPropNames = propertyNames.filter(function (propName) {\n                var property = linkableObject[propName];\n                if (property === null || property === undefined)\n                    return false;\n                if (this._childToParentMap[property] === undefined || !this._childToParentMap[property][linkableObject])\n                    return false;\n\n                return true;\n            });\n            return filteredPropNames;\n        }\n        return propertyNames;\n    };\n\n    /**\n     * This function gets the CallbackCollection associated with an ILinkableObject.\n     * If there is no CallbackCollection defined for the object, one will be created.\n     * This CallbackCollection is used for reporting changes in the session state\n     * @method getCallbackCollection\n     * @param {ILinkableObject} linkableObject An ILinkableObject to get the associated ICallbackCollection for.\n     * @return {CallbackCollection} The CallbackCollection associated with the given object.\n     */\n    p.getCallbackCollection = function (linkableObject) {\n        if (linkableObject === null || linkableObject === undefined)\n            return null;\n        if (linkableObject instanceof weavecore.CallbackCollection)\n            return linkableObject;\n\n        var objectCC = this.linkableObjectToCallbackCollectionMap.get(linkableObject);\n        if (objectCC === null || objectCC === undefined) {\n            objectCC = this.registerDisposableChild(linkableObject, new weavecore.CallbackCollection());\n            if (weavecore.CallbackCollection.debug)\n                objectCC._linkableObject = linkableObject;\n            this.linkableObjectToCallbackCollectionMap.set(linkableObject, objectCC);\n        }\n\n        return objectCC;\n    };\n\n\n    /**\n     * This function checks if an object has been disposed by the SessionManager.\n     * @method objectWasDisposed\n     * @param {Object} object An object to check.\n     * @return {Boolean} A value of true if disposeObject() was called for the specified object.\n     * see {{#crossLink \"SessionManager/disposeObject:method\"}}{{/crossLink}}\n     */\n    p.objectWasDisposed = function (object) {\n        if (object === undefined)\n            return true; // added by sanjay:\n        if (object === null) //null means :Object parameter is null i.e Object has no parameters\n            return false;\n        if (object instanceof weavecore.ILinkableObject) {\n            var cc = this.getCallbackCollection(object);\n            if (cc)\n                return cc.wasDisposed;\n        }\n        return this._disposedObjectsMap.get(object) !== undefined;\n    };\n\n\n    /**\n     * This function should be called when an ILinkableObject  is no longer needed.\n     * @method disposeObject\n     * @param {Object} object An ILinkableObject  to clean up.\n     * see {{#crossLink \"SessionManager/objectWasDisposed:method\"}}{{/crossLink}}\n     */\n    p.disposeObject = function (object) {\n        if (object !== null && object !== undefined && !this._disposedObjectsMap.get(object)) {\n            this._disposedObjectsMap.set(object, true);\n\n            // TODO: clean up pointers to busy tasks\n            //disposeBusyTaskPointers(object as ILinkableObject);\n\n            try {\n                // if the object implements IDisposableObject, call its dispose() function now\n                //if (object instanceof IDisposableObject)\n                //\t{\n                //\tobject.dispose();\n                //\t}\n                if (object.dispose && object.dispose.constructor === Function) {\n                    // call dispose() anyway if it exists, because it is common to forget to implement IDisposableObject.\n                    object.dispose();\n                }\n            } catch (e) {\n                console.log(e);\n            }\n\n            var linkableObject = object;\n            if (linkableObject) {\n                // dispose the callback collection corresponding to the object.\n                // this removes all callbacks, including the one that triggers parent callbacks.\n                var objectCC = this.getCallbackCollection(linkableObject);\n                if (objectCC !== linkableObject)\n                    this.disposeObject(objectCC);\n            }\n\n            // unregister from parents\n            if (this._childToParentMap.get(object) !== undefined) {\n                // remove the parent-to-child mappings\n                for (var parent in this._childToParentMap.get(object))\n                    if (this._parentToChildMap(parent) !== undefined)\n                        this._parentToChildMap.get(parent).delete(object);\n                    // remove child-to-parent mapping\n                this._childToParentMap.delete(object);\n            }\n\n            // unregister from owner\n            var owner = this._childToOwnerMap.get(object);\n            if (owner !== null || owner !== undefined) {\n                if (this._ownerToChildMap.get(owner) !== undefined)\n                    this._ownerToChildMap.get(owner).delete(object);\n                this._childToOwnerMap.delete(object);\n            }\n\n            // if the object is an ILinkableVariable, unlink it from all bindable properties that were previously linked\n            //if (linkableObject instanceof LinkableVariable)\n            //for (var bindableParent:* in _watcherMap[linkableObject])\n            //for (var bindablePropertyName:String in _watcherMap[linkableObject][bindableParent])\n            //unlinkBindableProperty(linkableObject as ILinkableVariable, bindableParent, bindablePropertyName);\n\n            // unlink this object from all other linkable objects\n            //for (var otherObject in linkFunctionCache.dictionary[linkableObject])\n            //unlinkSessionState(linkableObject, otherObject as ILinkableObject);\n\n            // dispose all registered children that this object owns\n            var children = this._ownerToChildMap.get(object);\n            if (children !== null && children !== undefined) {\n                // clear the pointers to the child dictionaries for this object\n                this._ownerToChildMap.delete(object);\n                this._parentToChildMap.delete(object);\n                // dispose the children this object owned\n                for (var child in children)\n                    this.disposeObject(child);\n            }\n\n            this._treeCallbacks.triggerCallbacks(\"Session Tree: Object Disposed\");\n        }\n    };\n\n\n    /**\n     * This function computes the diff of two session states.\n     * @method computeDiff\n     * @param {Object} oldState The source session state.\n     * @param {Object} newState The destination session state.\n     * @return {Object} A patch that generates the destination session state when applied to the source session state, or undefined if the two states are equivalent.\n     * see {{#crossLink \"SessionManager/combineDiff:method\"}}{{/crossLink}}\n     */\n    p.computeDiff = function (oldState, newState) {\n        var type = typeof (oldState); // the type of null is 'object'\n        var diffValue;\n\n        // special case if types differ\n        if (typeof (newState) !== type)\n            return newState;\n\n\n        if (type === 'number') {\n            if (isNaN(oldState) && isNaN(newState))\n                return undefined; // no diff\n\n            if (oldState !== newState)\n                return newState;\n\n            return undefined; // no diff\n        } else if (oldState === null || oldState === undefined || newState === null || newState === undefined || type !== 'object') // other primitive value\n        {\n            if (oldState !== newState) // no type-casting\n                return newState;\n\n            return undefined; // no diff\n        } else if (oldState.constructor === Array && newState.constructor === Array) {\n            // If neither is a dynamic state array, don't compare them as such.\n            if (!weavecore.DynamicState.isDynamicStateArray(oldState) && !weavecore.DynamicState.isDynamicStateArray(newState)) {\n                if (weavecore.StandardLib.compare(oldState, newState) === 0)\n                    return undefined; // no diff\n                return newState;\n            }\n\n            // create an array of new DynamicState objects for all new names followed by missing old names\n            var i;\n            var typedState;\n            var changeDetected = false;\n\n            // create oldLookup\n            var oldLookup = {};\n            var objectName;\n            var className;\n            var sessionState;\n            for (i = 0; i < oldState.length; i++) {\n                // assume everthing is typed session state\n                //note: there is no error checking here for typedState\n                typedState = oldState[i];\n                objectName = typedState[weavecore.DynamicState.OBJECT_NAME];\n                // use '' instead of null to avoid \"null\"\n                oldLookup[objectName || ''] = typedState;\n            }\n            if (oldState.length !== newState.length)\n                changeDetected = true;\n\n            // create new Array with new DynamicState objects\n            var result = [];\n            for (i = 0; i < newState.length; i++) {\n                // assume everthing is typed session state\n                //note: there is no error checking here for typedState\n                typedState = newState[i];\n                objectName = typedState[weavecore.DynamicState.OBJECT_NAME];\n                className = typedState[weavecore.DynamicState.CLASS_NAME];\n                sessionState = typedState[weavecore.DynamicState.SESSION_STATE];\n                var oldTypedState = oldLookup[objectName || ''];\n                delete oldLookup[objectName || '']; // remove it from the lookup because it's already been handled\n\n                // If the object specified in newState does not exist in oldState, we don't need to do anything further.\n                // If the class is the same as before, then we can save a diff instead of the entire session state.\n                // If the class changed, we can't save only a diff -- we need to keep the entire session state.\n                // Replace the sessionState in the new DynamicState object with the diff.\n                if (oldTypedState !== undefined && oldTypedState[weavecore.DynamicState.CLASS_NAME] === className) {\n                    className = null; // no change\n                    diffValue = this.computeDiff(oldTypedState[weavecore.DynamicState.SESSION_STATE], sessionState);\n                    if (diffValue === undefined) {\n                        // Since the class name is the same and the session state is the same,\n                        // we only need to specify that this name is still present.\n                        result.push(objectName);\n\n                        if (!changeDetected && oldState[i][weavecore.DynamicState.OBJECT_NAME] != objectName)\n                            changeDetected = true;\n\n                        continue;\n                    }\n                    sessionState = diffValue;\n                }\n\n                // save in new array and remove from lookup\n                result.push(weavecore.DynamicState.create(objectName || null, className, sessionState)); // convert empty string to null\n                changeDetected = true;\n            }\n\n            // Anything remaining in the lookup does not appear in newState.\n            // Add DynamicState entries with an invalid className (\"delete\") to convey that each of these objects should be removed.\n            for (objectName in oldLookup) {\n                result.push(weavecore.DynamicState.create(objectName || null, SessionManager.DIFF_DELETE)); // convert empty string to null\n                changeDetected = true;\n            }\n\n            if (changeDetected)\n                return result;\n\n            return undefined; // no diff\n        } else // nested object\n        {\n            var diff; // start with no diff\n\n            // find old properties that changed value\n            for (var oldName in oldState) {\n                diffValue = computeDiff(oldState[oldName], newState[oldName]);\n                if (diffValue !== undefined) {\n                    if (!diff)\n                        diff = {};\n                    diff[oldName] = diffValue;\n                }\n            }\n\n            // find new properties\n            for (var newName in newState) {\n                if (oldState[newName] === undefined) {\n                    if (!diff)\n                        diff = {};\n                    diff[newName] = newState[newName]; // TODO: same object pointer.. potential problem?\n                }\n            }\n\n            return diff;\n        }\n    };\n\n    /**\n     * This modifies an existing diff to include an additional diff.\n     * @method combineDiff\n     * @param {Object} baseDiff The base diff which will be modified to include an additional diff.\n     * @param {Object} diffToAdd The diff to add to the base diff.  This diff will not be modified.\n     * @return {Object} The modified baseDiff, or a new diff object if baseDiff is a primitive value.\n     * see {{#crossLink \"SessionManager/computeDiff:method\"}}{{/crossLink}}\n     */\n    p.combineDiff = function (baseDiff, diffToAdd) {\n        var baseType = typeof (baseDiff); // the type of null is 'object'\n        var diffType = typeof (diffToAdd);\n\n        // special cases\n        if (baseDiff === null || baseDiff === undefined || diffToAdd === null || diffToAdd === undefined || baseType !== diffType || baseType !== 'object') {\n            if (diffType === 'object') // not a primitive, so make a copy\n                baseDiff = Object.getPrototypeOf(Object.create(diffToAdd)).slice(0); //TODO: find better solution for array copy(currently Shallow copy)\n            else\n                baseDiff = diffToAdd;\n        } else if (Array.isArray(baseDiff) && Array.isArray(diffToAdd)) {\n            var i;\n\n            // If either of the arrays look like DynamicState arrays, treat as such\n            if (weavecore.DynamicState.isDynamicStateArray(baseDiff) || weavecore.DynamicState.isDynamicStateArray(diffToAdd)) {\n                var typedState;\n                var objectName;\n\n                // create lookup: objectName -> old diff entry\n                // temporarily turn baseDiff into an Array of object names\n                var baseLookup = {};\n                for (i = 0; i < baseDiff.length; i++) {\n                    typedState = baseDiff[i];\n                    // note: no error checking for typedState\n                    if (typeof typedState === 'string' || typedState instanceof String || typedState === null || typedState === undefined)\n                        objectName = typedState;\n                    else\n                        objectName = typedState[weavecore.DynamicState.OBJECT_NAME];\n                    baseLookup[objectName] = typedState;\n                    // temporarily turn baseDiff into an Array of object names\n                    baseDiff[i] = objectName;\n                }\n                // apply each typedState diff appearing in diffToAdd\n                for (i = 0; i < diffToAdd.length; i++) {\n                    typedState = diffToAdd[i];\n                    // note: no error checking for typedState\n                    if (typeof typedState === 'string' || typedState instanceof String || typedState === null || typedState === undefined)\n                        objectName = typedState;\n                    else\n                        objectName = typedState[weavecore.DynamicState.OBJECT_NAME];\n\n                    // adjust names list so this name appears at the end\n                    if (baseLookup.hasOwnProperty(objectName)) {\n                        for (var j = baseDiff.indexOf(objectName); j < baseDiff.length - 1; j++)\n                            baseDiff[j] = baseDiff[j + 1];\n                        baseDiff[baseDiff.length - 1] = objectName;\n                    } else {\n                        baseDiff.push(objectName);\n                    }\n\n                    // apply diff\n                    var oldTypedState = baseLookup[objectName];\n                    if (typeof oldTypedState === 'string' || oldTypedState instanceof String || oldTypedState === null || oldTypedState === undefined) {\n                        if (typeof typedState === 'string' || typedState instanceof String || typedState === null || typedState === undefined)\n                            baseLookup[objectName] = typedState; // avoid unnecessary function call overhead\n                        else\n                            baseLookup[objectName] = Object.getPrototypeOf(Object.create(typedState)).slice(0); //TODO: Temp solution for Array Copy\n                    } else if (!(typeof typedState === 'string' || typedState instanceof String || typedState === null || typedState === undefined)) // update dynamic state\n                    {\n                        var className = typedState[weavecore.DynamicState.CLASS_NAME];\n                        // if new className is different and not null, start with a fresh typedState diff\n                        if (className && className != oldTypedState[weavecore.DynamicState.CLASS_NAME]) {\n                            baseLookup[objectName] = Object.getPrototypeOf(Object.create(typedState)).slice(0); //TODO: Temp solution for Array Copy\n                        } else // className hasn't changed, so combine the diffs\n                        {\n                            oldTypedState[weavecore.DynamicState.SESSION_STATE] = this.combineDiff(oldTypedState[weavecore.DynamicState.SESSION_STATE], typedState[weavecore.DynamicState.SESSION_STATE]);\n                        }\n                    }\n                }\n                // change baseDiff back from names to typed states\n                for (i = 0; i < baseDiff.length; i++)\n                    baseDiff[i] = baseLookup[baseDiff[i]];\n            } else // not typed session state\n            {\n                // overwrite old Array with new Array's values\n                i = baseDiff.length = diffToAdd.length;\n                while (i--) {\n                    var value = diffToAdd[i];\n                    if (value === null || value === undefined || typeof value !== 'object')\n                        baseDiff[i] = value; // avoid function call overhead\n                    else\n                        baseDiff[i] = this.combineDiff(baseDiff[i], value);\n                }\n            }\n        } else // nested object\n        {\n            for (var newName in diffToAdd)\n                baseDiff[newName] = this.combineDiff(baseDiff[newName], diffToAdd[newName]);\n        }\n\n        return baseDiff;\n    };\n\n    /**\n     * @public\n     * @property  DIFF_DELETE\n     * @static\n     * @readOnly\n     * @type String\n     * @default \"delete\"\n     */\n    Object.defineProperty(SessionManager, 'DIFF_DELETE', {\n        value: \"delete\"\n    });\n\n    weavecore.SessionManager = SessionManager;\n\n}());\n/*\n    Weave (Web-based Analysis and Visualization Environment)\n    Copyright (C) 2008-2011 University of Massachusetts Lowell\n\n    This file is a part of Weave.\n\n    Weave is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, Version 3,\n    as published by the Free Software Foundation.\n\n    Weave is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with Weave.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * Facilitates the creation of dynamic trees.\n */\n(function () {\n\n\n    //----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----\n\n    /**\n     * Constructs a new WeaveTreeItem.\n     * @param params An Object containing property values to set on the WeaveTreeItem.\n     *               If params is a String, both <code>label</code> and <code>data</code> will be set to that String.\n     */\n\n    function WeaveTreeItem(params) {\n        //set default values\n        if (params === undefined) params = null;\n        /**\n         * Set this to change the constructor used for initializing child items.\n         * This variable is intentionally uninitialized to avoid overwriting the value set by an extending class in its constructor.\n         */\n        this.childItemClass; // IMPORTANT - no initial value\n        this._recursion = {}; // recursionName -> Boolean\n        this._label = \"\";\n        this._children = null;\n        this._source = null;\n        /**\n         * Cached values that get invalidated when the source triggers callbacks.\n         */\n        this._cache = {};\n\n        /**\n         * Cached values of getCallbackCollection(source).triggerCounter.\n         */\n        this._counter = {};\n\n\n        //----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----\n\n        /**\n         * This can be set to either a String or a Function.\n         * This property is checked by Flex's default data descriptor.\n         * If this property is not set, the <code>data</code> property will be used as the label.\n         */\n        Object.defineProperty(this, 'label', {\n            get: function () {\n                const id = 'label';\n                if (this.isCached(id))\n                    return this._cache[id];\n\n                var str = this.getString(this._label, id);\n                if (!str && this.data !== null && this.data !== undefined)\n                    str = String(this.data);\n                return this.cache(id, str);\n            },\n            set: function (value) {\n                this._counter['label'] = undefined;\n                this._label = value;\n            }\n        });\n\n\n\n\n        Object.defineProperty(this, 'children', {\n            /**\n             * Gets a filtered copy of the child menu items.\n             * When this property is accessed, refresh() will be called except if refresh() is already being called.\n             * This property is checked by Flex's default data descriptor.\n             */\n            get: function () {\n                const id = 'children';\n                if (this.isCached(id))\n                    return this._cache[id];\n\n                var items = this.getObject(this._children, id);\n                if (!items)\n                    return this.cache(id, null);\n\n                var result = items.map(WeaveTreeItem._mapItems.bind(this), this.childItemClass).filter(WeaveTreeItem._filterItems.bind(this));\n                return this.cache(id, result);\n            },\n            /**\n             * This can be set to either an Array or a Function that returns an Array.\n             * The function can be like function():void or function(item:WeaveTreeItem):void.\n             * The Array can contain either WeaveTreeItems or Objects, each of which will be passed to the WeaveTreeItem constructor.\n             */\n            set: function (value) {\n                this._counter['children'] = undefined;\n                this._children = value;\n            }\n        });\n\n\n        /**\n         * A pointer to the ILinkableObject that created this node.\n         * This is used to determine when to invalidate cached values.\n         */\n        Object.defineProperty(this, 'source', {\n            get: function () {\n                if (this._source && WeaveAPI.SessionManager.objectWasDisposed(this._source)) {\n                    this.source = null;\n                }\n                return this._source;\n            },\n            set: function (value) {\n                if (this._source != value)\n                    this._counter = {};\n                this._source = value;\n            }\n        });\n\n        /**\n         * This can be any data associated with this tree item.\n         */\n        this.data = null;\n\n        if (typeof (params) === 'string') {\n            this.label = params;\n            this.data = params;\n        } else\n            for (var key in params)\n                this[key] = params[key];\n    }\n\n\n\n\n\n\n    //----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----\n    var p = WeaveTreeItem.prototype;\n    /**\n     * Computes a Boolean value from various structures\n     * @param param Either a Boolean, and Object like {not: param}, a Function, an ILinkableVariable, or an Array of those objects.\n     * @param recursionName A name used to keep track of recursion.\n     * @return A Boolean value derived from the param, or the param itself if called recursively.\n     */\n    p.getBoolean = function (param, recursionName) {\n        if (!this._recursion[recursionName]) {\n            try {\n                this._recursion[recursionName] = true;\n\n                if (this.isSimpleObject(param, 'not'))\n                    param = !this.getBoolean(param['not'], \"not_\" + recursionName);\n                if (this.isSimpleObject(param, 'or'))\n                    param = this.getBoolean(param['or'], \"or_\" + recursionName);\n                if (typeof (param) === \"function\")\n                    param = this.evalFunction(param);\n                if (param instanceof weavecore.LinkableVariable)\n                    param = param.getSessionState();\n                if (param instanceof Array) {\n                    var breakValue = recursionName.indexOf(\"or_\") === 0;\n                    for (var param in param) {\n                        param = this.getBoolean(param, \"item_\" + recursionName);\n                        if (param ? breakValue : !breakValue)\n                            break;\n                    }\n                }\n                param = param ? true : false;\n            } finally {\n                this._recursion[recursionName] = false;\n            }\n        }\n        return param;\n    };\n\n    /**\n     * Checks if an object has a single specified property.\n     */\n    p.isSimpleObject = function (object, singlePropertyName) {\n        if (!(object instanceof Object) || object.constructor !== Object)\n            return false;\n\n        var found = false;\n        for (var key in object) {\n            if (found)\n                return false; // two or more properties\n\n            if (key !== singlePropertyName)\n                return false; // not the desired property\n\n            found = true; // found the desired property\n        }\n        return found;\n    };\n\n    /**\n     * Gets a String value from a String or Function.\n     * @param param Either a String or a Function.\n     * @param recursionName A name used to keep track of recursion.\n     * @return A String value derived from the param, or the param itself if called recursively.\n     */\n    p.getString = function (param, recursionName) {\n        if (!this._recursion[recursionName]) {\n            try {\n                this._recursion[recursionName] = true;\n\n                if (typeof (param) === \"function\")\n                    param = this.evalFunction(param);\n                else\n                    param = param || '';\n            } finally {\n                this._recursion[recursionName] = false;\n            }\n        }\n        return param;\n    };\n\n    /**\n     * Evaluates a function to get an Object or just returns the non-Function Object passed in.\n     * @param param Either an Object or a Function.\n     * @param recursionName A name used to keep track of recursion.\n     * @return An Object derived from the param, or the param itself if called recursively.\n     */\n    p.getObject = function (param, recursionName) {\n        if (!this._recursion[recursionName]) {\n            try {\n                this._recursion[recursionName] = true;\n\n                if (typeof (param) === \"function\")\n                    param = this.evalFunction(param);\n            } finally {\n                this._recursion[recursionName] = false;\n            }\n        }\n        return param;\n    };\n\n    /**\n     * First tries calling a function with no parameters.\n     * If an ArgumentError is thrown, the function will called again, passing this WeaveTreeItem as the first parameter.\n     */\n    p.evalFunction = function (func) {\n        try {\n            // first try calling the function with no parameters\n            return func.call(this);\n        } catch (e) {\n            console.log(e);\n            /*if (!(e is ArgumentError))\n\t\t\t\t{\n\t\t\t\t\tif (e is Error)\n\t\t\t\t\t\ttrace((e as Error).getStackTrace());\n\t\t\t\t\tthrow e;\n\t\t\t\t}*/\n        }\n\n        // on ArgumentError, pass in this WeaveTreeItem as the first parameter\n        return func.call(this, this);\n    };\n\n    //----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----//----\n\n    /**\n     * Checks if cached value is valid.\n     * Always returns false if the source property is not set.\n     * @param id A string identifying a property.\n     * @return true if the property value has been cached.\n     */\n    p.isCached = function (id) {\n        if (this._source && WeaveAPI.SessionManager.objectWasDisposed(this._source))\n            source = null;\n        return this._source && this._counter[id] === WeaveAPI.SessionManager.getCallbackCollection(this._source).triggerCounter;\n    };\n\n    /**\n     * Retrieves or updates a cached value for a property.\n     * Does not cache the value if the source property is not set.\n     * @param id A string identifying a property.\n     * @param newValue Optional new value to cache for the property.\n     * @return The new or existing value for the property.\n     */\n    p.cache = function (id, newValue) {\n        if (arguments.length === 1)\n            return this._cache[id];\n\n        if (this._source && WeaveAPI.SessionManager.objectWasDisposed(this._source))\n            source = null;\n        if (this._source) {\n            this._counter[id] = WeaveAPI.SessionManager.getCallbackCollection(this._source).triggerCounter;\n            this._cache[id] = newValue;\n        }\n        return newValue;\n    };\n\n\n    /**\n     * Initializes an Array of WeaveTreeItems using an Array of objects to pass to the constructor.\n     * Any Arrays passed in will be flattened.\n     * @param WeaveTreeItem_implementation The implementation of WeaveTreeItem to use.\n     * @param items Item descriptors.\n     */\n    WeaveTreeItem.createItems = function (WeaveTreeItem_implementation, items) {\n        // flatten\n        var n = 0;\n        while (n !== items.length) {\n            n = items.length;\n            items = [].concat.apply(null, items);\n        }\n\n        return items.map(_mapItems, WeaveTreeItem_implementation).filter(_filterItems);\n    };\n\n    /**\n     * Used for mapping an Array of params objects to an Array of WeaveTreeItem objects.\n     * The \"this\" argument is used to specify a particular WeaveTreeItem implementation.\n     */\n    WeaveTreeItem._mapItems = function (item, i, a) {\n        // If the item is a Class definition, create an instance of that Class.\n        if (typeof (item) === 'function')\n            return new item();\n\n        // If the item is a String or an Object, we can pass it to the constructor.\n        if (typeof (item) === 'string' || (item !== null && item !== undefined && item.constructor.name === \"Object\")) {\n            var ItemClass = WeaveTreeItem;\n            return new ItemClass(item);\n        }\n\n        // If the item is any other type, return the original item.\n        return item;\n    };\n\n    /**\n     * Filters out null items.\n     */\n    WeaveTreeItem._filterItems = function (item, i, a) {\n        return item !== null || item !== undefined;\n    };\n\n\n\n    weavecore.WeaveTreeItem = WeaveTreeItem;\n\n}());\n/*\n    Weave (Web-based Analysis and Visualization Environment)\n    Copyright (C) 2008-2011 University of Massachusetts Lowell\n\n    This file is a part of Weave.\n\n    Weave is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, Version 3,\n    as published by the Free Software Foundation.\n\n    Weave is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with Weave.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This is a wrapper for a 2-dimensional Dictionary.\n *\n * @author adufilie\n * @author sanjay1909\n */\n\n(function () {\n    function Dictionary2D() {\n        this.dictionary = new Map();\n    }\n\n    var p = Dictionary2D.prototype;\n\n    /**\n     *\n     * @param key1 The first dictionary key.\n     * @param key2 The second dictionary key.\n     * @return The value in the dictionary.\n     */\n    p.get = function (key1, key2) {\n        var d2 = this.dictionary.get(key1);\n        return d2 ? d2.get(key2) : undefined;\n    };\n\n    /**\n     * This will add or replace an entry in the dictionary.\n     * @param key1 The first dictionary key.\n     * @param key2 The second dictionary key.\n     * @param value The value to put into the dictionary.\n     */\n    p.set = function (key1, key2, value) {\n        var d2 = this.dictionary.get(key1);\n        if (d2 === null || d2 === undefined)\n            d2 = new Map();\n        this.dictionary.set(key1, d2);\n        d2.set(key2, value);\n    };\n\n    /**\n     * This removes all values associated with the given primary key.\n     * @param key1 The first dictionary key.\n     */\n    p.removeAllPrimary = function (key1) {\n        this.dictionary.delete(key1);\n    };\n\n    /**\n     * This removes all values associated with the given secondary key.\n     * @param key2 The second dictionary key.\n     */\n    p.removeAllSecondary = function (key2) {\n        for (var key1 of this.dictionary.keys()) {\n            this.dictionary.get(key1).delete(key2);\n        }\n\n    };\n\n    /**\n     * This removes a value associated with the given primary and secondary keys.\n     * @param key1 The first dictionary key.\n     * @param key2 The second dictionary key.\n     * @return The value that was in the dictionary.\n     */\n    p.remove = function (key1, key2) {\n        var value;\n        var d2 = this.dictionary.get(key1);\n        if (d2) {\n            value = d2.get(key2);\n            d2.delete(key2);\n        }\n\n        // if entries remain in d2, keep it\n        for (var v2 of d2.values())\n            return value;\n\n        // otherwise, remove it\n        this.dictionary.delete(key1);\n\n        return value;\n    };\n\n    weavecore.Dictionary2D = Dictionary2D;\n}());\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n/**\n * LinkableVariable allows callbacks to be added that will be called when the value changes.\n * A LinkableVariable has an optional type restriction on the values it holds.\n *\n * @author adufilie\n * @author sanjay1909\n */\n\n(function () {\n    /**\n     * If a defaultValue is specified, callbacks will be triggered in a later frame unless they have already been triggered before then.\n     * This behavior is desirable because it allows the initial value to be handled by the same callbacks that handles new values.\n     * @param sessionStateType The type of values accepted for this sessioned property.\n     * @param verifier A function that returns true or false to verify that a value is accepted as a session state or not.  The function signature should be  function(value:*):Boolean.\n     * @param defaultValue The default value for the session state.\n     * @param defaultValueTriggersCallbacks Set this to false if you do not want the callbacks to be triggered one frame later after setting the default value.\n     */\n\n    function LinkableVariable(sessionStateType, verifier, defaultValue, defaultValueTriggersCallbacks) {\n        if (sessionStateType === undefined) sessionStateType = null;\n        if (verifier === undefined) verifier = null;\n        if (defaultValueTriggersCallbacks === undefined) defaultValueTriggersCallbacks = true;\n\n        weavecore.CallbackCollection.call(this);\n\n        /**\n         * This function is used to prevent the session state from having unwanted values.\n         * Function signature should be  function(value:*):Boolean\n         * @private\n         * @property _verifier\n         * @type function\n         */\n        this._verifier = verifier;\n\n        /**\n         * This is true if the session state has been set at least once.\n         */\n        this._sessionStateWasSet = false;\n\n        /**\n         * This is true if the _sessionStateType is a primitive type.\n         */\n        this._primitiveType = false;\n\n        /**\n         * Type restriction passed in to the constructor.\n         */\n        this._sessionStateType = null;\n\n        /**\n         * Cannot be modified externally because it is not returned by getSessionState()\n         */\n        this._sessionStateInternal = undefined;\n\n        /**\n         * Available externally via getSessionState()\n         */\n        this._sessionStateExternal = undefined;\n\n        this._locked = false;\n\n        Object.defineProperty(this, 'locked', {\n            get: function () {\n                return this._locked;\n            }\n        });\n\n        if (sessionStateType !== Object) {\n            this._sessionStateType = sessionStateType;\n            this._primitiveType = this._sessionStateType === \"string\" || this._sessionStateType === \"number\" || this._sessionStateType === \"boolean\";\n        }\n        if (defaultValue !== undefined) {\n            this.setSessionState(defaultValue);\n\n            // If callbacks were triggered, make sure callbacks are triggered again one frame later when\n            // it is possible for other classes to have a pointer to this object and retrieve the value.\n            if (defaultValueTriggersCallbacks && this._triggerCounter > weavecore.CallbackCollection.DEFAULT_TRIGGER_COUNT)\n                weavecore.StageUtils.callLater(this, _defaultValueTrigger.bind(this));\n        }\n    }\n\n    function _defaultValueTrigger() {\n        // unless callbacks were triggered again since the default value was set, trigger callbacks now\n        if (!this._wasDisposed && this._triggerCounter === weavecore.CallbackCollection.DEFAULT_TRIGGER_COUNT + 1)\n            this.triggerCallbacks();\n\n    }\n\n    /**\n     * This function will verify if a given value is a valid session state for this linkable variable.\n     * @param value The value to verify.\n     * @return A value of true if the value is accepted by this linkable variable.\n     */\n    function verifyValue(value) {\n        return this._verifier === null || this._verifier === undefined || this._verifier(value);\n    }\n\n    LinkableVariable.prototype = new weavecore.CallbackCollection();\n    LinkableVariable.prototype.constructor = LinkableVariable;\n\n    var p = LinkableVariable.prototype;\n\n    /**\n     * The type restriction passed in to the constructor.\n     */\n    p.getSessionStateType = function () {\n        return this._sessionStateType;\n    };\n\n    p.getSessionState = function () {\n        return this._sessionStateExternal;\n    };\n\n    p.setSessionState = function (value) {\n        if (this._locked)\n            return;\n\n        // cast value now in case it is not the appropriate type\n        if (this._sessionStateType !== null && this._sessionStateType !== undefined)\n            value = value;\n\n        // stop if verifier says it's not an accepted value\n        if (this._verifier !== null && this._verifier !== undefined && !this._verifier(value))\n            return;\n\n        var wasCopied = false;\n        var type = null;\n        if (value !== null && value !== undefined) {\n            type = typeof (value);\n\n            if (type === 'object' && value.constructor !== Object && value.constructor !== Array) {\n                // convert to dynamic Object prior to sessionStateEquals comparison\n                value = Object.create(value);\n                wasCopied = true;\n            }\n        }\n\n        // If this is the first time we are calling setSessionState(), including\n        // from the constructor, don't bother checking sessionStateEquals().\n        // Otherwise, stop if the value did not change.\n        if (this._sessionStateWasSet && this.sessionStateEquals(value))\n            return;\n\n        // If the value is a dynamic object, save a copy because we don't want\n        // two LinkableVariables to share the same object as their session state.\n        if (type === 'object') {\n            if (!wasCopied) {\n                if (value.constructor === Array) //TODO:Temp solution for array copy - its a shallow copy now\n                    value = Object.getPrototypeOf(Object.create(value)).slice(0);\n                else\n                    value = Object.create(value);\n            }\n\n\n            // save external copy, accessible via getSessionState()\n            this._sessionStateExternal = value;\n\n            // save internal copy\n            if (value.constructor === Array) // TODO:Temp solution for array copy - its a shallow copy now\n                this._sessionStateInternal = Object.getPrototypeOf(Object.create(value)).slice(0);\n            else\n                this._sessionStateInternal = Object.create(value);\n\n        } else {\n            // save primitive value\n            this._sessionStateExternal = this._sessionStateInternal = value;\n        }\n\n        // remember that we have set the session state at least once.\n        this._sessionStateWasSet = true;\n\n        this.triggerCallbacks();\n    };\n\n    /**\n     * This function is used in setSessionState() to determine if the value has changed or not.\n     * object that prototype this object may override this function.\n     */\n    p.sessionStateEquals = function (otherSessionState) {\n        if (this._primitiveType)\n            return this._sessionStateInternal === otherSessionState;\n\n        return weavecore.StandardLib.compare(this._sessionStateInternal, otherSessionState) === 0;\n    };\n\n\n    /**\n     * This function may be called to detect change to a non-primitive session state in case it has been modified externally.\n     */\n    p.detectChanges = function () {\n        if (!this.sessionStateEquals(this._sessionStateExternal))\n            this.triggerCallbacks();\n    };\n\n    p.lock = function () {\n        this._locked = true;\n    };\n\n\n\n\n\n    p.dispose = function () {\n        weavecore.CallbackCollection.prototype.dispose.call(this);\n        this.setSessionState(null);\n    };\n\n    weavecore.LinkableVariable = LinkableVariable;\n\n}());\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This is a LinkableVariable which limits its session state to Number values.\n * @author adufilie\n * @author sanjay1909\n */\n(function () {\n    function LinkableNumber(defaultValue, verifier, defaultValueTriggersCallbacks) {\n        // set default values for Parameters\n        if (defaultValue === undefined) defaultValue = NaN;\n        if (verifier === undefined) verifier = null;\n        if (defaultValueTriggersCallbacks === undefined) defaultValueTriggersCallbacks = true;\n\n        // Note: Calling  weavecore.LinkableVariable.call() will set all the default values for member variables defined in the super class,\n        // which means we can't set _sessionStateInternal = NaN here.\n        weavecore.LinkableVariable.call(this, \"number\", verifier, arguments.length ? defaultValue : undefined, defaultValueTriggersCallbacks);\n\n        Object.defineProperty(this, 'value', {\n            get: function () {\n                return this._sessionStateExternal;\n            },\n            set: function (val) {\n                this.setSessionState(val);\n            }\n        });\n    }\n\n    LinkableNumber.prototype = new weavecore.LinkableVariable();\n    LinkableNumber.prototype.constructor = LinkableNumber;\n\n    var p = LinkableNumber.prototype;\n\n\n    p.setSessionState = function (val) {\n        if (typeof (val) != \"number\") {\n            if (val === null || val === '' || val === undefined) val = NaN;\n            else val = Number(val);\n        }\n        weavecore.LinkableVariable.prototype.setSessionState.call(this, val);\n    };\n\n    p.sessionStateEquals = function (otherSessionState) {\n        // We must check for null here because we can't set _sessionStateInternal = NaN in the constructor.\n        if (this._sessionStateInternal === null || this._sessionStateInternal === undefined)\n            this._sessionStateInternal = this._sessionStateExternal = NaN;\n        if (isNaN(this._sessionStateInternal) && isNaN(otherSessionState))\n            return true;\n        return this._sessionStateInternal === otherSessionState;\n    };\n\n    weavecore.LinkableNumber = LinkableNumber;\n\n}());\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This is a LinkableVariable which limits its session state to Boolean values.\n * @author adufilie\n * @author sanjay1909\n */\n(function () {\n    function LinkableBoolean(defaultValue, verifier, defaultValueTriggersCallbacks) {\n        // set default values for Parameters\n        if (verifier === undefined) verifier = null;\n        if (defaultValueTriggersCallbacks === undefined) defaultValueTriggersCallbacks = true;\n\n        weavecore.LinkableVariable.call(this, \"boolean\", verifier, defaultValue, defaultValueTriggersCallbacks);\n\n        Object.defineProperty(this, 'value', {\n            get: function () {\n                return this._sessionStateExternal;\n            },\n            set: function (val) {\n                this.setSessionState(val);\n            }\n        });\n    }\n\n    LinkableBoolean.prototype = new weavecore.LinkableVariable();\n    LinkableBoolean.prototype.constructor = LinkableBoolean;\n\n    var p = LinkableBoolean.prototype;\n\n\n    p.setSessionState = function (val) {\n        if (typeof (val) === \"string\") {\n            val = weavecore.ObjectUtil.stringCompare(val, \"true\", true) === 0;\n        }\n        weavecore.LinkableVariable.prototype.setSessionState.call(this, val ? true : false);\n    };\n\n    weavecore.LinkableBoolean = LinkableBoolean;\n\n}());\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This is a LinkableVariable which limits its session state to string values.\n * @author adufilie\n * @author sanjay1909\n */\n(function () {\n    function LinkableString(defaultValue, verifier, defaultValueTriggersCallbacks) {\n        // set default values for Parameters\n\n        if (defaultValue === undefined) defaultValue = null;\n        if (verifier === undefined) verifier = null;\n        if (defaultValueTriggersCallbacks === undefined) defaultValueTriggersCallbacks = true;\n\n\n        weavecore.LinkableVariable.call(this, \"string\", verifier, arguments.length ? defaultValue : undefined, defaultValueTriggersCallbacks);\n\n        Object.defineProperty(this, 'value', {\n            get: function () {\n                return this._sessionStateExternal;\n            },\n            set: function (val) {\n                this.setSessionState(val);\n            }\n        });\n    }\n\n    LinkableString.prototype = new weavecore.LinkableVariable();\n    LinkableString.prototype.constructor = LinkableString;\n\n    var p = LinkableString.prototype;\n\n    p.setSessionState = function (val) {\n        if (val !== null)\n            val = String(val);\n        weavecore.LinkableVariable.prototype.setSessionState.call(this, val);\n    };\n\n    weavecore.LinkableString = LinkableString;\n\n}());\n/**\n * @module weavecore\n */\n\n//namesapce\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n(function () {\n    \"use strict\";\n\n    // constructor:\n    /**\n     * Private Class for use with {{#crossLink \"LinkableHashMap\"}}{{/crossLink}}\n     * @class ChildListCallbackInterface\n     * @extends CallbackCollection\n     * @private\n     * @constructor\n     */\n    function ChildListCallbackInterface() {\n\n        // specify the preCallback function in super() so list callback\n        // variables will be set before each change callback.\n        weavecore.CallbackCollection.call(this, this._setCallbackVariables);\n        /**\n         * returned by public getter\n         * @private\n         * @property _lastNameAdded\n         * @default null\n         * @type String\n         **/\n        this._lastNameAdded = null;\n        /**\n         * returned by public getter\n         * @private\n         * @property _lastObjectAdded\n         * @default null\n         * @type ILinkableObject\n         **/\n        this._lastObjectAdded = null;\n        /**\n         * returned by public getter\n         * @private\n         * @property _lastNameRemoved\n         * @default null\n         * @type String\n         **/\n        this._lastNameRemoved = null;\n        /**\n         * returned by public getter\n         * @private\n         * @property _lastObjectRemoved\n         * @default null\n         * @type ILinkableObject\n         **/\n        this._lastObjectRemoved = null;\n\n        /**\n         * This is the name of the object that was added prior to running callbacks.\n         * @public\n         * @property lastNameAdded\n         * @readOnly\n         * @type String\n         */\n        Object.defineProperty(this, 'lastNameAdded', {\n            get: function () {\n                return this._lastNameAdded;\n            }\n        });\n\n        /**\n         * This is the object that was added prior to running callbacks.\n         * @public\n         * @property lastObjectAdded\n         * @readOnly\n         * @type ILinkableObject\n         */\n        Object.defineProperty(this, 'lastObjectAdded', {\n            get: function () {\n                return this._lastObjectAdded;\n            }\n        });\n\n        /**\n         * This is the name of the object that was removed prior to running callbacks.\n         * @public\n         * @property lastNameRemoved\n         * @readOnly\n         * @type String\n         */\n        Object.defineProperty(this, 'lastNameRemoved', {\n            get: function () {\n                return this._lastNameRemoved;\n            }\n        });\n\n        /**\n         * This is the object that was removed prior to running callbacks.\n         * @public\n         * @property lastObjectRemoved\n         * @readOnly\n         * @type ILinkableObject\n         */\n        Object.defineProperty(this, 'lastObjectRemoved', {\n            get: function () {\n                return this._lastObjectRemoved;\n            }\n        });\n\n    }\n\n    ChildListCallbackInterface.prototype = new weavecore.CallbackCollection();\n    ChildListCallbackInterface.prototype.constructor = ChildListCallbackInterface;\n\n    var p = ChildListCallbackInterface.prototype;\n    /**\n     * This function will set the list callback variables:\n     *     lastNameAdded, lastObjectAdded, lastNameRemoved, lastObjectRemoved, childListChanged\n     * @method _setCallbackVariables\n     * @private\n     * @param {String} name This is the name of the object that was just added or removed from the hash map.\n     * @param {ILinkableObject} objectAdded This is the object that was just added to the hash map.\n     * @param {ILinkableObject} objectRemoved This is the object that was just removed from the hash map.\n     */\n    p._setCallbackVariables = function (name, objectAdded, objectRemoved) {\n        this._lastNameAdded = objectAdded ? name : null;\n        this._lastObjectAdded = objectAdded;\n        this._lastNameRemoved = objectRemoved ? name : null;\n        this._lastObjectRemoved = objectRemoved;\n    };\n\n    /**\n     * This function will run callbacks immediately, setting the list callback variables before each one.\n     * @method runCallbacks\n     * @param {String} name\n     * @param {ILinkableObject} objectAdded\n     * @param {ILinkableObject} objectRemoved\n     */\n    p.runCallbacks = function (name, objectAdded, objectRemoved) {\n        // remember previous values\n        var _name = this._lastNameAdded || this._lastNameRemoved;\n        var _added = this._lastObjectAdded;\n        var _removed = this._lastObjectRemoved;\n\n        this._runCallbacksImmediately(name, objectAdded, objectRemoved);\n\n        // restore previous values (in case an external JavaScript popup caused us to interrupt something else)\n        this._setCallbackVariables.call(this, _name, _added, _removed);\n    };\n\n\n\n    weavecore.ChildListCallbackInterface = ChildListCallbackInterface;\n\n}());\n/**\n * @module weavecore\n */\n\n// namespace\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n(function () {\n    \"use strict\";\n\n    // constructor:\n    /**\n     * This is used to dynamically attach a set of callbacks to different targets.\n     * The callbacks of the LinkableWatcher will be triggered automatically when the\n     * target triggers callbacks, changes, becomes null or is disposed.\n     * Instead of calling this constructor directly, consider using one of the {{#crossLink \"SessionManager\"}}{{/crossLink}} functions\n     * {{#crossLink \"SessionManager/registerLinkableChild:method\"}}{{/crossLink}} or  {{#crossLink \"SessionManager/registerDisposableChild:method\"}}{{/crossLink}} to make sure the watcher will get disposed automatically.\n     * @class LinkableWatcher\n     * @extends ILinkableObject\n     * @constructor\n     * @param {Class} typeRestriction Optionally restricts which type of targets this watcher accepts.\n     * @param {Function} immediateCallback A function to add as an immediate callback.\n     * @param {Function} groupedCallback A function to add as a grouped callback.\n     */\n    function LinkableWatcher(typeRestriction, immediateCallback, groupedCallback) {\n        if (typeRestriction === undefined) typeRestriction = null;\n        if (immediateCallback === undefined) immediateCallback = null;\n        if (groupedCallback === undefined) groupedCallback = null;\n\n        weavecore.ILinkableObject.call(this);\n\n        this._typeRestriction = typeRestriction;\n\n        if (immediateCallback !== null)\n            WeaveAPI.SessionManager.getCallbackCollection(this).addImmediateCallback(null, immediateCallback);\n\n        if (groupedCallback !== null)\n            WeaveAPI.SessionManager.getCallbackCollection(this).addGroupedCallback(null, groupedCallback);\n\n        this._target; // the current target or ancestor of the to-be-target\n        this._foundTarget = true; // false when _target is not the desired target\n        this._targetPath; // the path that is being watched\n        this._pathDependencies = new Map(); // Maps an ILinkableDynamicObject to its previous internalObject.\n\n        Object.defineProperty(this, 'targetPath', {\n            /**\n             * This is the path that is currently being watched for linkable object targets.\n             */\n            get: function () {\n                return this._targetPath ? this._targetPath.concat() : null;\n            },\n            /**\n             * This will set a path which should be watched for new targets.\n             * Callbacks will be triggered immediately if the path changes or points to a new target.\n             */\n            set: function (path) {\n                // do not allow watching the globalHashMap\n                if (path && path.length === 0)\n                    path = null;\n                if (weavecore.StandardLib.compare(this._targetPath, path) !== 0) {\n                    var cc = WeaveAPI.SessionManager.getCallbackCollection(this);\n                    cc.delayCallbacks();\n\n                    this._resetPathDependencies();\n                    this._targetPath = path;\n                    this._handlePath();\n                    cc.triggerCallbacks();\n\n                    cc.resumeCallbacks();\n                }\n            },\n            configurable: true\n        });\n\n        Object.defineProperty(this, 'target', {\n            /**\n             * This is the linkable object currently being watched.\n             * Setting this will unset the targetPath.\n             */\n            get: function () {\n                return this._foundTarget ? this._target : null;\n            },\n            set: function (newTarget) {\n                var cc = WeaveAPI.SessionManager.getCallbackCollection(this);\n                cc.delayCallbacks();\n                this.targetPath = null;\n                this.internalSetTarget(newTarget);\n                cc.resumeCallbacks();\n            },\n            configurable: true\n        });\n    }\n\n    LinkableWatcher.prototype = new weavecore.ILinkableObject();\n    LinkableWatcher.prototype.constructor = LinkableWatcher;\n\n    var p = LinkableWatcher.prototype;\n\n    /**\n     * This sets the new target to be watched without resetting targetPath.\n     * Callbacks will be triggered immediately if the new target is different from the old one.\n     */\n    p.internalSetTarget = function (newTarget) {\n        if (this._foundTarget && this._typeRestriction)\n            newTarget = newTarget;\n\n        // do nothing if the targets are the same.\n        if (_target === newTarget)\n            return;\n\n        var sm = WeaveAPI.SessionManager;\n\n        // unlink from old target\n        if (this._target) {\n            sm.getCallbackCollection(this._target).removeCallback(this._handleTargetTrigger);\n            sm.getCallbackCollection(this._target).removeCallback(this._handleTargetDispose);\n            // if we own the previous target, dispose it\n            if (sm.getLinkableOwner(this._target) === this)\n                sm.disposeObject(this._target);\n            else\n                sm.unregisterLinkableChild(this, this._target);\n        }\n\n        this._target = newTarget;\n\n        // link to new target\n        if (this._target) {\n            // we want to register the target as a linkable child (for busy status)\n            sm.registerLinkableChild(this, _target);\n            // we don't want the target triggering our callbacks directly\n            sm.getCallbackCollection(this._target).removeCallback(sm.getCallbackCollection(this).triggerCallbacks);\n            sm.getCallbackCollection(this._target).addImmediateCallback(this, this._handleTargetTrigger.bind(this), false, true);\n            // we need to know when the target is disposed\n            sm.getCallbackCollection(this._target).addDisposeCallback(this, this._handleTargetDispose.bind(this));\n        }\n\n        if (this._foundTarget)\n            this._handleTargetTrigger();\n    };\n\n\n    p._handleTargetTrigger = function () {\n        if (this._foundTarget)\n            WeaveAPI.SessionManager.getCallbackCollection(this).triggerCallbacks();\n        else\n            this._handlePath();\n    };\n\n\n\n    p._handleTargetDispose = function () {\n        if (this._targetPath) {\n            this._handlePath();\n        } else {\n            this._target = null;\n            WeaveAPI.SessionManager.getCallbackCollection(this).triggerCallbacks();\n        }\n    };\n\n    p._handlePath = function () {\n        if (!this._targetPath) {\n            this._foundTarget = true;\n            this.internalSetTarget(null);\n            return;\n        }\n\n        // traverse the path, finding ILinkableDynamicObject path dependencies along the way\n        var sm = WeaveAPI.SessionManager;\n        var node = WeaveAPI.globalHashMap;\n        var subPath = [];\n        for (var name of this._targetPath) {\n            if (node instanceof weavecore.LinkableDynamicObject)\n                this._addPathDependency(node);\n\n            subPath[0] = name;\n            var child = sm.getObject(node, subPath);\n            if (child) {\n                node = child;\n            } else {\n                // the path points to an object that doesn't exist yet\n                if (node instanceof weavecore.LinkableHashMap) {\n                    // watching childListCallbacks instead of the hash map accomplishes two things:\n                    // 1. eliminate unnecessary calls to _handlePath()\n                    // 2. avoid watching the root hash map (and registering the root as a child of the watcher)\n                    node = node.childListCallbacks;\n                }\n                this._foundTarget = false;\n                if (node instanceof weavecore.LinkableDynamicObject) {\n                    if (this._target !== null) {\n                        // path dependency code will detect changes to this node\n                        this.internalSetTarget(null);\n                        // must trigger here because _foundtarget is false\n                        sm.getCallbackCollection(this).triggerCallbacks();\n                    }\n                } else\n                    this.internalSetTarget(node);\n                return;\n            }\n        }\n\n        // we found a desired target if there is no type restriction or the object fits the restriction\n        this._foundTarget = !this._typeRestriction || node instanceof this._typeRestriction;\n        this.internalSetTarget(node);\n    };\n\n    p._addPathDependency = function (ldo) {\n        var sm = WeaveAPI.SessionManager;\n        if (!this._pathDependencies.get(ldo)) {\n            this._pathDependencies.set(ldo, ldo.internalObject);\n            sm.getCallbackCollection(ldo).addImmediateCallback(this, this._handlePathDependencies.bind(this));\n            sm.getCallbackCollection(ldo).addDisposeCallback(this, this._handlePathDependencies.bind(this));\n        }\n    };\n\n\n    p._handlePathDependencies = function () {\n        var sm = WeaveAPI.SessionManager;\n        for (var key of this._pathDependencies.keys()) {\n            var ldo = key;\n            if (sm.objectWasDisposed(ldo) || ldo.internalObject !== this._pathDependencies.get(ldo)) {\n                this._resetPathDependencies();\n                this._handlePath();\n                return;\n            }\n        }\n    };\n\n    p._resetPathDependencies = function () {\n        var sm = WeaveAPI.SessionManager;\n        for (var key of this._pathDependencies.keys())\n            sm.getCallbackCollection(key).removeCallback(this._handlePathDependencies);\n        this._pathDependencies = new Map();\n    };\n\n\n    p.dispose = function () {\n        this._targetPath = null;\n        this._target = null;\n        // everything else will be cleaned up automatically\n    };\n\n    weavecore.LinkableWatcher = LinkableWatcher;\n\n    /*\n\t\t\t// JavaScript test code for path dependency case\n\t\t\tvar lhm = weave.path('lhm').remove().request('LinkableHashMap');\n\n\t\t\tvar a = lhm.push('a').request('LinkableDynamicObject').state(lhm.getPath('b', null));\n\n\t\t\ta.addCallback(function () {\n\t\t\tif (a.getType(null))\n\t\t\tconsole.log('a.getState(null): ', JSON.stringify(a.getState(null)));\n\t\t\telse\n\t\t\tconsole.log('a has no internal object');\n\t\t\t}, false, true);\n\n\t\t\tvar b = lhm.push('b').request('LinkableDynamicObject').state(lhm.getPath('c'));\n\n\t\t\t// a has no internal object\n\n\t\t\tvar c = lhm.push('c').request('LinkableDynamicObject').request(null, 'LinkableString').state(null, 'c value');\n\n\t\t\t// a.getState(null): []\n\t\t\t// a.getState(null): [{\"className\":\"weave.core::LinkableString\",\"objectName\":null,\"sessionState\":null}]\n\t\t\t// a.getState(null): [{\"className\":\"weave.core::LinkableString\",\"objectName\":null,\"sessionState\":\"c value\"}]\n\n\t\t\tb.remove(null);\n\n\t\t\t// a has no internal object\n\n\t\t\tb.request(null, 'LinkableString').state(null, 'b value');\n\n\t\t\t// a.getState(null): null\n\t\t\t// a.getState(null): \"b value\"\n\t\t*/\n}());\n/**\n * @module weavecore\n */\n\n//namesapce\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n(function () {\n    \"use strict\";\n\n    // constructor:\n    /**\n     * Allows dynamically creating instances of objects inheriting ILinkableObject at runtime.\n     * The session state is an Array of {{#crossLink \"DynamicState\"}}{{/crossLink}} objects.\n     * @class LinkableHashMap\n     * @extends CallbackCollection\n     * @constructor\n     * @param {Class} typeRestriction If specified, this will limit the type of objects that can be added to this LinkableHashMap.\n     */\n    function LinkableHashMap(typeRestriction) {\n        if (typeRestriction === undefined) typeRestriction = null;\n\n        weavecore.CallbackCollection.call(this);\n\n        /**\n         * restricts the type of object that can be stored\n         * @private\n         * @property _typeRestriction\n         * @type Class\n         */\n        this._typeRestriction;\n        /**\n         * qualified class name of _typeRestriction\n         * @private\n         * @property _typeRestrictionClassName\n         * @type String\n         */\n        this._typeRestrictionClassName;\n\n        if (typeRestriction !== null && typeRestriction !== undefined) {\n            this._typeRestriction = typeRestriction;\n            this._typeRestrictionClassName = typeRestriction.name;\n        }\n\n        /**\n         * @private\n         * @readOnly\n         * @property _childListCallbacks\n         * @type ChildListCallbackInterface\n         */\n        Object.defineProperty(this, '_childListCallbacks', {\n            value: WeaveAPI.SessionManager.registerLinkableChild(this, new weavecore.ChildListCallbackInterface())\n        });\n\n        /**\n         * an ordered list of names appearing in _nameToObjectMap\n         * @private\n         * @readOnly\n         * @property _orderedNames\n         * @type Array\n         */\n        Object.defineProperty(this, '_orderedNames', {\n            value: []\n        });\n\n        /**\n         * maps an identifying name to an object\n         * @private\n         * @readOnly\n         * @property _nameToObjectMap\n         * @type Object\n         */\n        Object.defineProperty(this, '_nameToObjectMap', {\n            value: {}\n        });\n\n        /**\n         * maps an object to an identifying name\n         * @private\n         * @readOnly\n         * @property _objectToNameMap\n         * @type Map\n         */\n        Object.defineProperty(this, '_objectToNameMap', {\n            value: new Map()\n        });\n\n        /**\n         * maps an identifying name to a value of true if that name is locked.\n         * @private\n         * @readOnly\n         * @property _nameIsLocked\n         * @type Object\n         */\n        Object.defineProperty(this, '_nameIsLocked', {\n            value: {}\n        });\n\n        /**\n         * maps a previously used name to a value of true.  used when generating unique names.\n         * @private\n         * @readOnly\n         * @property _previousNameMap\n         * @type Object\n         */\n        Object.defineProperty(this, '_previousNameMap', {\n            value: {}\n        });\n\n        /**\n         * The child type restriction, or null if there is none.\n         * @public\n         * @readOnly\n         * @property typeRestriction\n         * @type Class\n         */\n        Object.defineProperty(this, 'typeRestriction', {\n            get: function () {\n                return this._typeRestriction;\n            }\n        });\n\n        /**\n         * This is an interface for adding and removing callbacks that will get triggered immediately\n         * when the list of child objects changes.\n         * @public\n         * @readOnly\n         * @property childListCallbacks\n         * @type ChildListCallbackInterface\n         */\n        Object.defineProperty(this, 'childListCallbacks', {\n            get: function () {\n                return this._childListCallbacks;\n            }\n        });\n    }\n\n    LinkableHashMap.prototype = new weavecore.CallbackCollection();\n    LinkableHashMap.prototype.constructor = LinkableHashMap;\n\n    var p = LinkableHashMap.prototype;\n\n    /**\n     * This function returns an ordered list of names in the hash map.\n     * @method getNames\n     * @param {Class} filter If specified, names of objects that are not of this type will be filtered out.\n     * @return {Array} A copy of the ordered list of names of objects contained in this LinkableHashMap.\n     */\n    p.getNames = function (filter) {\n        // set default value for parameter\n        if (filter === undefined) filter = null;\n        var result = [];\n        for (var i = 0; i < this._orderedNames.length; i++) {\n            var name = this._orderedNames[i];\n            if (filter === null || this._nameToObjectMap[name] instanceof filter)\n                result.push(name);\n        }\n        return result;\n    };\n\n    /**\n     * This function returns an ordered list of objects in the hash map.\n     * @method getObjects\n     * @param {Class} filter If specified, objects that are not of this type will be filtered out.\n     * @return {Array} An ordered Array of objects that correspond to the names returned by getNames(filter).\n     */\n    p.getObjects = function (filter) {\n        // set default value for parameter\n        if (filter === undefined) filter = null;\n        var result = [];\n        for (var i = 0; i < this._orderedNames.length; i++) {\n            var name = this._orderedNames[i];\n            var object = this._nameToObjectMap[name];\n            if (filter === null || filter === undefined || object instanceof filter)\n                result.push(object);\n        }\n        return result;\n    };\n\n    /**\n     * This function gets the object associated with the specified name.\n     * @method getObject\n     * @param {String} name The identifying name to associate with an object.\n     * @return {ILinkableObject} The object associated with the given name.\n     */\n    p.getObject = function (name) {\n        return this._nameToObjectMap[name];\n    };\n\n    /**\n     * This function gets the name of the specified object in the hash map.\n     * @getName\n     * @param {ILinkableObject} object An object contained in this LinkableHashMap.\n     * @return {String} The name associated with the object, or null if the object was not found.\n     */\n    p.getName = function (object) {\n        return this._objectToNameMap.get(object);\n    };\n\n    /**\n     * This will reorder the names returned by getNames().\n     * Any names appearing in newOrder that do not appear in getNames() will be ignored.\n     * Callbacks will be called if the new name order differs from the old order.\n     * @method setNameOrder\n     * @param {Array} newOrder The new desired ordering of names.\n     */\n    p.setNameOrder = function (newOrder) {\n        var changeDetected = false;\n        var name;\n        var i;\n        var originalNameCount = this._orderedNames.length; // remembers how many names existed before appending\n        var haveSeen = {}; // to remember which names have been seen in newOrder\n        // append each name in newOrder to the end of _orderedNames\n        for (i = 0; i < newOrder.length; i++) {\n            name = newOrder[i];\n            // ignore bogus names and append each name only once.\n            if (this._nameToObjectMap[name] === undefined || haveSeen[name] !== undefined)\n                continue;\n            haveSeen[name] = true; // remember that this name was appended to the end of the list\n            this._orderedNames.push(name); // add this name to the end of the list\n        }\n        // Now compare the ordered appended items to the end of the original list.\n        // If the order differs, set _nameOrderChanged to true.\n        // Meanwhile, set old name entries to null so they will be removed in the next pass.\n        var appendedCount = this._orderedNames.length - originalNameCount;\n        for (i = 0; i < appendedCount; i++) {\n            var newIndex = originalNameCount + i;\n            var oldIndex = this._orderedNames.indexOf(this._orderedNames[newIndex]);\n            if (newIndex - oldIndex !== appendedCount)\n                changeDetected = true;\n            this._orderedNames[oldIndex] = null;\n        }\n        // remove array items that have been set to null\n        var out = 0;\n        for (i = 0; i < this._orderedNames.length; i++)\n            if (this._orderedNames[i] !== null && this._orderedNames[i] !== undefined)\n                this._orderedNames[out++] = this._orderedNames[i];\n        this._orderedNames.length = out;\n        // if the name order changed, run child list callbacks\n        if (changeDetected)\n            this._childListCallbacks.runCallbacks(null, null, null);\n    };\n\n    /**\n     * This function creates an object in the hash map if it doesn't already exist.\n     * If there is an existing object associated with the specified name, it will be kept if it\n     * is the specified type, or replaced with a new instance of the specified type if it is not.\n     * @method requestObject\n     * @param {String} name The identifying name of a new or existing object.\n     * @param {Class} classDef The Class of the desired object type.\n     * @param {Boolean} lockObject If this is true, the object will be locked in place under the specified name.\n     * @return {Object} The object under the requested name of the requested type, or null if an error occurred.\n     */\n    p.requestObject = function (name, classDef, lockObject) {\n        var className = classDef ? classDef.name : null;\n        var result = this._initObjectByClassName.call(this, name, className, lockObject);\n        return classDef ? result : null;\n    };\n\n    /**\n     * This function will copy the session state of an ILinkableObject to a new object under the given name in this LinkableHashMap.\n     * @method requestObjectCopy\n     * @param {String} newName A name for the object to be initialized in this LinkableHashMap.\n     * @param {ILinkableObject} objectToCopy An object to copy the session state from.\n     * @return {ILinkableObject} The new object of the same type, or null if an error occurred.\n     */\n    p.requestObjectCopy = function (name, objectToCopy) {\n        if (objectToCopy === null || objectToCopy === undefined) {\n            this.removeObject(name);\n            return null;\n        }\n\n        this.delayCallbacks(); // make sure callbacks only trigger once\n        var classDef = objectToCopy.constructor; //ClassUtils.getClassDefinition(className);\n        var sessionState = WeaveAPI.SessionManager.getSessionState(objectToCopy);\n        var object = requestObject(name, classDef, false);\n        if (object !== null && object !== undefined)\n            WeaveAPI.SessionManager.setSessionState(object, sessionState);\n        this.resumeCallbacks();\n\n        return object;\n    };\n\n    /**\n     * This function will rename an object by making a copy and removing the original.\n     * @method renameObject\n     * @param {String} oldName The name of an object to replace.\n     * @param {String} newName The new name to use for the copied object.\n     * @return {ILinkableObject} The copied object associated with the new name, or the original object if newName is the same as oldName.\n     */\n    p.renameObject = function (oldName, newName) {\n        if (oldName !== newName) {\n            this.delayCallbacks();\n\n            // prepare a name order that will put the new name in the same place the old name was\n            var newNameOrder = this._orderedNames.concat();\n            var index = newNameOrder.indexOf(oldName);\n            if (index >= 0)\n                newNameOrder.splice(index, 1, newName);\n\n            this.requestObjectCopy(newName, getObject(oldName));\n            this.removeObject(oldName);\n            this.setNameOrder(newNameOrder);\n\n            this.resumeCallbacks();\n        }\n        return this.getObject(newName);\n    };\n\n    /**\n     * If there is an existing object associated with the specified name, it will be kept if it\n     * is the specified type, or replaced with a new instance of the specified type if it is not.\n     * @method _initObjectByClassName\n     * @private\n     * @param {String} name The identifying name of a new or existing object.  If this is null, a new one will be generated.\n     * @param {String} className The qualified class name of the desired object type.\n     * @param {Boolean} lockObject If this is set to true, lockObject() will be called on the given name.\n     * @return {ILinkableObject} The object associated with the given name, or null if an error occurred.\n     */\n    p._initObjectByClassName = function (name, className, lockObject) {\n        if (className) {\n            // if no name is specified, generate a unique one now.\n            if (!name)\n                name = generateUniqueName(className.split(\"::\").pop());\n            if (className !== \"delete\") // to-do Add Support for class Utils - delete is temp solution\n            {\n                // If this name is not associated with an object of the specified type,\n                // associate the name with a new object of the specified type.\n                console.log(className);\n                var classDef = eval('weavecore.' + className); //TODO:remove hardcoded weavecore with namespace\n                var object = this._nameToObjectMap[name];\n                if (!object || object.constructor !== classDef)\n                    this._createAndSaveNewObject.call(this, name, classDef, lockObject);\n                else if (lockObject)\n                    this._lockObject(name);\n\n            } else {\n                this.removeObject(name);\n            }\n        } else {\n            this.removeObject(name);\n        }\n        return this._nameToObjectMap[name];\n    };\n\n    /**\n     * @method _createAndSaveNewObject\n     * @private\n     * @param {String} name The identifying name to associate with a new object.\n     * @param {Class} classDef The Class definition used to instantiate a new object.\n     * @param {Boolean} lockObject If this is set to true, lockObject() will be called on the given name.\n     */\n    p._createAndSaveNewObject = function (name, classDef, lockObject) {\n        if (this._nameIsLocked[name])\n            return;\n\n        // remove any object currently using this name\n        this.removeObject(name);\n        // create a new object\n        var object = new classDef();\n        // register the object as a child of this LinkableHashMap\n        WeaveAPI.SessionManager.registerLinkableChild(this, object);\n        // save the name-object mappings\n        this._nameToObjectMap[name] = object;\n        this._objectToNameMap.set(object, name);\n        // add the name to the end of _orderedNames\n        this._orderedNames.push(name);\n        // remember that this name was used.\n        this._previousNameMap[name] = true;\n\n        if (lockObject)\n            this._lockObject(name);\n\n        // make sure the callback variables signal that the object was added\n        this._childListCallbacks.runCallbacks(name, object, null);\n    };\n\n    /**\n     * This function will lock an object in place for a given identifying name.\n     * If there is no object using the specified name, this function will have no effect.\n     * @method _lockObject\n     * @private\n     * @param {String} name The identifying name of an object to lock in place.\n     */\n    p._lockObject = function (name) {\n        if (name !== null && name !== undefined && this._nameToObjectMap[name] !== null && this._nameToObjectMap[name] !== undefined)\n            this._nameIsLocked[name] = true;\n    };\n\n    /**\n     * This function will return true if the specified object was previously locked.\n     * @method objectIsLocked\n     * @param {String} name The name of an object.\n     * @return {Boolean}\n     */\n    p.objectIsLocked = function (name) {\n        return this._nameIsLocked[name] ? true : false;\n    };\n\n    /**\n     * This function removes an object from the hash map.\n     * @method removeObject\n     * @param {String} name The identifying name of an object previously saved with setObject().\n     */\n    p.removeObject = function (name) {\n        if (!name || this._nameIsLocked[name])\n            return;\n\n        var object = this._nameToObjectMap[name];\n        if (object === null || object === undefined)\n            return; // do nothing if the name isn't mapped to an object.\n\n        //console.log(LinkableHashMap, \"removeObject\",name,object);\n        // remove name & associated object\n        delete this._nameToObjectMap[name];\n        this._objectToNameMap.delete(object);\n        var index = this._orderedNames.indexOf(name);\n        this._orderedNames.splice(index, 1);\n\n        // make sure the callback variables signal that the object was removed\n        this._childListCallbacks.runCallbacks(name, null, object);\n\n        // dispose the object AFTER the callbacks know that the object was removed\n        WeaveAPI.SessionManager.disposeObject(object);\n    };\n\n    /**\n     * This function attempts to removes all objects from this LinkableHashMap.\n     * Any objects that are locked will remain.\n     * @method removeAllObjects\n     */\n    p.removeAllObjects = function () {\n        this.delayCallbacks();\n        var orderedNamesCopy = this._orderedNames.concat();\n        for (var i = 0; i < orderedNamesCopy.length; i++) {\n            this.removeObject(orderedNamesCopy[i]);\n        }\n        this.resumeCallbacks();\n    };\n\n    /**\n     * This function removes all objects from this LinkableHashMap.\n     * adds implementaion to {{#crossLink \"CallbackCollection/dispose:method\"}}{{/crossLink}}\n     * @method dispose\n     */\n    p.dispose = function dispose() {\n\n        weavecore.CallbackCollection.prototype.dispose.call(this);\n\n        // first, remove all objects that aren't locked\n        this.removeAllObjects();\n\n        // remove all locked objects\n        var orderedNamesCopy = this._orderedNames.concat();\n        for (var i = 0; i < orderedNamesCopy.length; i++) {\n            var name = orderedNamesCopy[i];\n            this._nameIsLocked[name] = undefined; // make sure removeObject() will carry out its action\n            this.removeObject(name);\n        }\n    };\n\n    /**\n     * This will generate a new name for an object that is different from all the names of objects previously used in this LinkableHashMap.\n     * @method generateUniqueName\n     * @param {String} baseName The name to start with.  If the name is already in use, an integer will be appended to create a unique name.\n     */\n    p.generateUniqueName = function (baseName) {\n        var count = 1;\n        var name = baseName;\n        while (this._previousNameMap[name] !== undefined)\n            name = baseName + (++count);\n        return name;\n    };\n\n    /**\n     * This gets the session state of this composite object.\n     * @method getSessionState\n     * @return {Array} An Array of {{#crossLink \"DynamicState\"}}{{/crossLink}} objects which compose the session state for this object.\n     */\n    p.getSessionState = function () {\n        var result = new Array(this._orderedNames.length);\n        for (var i = 0; i < this._orderedNames.length; i++) {\n            var name = this._orderedNames[i];\n            var object = this._nameToObjectMap[name];\n            result[i] = weavecore.DynamicState.create(\n                name,\n                object.constructor.name,\n                WeaveAPI.SessionManager.getSessionState(object)\n            );\n        }\n        return result;\n    };\n\n    /**\n     * This sets the session state of this composite object.\n     * @method setSessionState\n     * @param {Array} newState An Array of child name Strings or {{#crossLink \"DynamicState\"}}{{/crossLink}} objects containing the new values and types for child ILinkableObjects.\n     * @param {Boolean} removeMissingDynamicObjects If true, this will remove any child objects that do not appear in the session state.\n     *     As a special case, a null session state will result in no change regardless of the removeMissingDynamicObjects value.\n     */\n    p.setSessionState = function (newStateArray, removeMissingDynamicObjects) {\n        // special case - no change\n        if (newStateArray === null || newStateArray === undefined)\n            return;\n\n        this.delayCallbacks();\n\n        // first pass: make sure the types match and sessioned properties are instantiated.\n        var i;\n        var objectName;\n        var className;\n        var typedState;\n        var remainingObjects = removeMissingDynamicObjects ? {} : null; // maps an objectName to a value of true\n        var newObjects = {}; // maps an objectName to a value of true if the object is newly created as a result of setting the session state\n        var newNameOrder = []; // the order the object names appear in the vector\n        if (newStateArray !== null && newStateArray !== undefined) {\n            // initialize all the objects before setting their session states because they may refer to each other.\n            for (i = 0; i < newStateArray.length; i++) {\n                typedState = newStateArray[i];\n                if (!weavecore.DynamicState.isDynamicState(typedState))\n                    continue;\n                objectName = typedState[weavecore.DynamicState.OBJECT_NAME];\n                className = typedState[weavecore.DynamicState.CLASS_NAME];\n                // ignore objects that do not have a name because they may not load the same way on different application instances.\n                if (objectName === null || objectName === undefined)\n                    continue;\n                // if className is not specified, make no change\n                if (className === null || className === undefined)\n                    continue;\n                // initialize object and remember if a new one was just created\n                if (this._nameToObjectMap[objectName] !== this._initObjectByClassName.call(this, objectName, className))\n                    newObjects[objectName] = true;\n            }\n            // second pass: copy the session state for each property that is defined.\n            // Also remember the ordered list of names that appear in the session state.\n            for (i = 0; i < newStateArray.length; i++) {\n                typedState = newStateArray[i];\n                if (typeof (typedState) === \"string\") {\n                    objectName = typedState;\n                    if (removeMissingDynamicObjects)\n                        remainingObjects[objectName] = true;\n                    newNameOrder.push(objectName);\n                    continue;\n                }\n\n                if (!weavecore.DynamicState.isDynamicState(typedState))\n                    continue;\n                objectName = typedState[weavecore.DynamicState.OBJECT_NAME];\n                if (objectName === null || objectName === undefined)\n                    continue;\n                var object = this._nameToObjectMap[objectName];\n                if (object === null || object === undefined)\n                    continue;\n                // if object is newly created, we want to apply an absolute session state\n                WeaveAPI.SessionManager.setSessionState(object, typedState[weavecore.DynamicState.SESSION_STATE], newObjects[objectName] || removeMissingDynamicObjects);\n                if (removeMissingDynamicObjects)\n                    remainingObjects[objectName] = true;\n                newNameOrder.push(objectName);\n            }\n        }\n        if (removeMissingDynamicObjects) {\n            // third pass: remove objects based on the Boolean flags in remainingObjects.\n            var orderedNamesCopy = this._orderedNames.concat();\n            for (var j = 0; j < orderedNamesCopy.length; j++) {\n                objectName = torderedNamesCopy[j];\n                if (remainingObjects[objectName] !== true) {\n                    //trace(LinkableHashMap, \"missing value: \"+objectName);\n                    this.removeObject(objectName);\n                }\n            }\n        }\n        // update name order AFTER objects have been added and removed.\n        this.setNameOrder(newNameOrder);\n\n        this.resumeCallbacks();\n    };\n\n    weavecore.LinkableHashMap = LinkableHashMap;\n}());\ncreatejs.Ticker.setFPS(50);\n//createjs.Ticker.\n\n// constructor:\n\nif (typeof window === 'undefined') {\n    this.WeaveAPI = this.WeaveAPI || {};\n} else {\n    window.WeaveAPI = window.WeaveAPI || {};\n}\n\n//Object.defineProperty(WeaveAPI, '_sessionManager', {\n// value: new SessionManager()\n//});\n//Object.defineProperty(WeaveAPI, '_stageUtils', {\n//value: new weave.core.StageUtils()\n//});\n\nObject.defineProperty(WeaveAPI, 'TASK_PRIORITY_IMMEDIATE', {\n    value: 0\n});\n\nObject.defineProperty(WeaveAPI, 'TASK_PRIORITY_HIGH', {\n    value: 1\n});\n\nObject.defineProperty(WeaveAPI, 'TASK_PRIORITY_NORMAL', {\n    value: 2\n});\n\nObject.defineProperty(WeaveAPI, 'TASK_PRIORITY_LOW', {\n    value: 3\n});\n\n/* WeaveAPI.__defineGetter__(\"SessionManager\", function(){\n     return WeaveAPI._sessionManager;\n });\n\n WeaveAPI.__defineGetter__(\"StageUtils\", function(){\n     return WeaveAPI._stageUtils;\n });*/\nWeaveAPI.SessionManager = new weavecore.SessionManager();\nWeaveAPI.globalHashMap = new weavecore.LinkableHashMap();\n/**\n * @module weavecore\n */\n\n//namesapce\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n(function () {\n    \"use strict\";\n\n    // constructor:\n    /**\n     * This object links to an internal ILinkableObject.\n     * The internal object can be either a local one or a global one identified by a global name.\n     * @class LinkableDynamicObject\n     * @extends LinkableWatcher\n     * @constructor\n     * @param {Class} typeRestriction If specified, this will limit the type of objects that can be added to this LinkableHashMap.\n     */\n    function LinkableDynamicObject(typeRestriction) {\n        if (typeRestriction === undefined) typeRestriction = null;\n        // this is a constraint on the type of object that can be linked\n        this._typeRestrictionClassName;\n        this._typeRestriction = typeRestriction;\n        // when this is true, the linked object cannot be changed\n        this._locked = false;\n\n        weavecore.LinkableWatcher.call(this, typeRestriction);\n        if (typeRestriction)\n            this._typeRestrictionClassName = typeRestriction.constructor.name;\n\n        // the callback collection for this object\n        // private const\n        Object.defineProperty(this, '_cc', {\n            value: WeaveAPI.SessionManager.registerDisposableChild(this, new weavecore.CallbackCollection()),\n            writable: false\n        });\n\n        Object.defineProperty(LinkableDynamicObject, 'ARRAY_CLASS_NAME', {\n            value: 'Array'\n        });\n\n        /**\n         * @inheritDoc\n         */\n        Object.defineProperty(this, 'internalObject', {\n            get: function () {\n                return this.target;\n            }\n        });\n\n        // override public\n        Object.defineProperty(this, 'targetPath', {\n\n            set: function (path) {\n                if (this._locked)\n                    return;\n                weavecore.LinkableWatcher.prototype.targetPath = path;\n            },\n            configurable: true\n        });\n\n        // override public\n        Object.defineProperty(this, 'target', {\n\n            set: function (newTarget) {\n                if (this._locked)\n                    return;\n\n                if (!newTarget) {\n                    weavecore.LinkableWatcher.prototype.target = null;\n                    return;\n                }\n\n                this._cc.delayCallbacks();\n\n                // if the target can be found by a path, use the path\n                var sm = WeaveAPI.SessionManager;\n                var path = sm.getPath(WeaveAPI.globalHashMap, newTarget);\n                if (path) {\n                    this.targetPath = path;\n                } else {\n                    // it's ok to assign a local object that we own or that doesn't have an owner yet\n                    // otherwise, unset the target\n                    var owner = sm.getLinkableOwner(newTarget);\n                    if (owner === this || !owner)\n                        weavecore.LinkableWatcher.prototype.target = newTarget;\n                    else\n                        weavecore.LinkableWatcher.prototype.target = null;\n                }\n\n                this._cc.resumeCallbacks();\n            },\n            configurable: true\n        });\n\n\n        Object.defineProperty(this, 'globalName', {\n            /**\n             * This is the name of the linked global object, or null if the internal object is local.\n             */\n            get: function () {\n                if (this._targetPath && this._targetPath.length == 1)\n                    return this._targetPath[0];\n                return null;\n            },\n            /**\n             * This function will change the internalObject if the new globalName is different, unless this object is locked.\n             * If a new global name is given, the session state of the new global object will take precedence.\n             * @param newGlobalName This is the name of the global object to link to, or null to unlink from the current global object.\n             */\n            set: function (newGlobalName) {\n                if (this._locked)\n                    return;\n\n                // change empty string to null\n                if (!newGlobalName)\n                    newGlobalName = null;\n\n                var oldGlobalName = this.globalName;\n                if (oldGlobalName === newGlobalName)\n                    return;\n\n                this._cc.delayCallbacks();\n\n                if (newGlobalName === null || newGlobalName === undefined) {\n                    // unlink from global object and copy session state into a local object\n                    this.requestLocalObjectCopy(this.internalObject);\n                } else {\n                    // when switcing from a local object to a global one that doesn't exist yet, copy the local object\n                    if (this.target && !this.targetPath && !WeaveAPI.globalHashMap.getObject(newGlobalName))\n                        WeaveAPI.globalHashMap.requestObjectCopy(newGlobalName, this.internalObject);\n\n                    // link to new global name\n                    this.targetPath = [newGlobalName];\n                }\n\n                this._cc.resumeCallbacks();\n            }\n        });\n\n        /**\n         * @inheritDoc\n         */\n        Object.defineProperty(this, 'locked', {\n            get: function () {\n                return this.locked;\n            }\n\n        });\n    }\n\n    LinkableDynamicObject.prototype = new weavecore.LinkableWatcher();\n    LinkableDynamicObject.prototype.constructor = LinkableDynamicObject;\n\n    var p = LinkableDynamicObject.prototype;\n\n\n    p.lock = function () {\n        this._locked = true;\n    };\n\n    /**\n     * @inheritDoc\n     */\n    //public\n\n    p.getSessionState = function () {\n        var obj = this.targetPath || this.target;\n        if (!obj)\n            return [];\n\n        var className = obj.constructor.name;\n        var sessionState = obj || WeaveAPI.SessionManager.getSessionState(obj);\n        return [weavecore.DynamicState.create(null, className, sessionState)];\n    };\n\n    /**\n     * @inheritDoc\n     */\n    //public\n\n    p.setSessionState = function (newState, removeMissingDynamicObjects) {\n        //console.log(debugId(this), removeMissingDynamicObjects ? 'diff' : 'state', Compiler.stringify(newState, null, '\\t'));\n\n        // special case - no change\n        if (newState === null || newState === undefined)\n            return;\n\n        try {\n            // make sure callbacks only run once\n            this._cc.delayCallbacks();\n\n            // stop if there are no items\n            if (!newState.length) {\n                if (removeMissingDynamicObjects)\n                    target = null;\n                return;\n            }\n\n            // if it's not a dynamic state array, treat it as a path\n            if (!weavecore.DynamicState.isDynamicStateArray(newState)) {\n                this.targetPath = newState;\n                return;\n            }\n\n            // if there is more than one item, it's in a deprecated format\n            /*if (newState.length > 1) {\n                handleDeprecatedSessionState(newState, removeMissingDynamicObjects);\n                return;\n            }*/\n\n            var dynamicState = newState[0];\n            var className = dynamicState[weavecore.DynamicState.CLASS_NAME];\n            var objectName = dynamicState[weavecore.DynamicState.OBJECT_NAME];\n            var sessionState = dynamicState[weavecore.DynamicState.SESSION_STATE];\n\n            // backwards compatibility\n            /*if (className == 'weave.core::GlobalObjectReference' || className == 'GlobalObjectReference') {\n                className = ARRAY_CLASS_NAME;\n                sessionState = [objectName];\n            }*/\n\n            if (className === ARRAY_CLASS_NAME || (!className && this.targetPath))\n                this.targetPath = sessionState;\n            else if (className === SessionManager.DIFF_DELETE)\n                this.target = null;\n            else {\n                var prevTarget = this.target;\n                // if className is not specified, make no change unless removeMissingDynamicObjects is true\n                if (className || removeMissingDynamicObjects)\n                    this._setLocalObjectType(className);\n                //TODO:Remove hardcoded NameSpace\n                var classDef = eval(\"weavecore.\" + className);\n                if ((!className && this.target) || (classDef && this.target instanceof classDef))\n                    WeaveAPI.SessionManager.setSessionState(this.target, sessionState, prevTarget !== this.target || removeMissingDynamicObjects);\n            }\n        } finally {\n            // allow callbacks to run once now\n            this._cc.resumeCallbacks();\n        }\n    };\n\n\n\n\n\n    // override protected\n\n    p.internalSetTarget = function (newTarget) {\n        // don't allow recursive linking\n        if (newTarget === this || WeaveAPI.SessionManager.getLinkableDescendants(newTarget, LinkableDynamicObject).indexOf(this) >= 0)\n            newTarget = null;\n\n        weavecore.LinkableWatcher.prototype.internalSetTarget(newTarget);\n    };\n\n\n\n    //private\n\n    p._setLocalObjectType = function (className) {\n        // stop if locked\n        if (this._locked)\n            return;\n\n        this._cc.delayCallbacks();\n\n        this.targetPath = null;\n\n        var classDef = eval('weavecore.' + className);\n        if (classDef instanceof weavecore.ILinkableObject && (this._typeRestriction === null || this._typeRestriction === undefined || classDef instanceof this._typeRestriction)) {\n\n            var obj = target;\n            if (!obj || obj.constructor !== classDef)\n                weavecore.LinkableWatcher.prototype.target = new classDef();\n        } else {\n            weavecore.LinkableWatcher.prototype.target = null;\n        }\n\n        _cc.resumeCallbacks();\n    };\n\n    /**\n     * @inheritDoc\n     */\n\n\n    p.requestLocalObject = function (objectType, lockObject) {\n        this._cc.delayCallbacks();\n\n        if (objectType)\n            this._setLocalObjectType(objectType.constructor.name);\n        else\n            this.target = null;\n\n        if (lockObject)\n            this._locked = true;\n\n        this._cc.resumeCallbacks();\n\n        return target;\n    };\n\n    /**\n     * @inheritDoc\n     */\n    p.requestGlobalObject = function (name, objectType, lockObject) {\n        if (!name)\n            return this.requestLocalObject(objectType, lockObject);\n\n        if (!this._locked) {\n            this._cc.delayCallbacks();\n\n            this.targetPath = [name];\n            WeaveAPI.globalHashMap.requestObject(name, objectType, lockObject);\n            if (lockObject)\n                this._locked = true;\n\n            this._cc.resumeCallbacks();\n        }\n\n        return this.target;\n    };\n\n    /**\n     * @inheritDoc\n     */\n    p.requestLocalObjectCopy = function (objectToCopy) {\n        this._cc.delayCallbacks(); // make sure callbacks only trigger once\n        var classDef = objectToCopy ? objectToCopy.constructor : null;\n        var object = this.requestLocalObject(classDef, false);\n        if (object !== null && object !== undefined && objectToCopy !== null && objectToCopy !== undefined) {\n            var state = WeaveAPI.SessionManager.getSessionState(objectToCopy);\n            WeaveAPI.SessionManager.setSessionState(object, state, true);\n        }\n        this._cc.resumeCallbacks();\n    };\n\n\n    p.removeObject = function () {\n        if (!this._locked)\n            weavecore.LinkableWatcher.prototype.target = null;\n    };\n\n    p.dispose = function () {\n        // explicitly dispose the CallbackCollection before anything else\n        this._cc.dispose();\n        weavecore.LinkableWatcher.prototype.dispose();\n    };\n\n    weavecore.LinkableDynamicObject = LinkableDynamicObject;\n\n\n}());\n/*\n    Weave (Web-based Analysis and Visualization Environment)\n    Copyright (C) 2008-2011 University of Massachusetts Lowell\n    This file is a part of Weave.\n    Weave is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, Version 3,\n    as published by the Free Software Foundation.\n    Weave is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n    You should have received a copy of the GNU General Public License\n    along with Weave.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// namespace\n\nif (!this.weavecore)\n    this.weavecore = {};\n\n/**\n * This allows you to add callbacks that will be called when an event occurs on the stage.\n *\n * WARNING: These callbacks will trigger on every mouse and keyboard event that occurs on the stage.\n *          Developers should not add any callbacks that run computationally expensive code.\n *\n * @author adufilie\n * @author sanjay1909\n */\n(function () {\n\n    // Internal class constructor\n\n    Object.defineProperty(EventCallbackCollection, 'eventTypes', {\n        value: ['tick']\n    });\n\n    function EventCallbackCollection(eventManager, eventType) {\n        weavecore.CallbackCollection.call(this, this.setEvent.bind(this));\n        this._eventManager = eventManager;\n        this._eventType = eventType;\n\n    }\n\n    EventCallbackCollection.prototype = new weavecore.CallbackCollection();\n    EventCallbackCollection.prototype.constructor = EventCallbackCollection;\n\n    var p = EventCallbackCollection.prototype;\n\n    /**\n     * This is the _preCallback\n     */\n    p.setEvent = function setEvent(event) {\n        this._eventManager.event = event;\n    };\n\n    /**\n     * This function remembers the previous event value, runs callbacks using the new event value,\n     * then restores the previous event value. This is necessary because it is possible for a popup\n     * browser window to interrupt Flash with requests in the middle of an event.\n     */\n    p.runEventCallbacks = function (event) {\n        var previousEvent = this._eventManager.event; // remember previous value\n        this._runCallbacksImmediately(event); // make sure event is set before each immediate callback\n        this._preCallback(previousEvent); // restore the previous value\n    };\n\n    /**\n     * Call this when the stage is available to set up event listeners.\n     */\n    p.listenToStage = function () {\n        // do not create event listeners for these meta events\n        //if (eventType == POINT_CLICK_EVENT || eventType == THROTTLED_MOUSE_MOVE_EVENT)\n        //return;\n\n        //if (eventType == KeyboardEvent.KEY_DOWN && Capabilities.playerType == \"Desktop\")\n        //cancelable = false;\n\n        // Add a listener to the capture phase so the callbacks will run before the target gets the event.\n        //stage.addEventListener(eventType, captureListener, true, 0, true); // use capture phase\n\n        // If the target is the stage, the capture listener won't be called, so add\n        // an additional listener that runs callbacks when the stage is the target.\n        createjs.Ticker.addEventListener(this._eventType, this._tickerListener.bind(this)); // do not use capture phase\n\n        // when callbacks are disposed, remove the listeners\n        this.addDisposeCallback(null, function () {\n            //stage.removeEventListener(eventType, captureListener, true);\n            createjs.Ticker.removeEventListener(this._eventType, this._tickerListener.bind(this));\n        });\n    };\n\n    p._tickerListener = function (event) {\n        this._eventManager.eventTime = new Date().getTime();\n        if (this._eventType === \"tick\") {\n            if (this._eventManager.userActivity > 0 && !this._eventManager.mouseButtonDown)\n                this._eventManager.userActivity--;\n            this._eventManager.previousFrameElapsedTime = this._eventManager.eventTime - this._eventManager.currentFrameStartTime;\n            this._eventManager.currentFrameStartTime = this._eventManager.eventTime;\n            //this._eventManager.triggeredThrottledMouseThisFrame = false;\n        }\n        // finally, trigger callbacks for non-mouse-move events\n        if (this._eventType === \"tick\") // altered temporarily\n            this.runEventCallbacks(event);\n\n    };\n\n    weavecore.EventCallbackCollection = EventCallbackCollection;\n\n    //constructor\n    function StageUtils() {\n\n        this.averageFrameTime = 0;\n\n        Object.defineProperties(this, {\n            eventManager: {\n                value: new EventManager()\n            },\n            frameTimes: {\n                value: []\n            },\n            _stackTraceMap: {\n                value: new Map()\n            },\n            _taskElapsedTime: {\n                value: new Map()\n            },\n            _taskStartTime: {\n                value: new Map()\n            },\n\n        });\n        this._currentTaskStopTime = 0;\n\n        /**\n         * This is an Array of \"callLater queues\", each being an Array of function invocations to be done later.\n         * The Arrays get populated by callLater().\n         * There are four nested Arrays corresponding to the four priorities (0, 1, 2, 3) defined by static constants in WeaveAPI.\n         */\n        Object.defineProperties(this, {\n            _priorityCallLaterQueues: {\n                value: [[], [], [], []]\n            },\n            _priorityAllocatedTimes: {\n                value: [Number.MAX_VALUE, 300, 200, 100]\n            }\n        });\n        this._activePriority = WeaveAPI.TASK_PRIORITY_IMMEDIATE + 1; // task priority that is currently being processed\n        this._activePriorityElapsedTime = 0;\n        this._deactivatedMaxComputationTimePerFrame = 1000;\n        this._nextCallLaterPriority = WeaveAPI.TASK_PRIORITY_IMMEDIATE; // private variable to control the priority of the next callLater() internally\n        this.addEventCallback(\"tick\", null, this._handleCallLater.bind(this));\n        this.maxComputationTimePerFrame = 100;\n        this.maxComputationTimePerFrame_noActivity = 250;\n\n    }\n\n    var suP = StageUtils.prototype;\n    suP.getMaxComputationTimePerFrame = function () {\n        return this.maxComputationTimePerFrame;\n    };\n\n    suP.setMaxComputationTimePerFrame = function (value) {\n        // this.eventManager.throttledMouseMoveInterval = value;\n        this.maxComputationTimePerFrame = value;\n    };\n\n    suP.getTaskPriorityTimeAllocation = function (priority) {\n        return this._priorityAllocatedTimes[priority];\n    };\n\n    suP.setTaskPriorityTimeAllocation = function (priority, milliseconds) {\n        this._priorityAllocatedTimes[priority] = Math.max(milliseconds, 5);\n    };\n\n    StageUtils._time;\n    StageUtils._times = [];\n\n    suP.callLater = function (relevantContext, method, parameters) {\n        if (method === null || method === undefined) {\n            console.log('StageUtils.callLater(): received null \"method\" parameter');\n            return;\n        }\n\n        this._priorityCallLaterQueues[this._nextCallLaterPriority].push(arguments);\n        this._nextCallLaterPriority = WeaveAPI.TASK_PRIORITY_IMMEDIATE;\n\n        //if (this.debug_async_stack)\n        //_stackTraceMap[arguments] = new Error(\"This is the stack trace from when callLater() was called.\").getStackTrace();\n    };\n\n    suP._handleCallLater = function () {\n        if (this.maxComputationTimePerFrame === 0)\n            this.maxComputationTimePerFrame = 100;\n\n        var maxComputationTime;\n        if (this.eventManager.useDeactivatedFrameRate)\n            maxComputationTime = this._deactivatedMaxComputationTimePerFrame;\n        else if (!this.eventManager.userActivity)\n            maxComputationTime = this.maxComputationTimePerFrame_noActivity;\n        else\n            maxComputationTime = this.maxComputationTimePerFrame;\n        if (!this.eventManager.event) {\n            console.log(\"StageUtils.handleCallLater(): _event is null. This should never happen.\");\n            return;\n        }\n        if (this.eventManager.event.type === \"tick\") {\n            //resetDebugTime();\n\n            /*if (debug_fps)\n            {\n                frameTimes.push(previousFrameElapsedTime);\n                if (StandardLib.sum(frameTimes) >= 1000)\n                {\n                    averageFrameTime = StandardLib.mean(frameTimes);\n                    var fps:Number = StandardLib.roundSignificant(1000 / averageFrameTime, 2);\n                    trace(fps,'fps; max computation time',maxComputationTime);\n                    frameTimes.length = 0;\n                }\n            }*/\n\n            if (this.eventManager.previousFrameElapsedTime > 3000)\n                console.log('Previous frame took', this.eventManager.previousFrameElapsedTime, 'ms');\n        }\n\n        //if (UIComponentGlobals.callLaterSuspendCount > 0)\n        //return;\n\n        // The variables countdown and lastPriority are used to avoid running newly-added tasks immediately.\n        // This avoids wasting time on async tasks that do nothing and return early, adding themselves back to the queue.\n\n        var args;\n        var args2; // this is set to args[2]\n        var stackTrace;\n        var now;\n        var allStop = this.eventManager.currentFrameStartTime + maxComputationTime;\n\n        this._currentTaskStopTime = allStop; // make sure _iterateTask knows when to stop\n\n        // first run the functions that should be called before anything else.\n        /*if (pauseForGCIfCollectionImminent != null)\n        {\n            var t:int = getTimer();\n            pauseForGCIfCollectionImminent();\n            t = getTimer() - t;\n            if (t > maxComputationTimePerFrame)\n                trace('paused',t,'ms for GC');\n        }*/\n        var queue = this._priorityCallLaterQueues[WeaveAPI.TASK_PRIORITY_IMMEDIATE];\n        var countdown;\n        for (countdown = queue.length; countdown > 0; countdown--) {\n            /*if (debug_callLater)\n                DebugTimer.begin();*/\n\n            now = new Date().getTime();\n            // stop when max computation time is reached for this frame\n            if (now > allStop) {\n                /*if (debug_callLater)\n                    DebugTimer.cancel();*/\n                return;\n            }\n\n            // args: (relevantContext:Object, method:Function, parameters:Array, priority:uint)\n            args = queue.shift();\n            stackTrace = this._stackTraceMap[args];\n\n            // don't call the function if the relevantContext was disposed.\n            if (!WeaveAPI.SessionManager.objectWasDisposed(args[0])) {\n                args2 = args[2];\n                if (args2 !== null && args2 && args2.length > 0)\n                    args[1].apply(null, args2);\n                else\n                    args[1].call();\n            }\n\n            /*if (debug_callLater)\n                DebugTimer.end(stackTrace);*/\n        }\n\n        //\t\t\ttrace('-------');\n\n        var minPriority = WeaveAPI.TASK_PRIORITY_IMMEDIATE + 1;\n        var lastPriority = this._activePriority === minPriority ? this._priorityCallLaterQueues.length - 1 : this._activePriority - 1;\n        var pStart = new Date().getTime();\n        var pAlloc = this._priorityAllocatedTimes[this._activePriority];\n        if (this.eventManager.useDeactivatedFrameRate)\n            pAlloc = pAlloc * this._deactivatedMaxComputationTimePerFrame / this.maxComputationTimePerFrame;\n        else if (!this.eventManager.userActivity)\n            pAlloc = pAlloc * this.maxComputationTimePerFrame_noActivity / this.maxComputationTimePerFrame;\n        var pStop = Math.min(allStop, pStart + pAlloc - this._activePriorityElapsedTime); // continue where we left off\n        queue = this._priorityCallLaterQueues[this._activePriority];\n        countdown = queue.length;\n        while (true) {\n            /*if (debug_callLater)\n\t\t\t\t\tDebugTimer.begin();*/\n\n            now = new Date().getTime();\n            if (countdown === 0 || now > pStop) {\n                // add the time we just spent on this priority\n                this._activePriorityElapsedTime += now - pStart;\n\n                // if max computation time was reached for this frame or we have visited all priorities, stop now\n                if (now > allStop || this._activePriority === lastPriority) {\n                    /*if (debug_callLater)\n\t\t\t\t\t\t\tDebugTimer.cancel();\n\t\t\t\t\t\tif (debug_fps)\n\t\t\t\t\t\t\ttrace('spent',currentFrameElapsedTime,'ms');*/\n                    return;\n                }\n\n                // see if there are any entries left in the queues (except for the immediate queue)\n                var remaining = 0;\n                for (var i = minPriority; i < this._priorityCallLaterQueues.length; i++)\n                    remaining += this._priorityCallLaterQueues[i].length;\n                // stop if no more entries\n                if (remaining === 0) {\n                    /*if (debug_callLater)\n\t\t\t\t\t\t\tDebugTimer.cancel();*/\n                    break;\n                }\n\n                // switch to next priority, reset elapsed time\n                this._activePriority++;\n                this._activePriorityElapsedTime = 0;\n                if (this._activePriority === this._priorityCallLaterQueues.length)\n                    this._activePriority = minPriority;\n                pStart = now;\n                pAlloc = this._priorityAllocatedTimes[_activePriority];\n                if (this.eventManager.useDeactivatedFrameRate)\n                    pAlloc = pAlloc * this._deactivatedMaxComputationTimePerFrame / this.maxComputationTimePerFrame;\n                else if (!this.eventManager.userActivity)\n                    pAlloc = pAlloc * this.maxComputationTimePerFrame_noActivity / this.maxComputationTimePerFrame;\n                pStop = Math.min(allStop, pStart + pAlloc);\n                queue = this._priorityCallLaterQueues[this._activePriority];\n                countdown = queue.length;\n\n                // restart loop to check stopping condition\n                /*if (debug_callLater)\n\t\t\t\t\t\tDebugTimer.cancel();*/\n                continue;\n            }\n\n            countdown--;\n\n            //\t\t\t\ttrace('p',_activePriority,pElapsed,'/',pAlloc);\n            _currentTaskStopTime = pStop; // make sure _iterateTask knows when to stop\n\n            // call the next function in the queue\n            // args: (relevantContext:Object, method:Function, parameters:Array, priority:uint)\n            args = queue.shift();\n            stackTrace = this._stackTraceMap[args]; // check this for debugging where the call came from\n\n            //\t\t\t\tWeaveAPI.SessionManager.unassignBusyTask(args);\n\n            // don't call the function if the relevantContext was disposed.\n            if (!WeaveAPI.SessionManager.objectWasDisposed(args[0])) {\n                // TODO: PROFILING: check how long this function takes to execute.\n                // if it takes a long time (> 1000 ms), something's wrong...\n                args2 = args[2];\n                if (args2 !== null && args2.length > 0)\n                    args[1].apply(null, args2);\n                else\n                    args[1].call();\n            }\n\n            /*if (debug_callLater)\n\t\t\t\t\tDebugTimer.end(stackTrace);*/\n        }\n\n    };\n\n    suP.addEventCallback = function (eventType, relevantContext, callback, runCallbackNow) {\n        // set default parameter value\n        if (runCallbackNow === null || runCallbackNow === undefined) {\n            runCallbackNow = false;\n        }\n        var cc = this.eventManager.callbackCollections[eventType];\n        if (cc !== null && cc !== undefined) {\n            cc.addImmediateCallback(relevantContext, callback, runCallbackNow);\n        } else {\n            console.log(\"(StageUtils) Unsupported event: \", eventType);\n        }\n    };\n\n\n\n    weavecore.StageUtils = new StageUtils();\n\n\n    function EventManager() {\n        Object.defineProperty(this, 'callbackCollections', {\n            value: {}\n        });\n        this.userActivity = 0; // greater than 0 when there was user activity since the last frame.\n        this.event = null;\n        this.eventTime = 0;\n        this.shiftKey = false;\n        this.altKey = false;\n        this.ctrlKey = false;\n        this.mouseButtonDown = false;\n\n        this.currentFrameStartTime = new Date().getTime(); // this is the result of getTimer() on the last ENTER_FRAME event.\n        this.previousFrameElapsedTime = 0; // this is the amount of time it took to process the previous frame.\n        this.pointClicked = false;\n        this.deactivated = true; // true when application is deactivated\n        this.useDeactivatedFrameRate = false;\n\n        this.triggeredThrottledMouseThisFrame = false; // set to false on enterFrame, set to true on throttled mouse move\n        this.nextThrottledMouseMoveTime = 0; // time threshold before triggering throttled mouse move again\n        this.throttledMouseMoveInterval = 100; // time threshold before triggering throttled mouse move again\n\n        // create a new callback collection for each type of event\n        for (var j = 0; j < EventCallbackCollection.eventTypes.length; j++) {\n            var type = EventCallbackCollection.eventTypes[j];\n            this.callbackCollections[type] = new EventCallbackCollection(this, type);\n            // this.callbackCollections[type] = WeaveAPI.SessionManager.registerDisposableChild(WeaveAPI.globalHashMap, new EventCallbackCollection(this, type));\n        }\n\n        //add event listeners\n        for (var eventtype in this.callbackCollections) {\n            this.callbackCollections[eventtype].listenToStage();\n        }\n        this.event;\n    }\n\n\n    weavecore.EventManager = EventManager;\n\n\n\n}());\n\nif (typeof window === 'undefined') {\n    this.weavecore = this.weavecore || {};\n} else {\n    window.weavecore = window.weavecore || {};\n}\n\n/**\n * This class saves the session history of an ILinkableObject.\n *\n * @author adufilie\n * @author sanjay1909\n */\n(function () {\n\n    /**\n     * This is an entry in the session history log.  It contains both undo and redo session state diffs.\n     * The triggerDelay is the time it took for the user to make a change since the last synchronization.\n     * This time difference does not include the time it took to set the session state.  This way, when\n     * the session state is replayed at a reasonable speed regardless of the speed of the computer.\n     * @param id\n     * @param forward The diff for applying redo.\n     * @param backward The diff for applying undo.\n     * @param triggerDelay The length of time between the last synchronization and the diff.\n     */\n    function LogEntry(id, forward, backward, triggerDelay, diffDuration) {\n        this.id = id;\n        this.forward = forward; // the diff for applying redo\n        this.backward = backward; // the diff for applying undo\n        this.triggerDelay = triggerDelay; // the length of time between the last synchronization and the diff\n        this.diffDuration = diffDuration; // the length of time in which the diff took place\n    }\n\n    /**\n     * This will convert an Array of generic objects to an Array of LogEntry objects.\n     * Generic objects are easier to create backwards compatibility for.\n     */\n    LogEntry.convertGenericObjectsToLogEntries = function (array, defaultTriggerDelay) {\n        for (var i = 0; i < array.length; i++) {\n            var o = array[i];\n            if (!(o instanceof LogEntry))\n                array[i] = new LogEntry(o.id, o.forward, o.backward, o.triggerDelay || defaultTriggerDelay, o.diffDuration);\n        }\n        return array;\n    };\n\n\n    function getTimer() {\n        var start = new Date().getTime();\n        return start;\n    }\n\n    function SessionStateLog(subject, syncDelay) {\n        // set default values\n        if (syncDelay === undefined)\n            syncDelay = 0;\n        this._subject = subject; // the object we are monitoring\n        this._syncDelay = syncDelay; // the number of milliseconds to wait before automatically synchronizing\n        this._prevState = WeaveAPI.SessionManager.getSessionState(this._subject); // remember the initial state\n\n        /**\n         * When this is set to true, changes in the session state of the subject will be automatically logged.\n         */\n        SessionStateLog.prototype.enableLogging = WeaveAPI.SessionManager.registerLinkableChild(this, new weavecore.LinkableBoolean(true), this.synchronizeNow.bind(this));\n\n\n        WeaveAPI.SessionManager.registerDisposableChild(this._subject, this); // make sure this is disposed when _subject is disposed\n\n        var cc = WeaveAPI.SessionManager.getCallbackCollection(this._subject);\n        cc.addImmediateCallback(this, this._immediateCallback.bind(this));\n        cc.addGroupedCallback(this, this._groupedCallback.bind(this));\n\n        this._undoHistory = []; // diffs that can be undone\n        this._redoHistory = []; // diffs that can be redone\n        this._nextId = 0; // gets incremented each time a new diff is created\n        this._undoActive = false; // true while an undo operation is active\n        this._redoActive = false; // true while a redo operation is active\n\n        this._syncTime = getTimer(); // this is set to getTimer() when synchronization occurs\n        this._triggerDelay = -1; // this is set to (getTimer() - _syncTime) when immediate callbacks are triggered for the first time since the last synchronization occurred\n        this._saveTime = 0; // this is set to getTimer() + _syncDelay to determine when the next diff should be computed and logged\n        this._savePending = false; // true when a diff should be computed\n\n        Object.defineProperty(SessionStateLog, 'debug', {\n            value: true,\n            writable: true\n        });\n        Object.defineProperty(SessionStateLog, 'enableHistoryRewrite', {\n            value: true,\n            writable: true\n        });\n\n        /**\n         * @TODO create an interface for the objects in this Array\n         */\n        Object.defineProperty(this, 'undoHistory', {\n            get: function () {\n                return this._undoHistory;\n            }\n        });\n\n        /**\n         * @TODO create an interface for the objects in this Array\n         */\n        Object.defineProperty(this, 'redoHistory', {\n            get: function () {\n                return this._redoHistory;\n            }\n        });\n\n\n    }\n\n    SessionStateLog.prototype = new weavecore.LinkableVariable();\n    SessionStateLog.prototype.constructor = SessionStateLog;\n\n    var p = SessionStateLog.prototype;\n\n\n    /**\n     * @inheritDoc\n     */\n    p.dispose = function () {\n        if (this._undoHistory === null || this._undoHistory === undefined)\n            console.log(\"SessionStateLog.dispose() called more than once\");\n\n        this._subject = null;\n        this._undoHistory = null;\n        this._redoHistory = null;\n    };\n\n    /**\n     * This function will save any pending diff in session state.\n     * Use this function only when necessary (for example, when writing a collaboration service that must synchronize).\n     */\n    p.synchronizeNow = function () {\n        this._saveDiff.call(this, true);\n    };\n\n\n\n    /**\n     * This gets called as an immediate callback of the subject.\n     */\n    p._immediateCallback = function () {\n        if (!this.enableLogging.value)\n            return;\n\n        // we have to wait until grouped callbacks are called before we save the diff\n        this._saveTime = Number.MAX_VALUE;\n\n        // make sure only one call to saveDiff() is pending\n        if (!this._savePending) {\n            this._savePending = true;\n            this._saveDiff.call(this);\n        }\n\n\n        if (SessionStateLog.debug && (this._undoActive || this._redoActive)) {\n            var state = WeaveAPI.SessionManager.getSessionState(this._subject);\n            var forwardDiff = WeaveAPI.SessionManager.computeDiff(this._prevState, state);\n            console.log('immediate diff:', forwardDiff);\n        }\n    };\n\n    /**\n     * This gets called as a grouped callback of the subject.\n     */\n    p._groupedCallback = function () {\n        if (!this.enableLogging.value)\n            return;\n\n        // Since grouped callbacks are currently running, it means something changed, so make sure the diff is saved.\n        this._immediateCallback();\n        // It is ok to save a diff some time after the last time grouped callbacks are called.\n        // If callbacks are triggered again before the next frame, the immediateCallback will reset this value.\n        this._saveTime = getTimer() + this._syncDelay;\n\n        if (SessionStateLog.debug && (this._undoActive || this._redoActive)) {\n            var state = WeaveAPI.SessionManager.getSessionState(this._subject);\n            var forwardDiff = WeaveAPI.SessionManager.computeDiff(this._prevState, state);\n            console.log('grouped diff:', forwardDiff);\n        }\n    };\n\n    /**\n     * This will save a diff in the history, if there is any.\n     * @param immediately Set to true if it should be saved immediately, or false if it can wait.\n     */\n    p._saveDiff = function (immediately) {\n        //console.log(\"save difference is called\");\n        if (immediately === undefined) {\n            immediately = false;\n        }\n        if (!this.enableLogging.value) {\n            this._savePending = false;\n            return;\n        }\n\n        var currentTime = getTimer();\n\n        // remember how long it's been since the last synchronization\n        if (this._triggerDelay < 0)\n            this._triggerDelay = currentTime - this._rsyncTime;\n\n        if (!immediately && getTimer() < this._saveTime) {\n            // console.log(\"save difference is Paused\");\n            // we have to wait until the next frame to save the diff because grouped callbacks haven't finished.\n            weavecore.StageUtils.callLater(this, this._saveDiff.bind(this));\n            return;\n        }\n\n        var cc = WeaveAPI.SessionManager.getCallbackCollection(this);\n        cc.delayCallbacks.call(cc);\n\n        // console.log(\"save difference is executed\");\n\n        var state = WeaveAPI.SessionManager.getSessionState(this._subject);\n        var forwardDiff = WeaveAPI.SessionManager.computeDiff(this._prevState, state);\n        if (forwardDiff !== undefined) {\n            var diffDuration = currentTime - (this._rsyncTime + this._triggerDelay);\n            var backwardDiff = WeaveAPI.SessionManager.computeDiff(state, this._prevState);\n            var oldEntry;\n            var newEntry;\n            if (this._undoActive) {\n                // To prevent new undo history from being added as a result of applying an undo, overwrite first redo entry.\n                // Keep existing delay/duration.\n                oldEntry = this._redoHistory[0];\n                newEntry = new LogEntry(this._nextId++, backwardDiff, forwardDiff, oldEntry.triggerDelay, oldEntry.diffDuration);\n                if (this.enableHistoryRewrite) {\n                    this._redoHistory[0] = newEntry;\n                } else if (weavecore.StandardLib.compare(oldEntry.forward, newEntry.forward) !== 0) {\n                    this._redoHistory.unshift(newEntry);\n                }\n            } else {\n                newEntry = new LogEntry(this._nextId++, forwardDiff, backwardDiff, this._triggerDelay, diffDuration);\n                if (this._redoActive) {\n                    // To prevent new undo history from being added as a result of applying a redo, overwrite last undo entry.\n                    // Keep existing delay/duration.\n                    oldEntry = this._undoHistory.pop();\n                    newEntry.triggerDelay = oldEntry.triggerDelay;\n                    newEntry.diffDuration = oldEntry.diffDuration;\n\n                    if (!this.enableHistoryRewrite && weavecore.StandardLib.compare(oldEntry.forward, newEntry.forward) === 0)\n                        newEntry = oldEntry; // keep old entry\n                }\n                // save new undo entry\n                this._undoHistory.push(newEntry);\n            }\n\n            if (SessionStateLog.debug)\n                debugHistory.call(this, newEntry);\n\n            this._rsyncTime = currentTime; // remember when diff was saved\n            cc.triggerCallbacks.call(cc);\n        }\n\n        // always reset sync time after undo/redo even if there was no new diff\n        if (this._undoActive || this._redoActive)\n            this._rsyncTime = currentTime;\n        this._prevState = state;\n        this._undoActive = false;\n        this._redoActive = false;\n        this._savePending = false;\n        this._triggerDelay = -1;\n\n        cc.resumeCallbacks.call(cc);\n    };\n\n\n\n    /**\n     * This will undo a number of steps from the saved history.\n     * @param numberOfSteps The number of steps to undo.\n     */\n    p.undo = function (numberOfSteps) {\n        if (isNaN(numberOfSteps))\n            numberOfSteps = 1;\n        this.applyDiffs.call(this, -numberOfSteps);\n    };\n\n    /**\n     * This will redo a number of steps that have been previously undone.\n     * @param numberOfSteps The number of steps to redo.\n     */\n    p.redo = function (numberOfSteps) {\n        if (isNaN(numberOfSteps))\n            numberOfSteps = 1;\n        this.applyDiffs.call(this, numberOfSteps);\n    };\n\n    /**\n     * This will clear all undo and redo history.\n     * @param directional Zero will clear everything. Set this to -1 to clear all undos or 1 to clear all redos.\n     */\n    p.clearHistory = function (directional) {\n        if (directional === undefined) directional = 0;\n        var cc = WeaveAPI.SessionManager.getCallbackCollection(this);\n        cc.delayCallbacks();\n\n        this.synchronizeNow();\n\n        if (directional <= 0) {\n            if (this._undoHistory.length > 0)\n                cc.triggerCallbacks(\"Log: Clear History Undo > 0\");\n            this._undoHistory.length = 0;\n        }\n        if (directional >= 0) {\n            if (this._redoHistory.length > 0)\n                cc.triggerCallbacks(\"Log: Clear History Redo > 0\");\n            this._redoHistory.length = 0;\n        }\n\n        cc.resumeCallbacks();\n    };\n\n    /**\n     * This will apply a number of undo or redo steps.\n     * @param delta The number of steps to undo (negative) or redo (positive).\n     */\n    p.applyDiffs = function (delta) {\n        var stepsRemaining = Math.min(Math.abs(delta), delta < 0 ? this._undoHistory.length : this._redoHistory.length);\n        if (stepsRemaining > 0) {\n            var logEntry;\n            var diff;\n            var debug = SessionStateLog.debug && stepsRemaining === 1;\n\n            // if something changed and we're not currently undoing/redoing, save the diff now\n            if (this._savePending && !this._undoActive && !this._redoActive)\n                this.synchronizeNow();\n\n            var combine = stepsRemaining > 2;\n            var baseDiff = null;\n            WeaveAPI.SessionManager.getCallbackCollection(this._subject).delayCallbacks.call(this._subject);\n            // when logging is disabled, revert to previous state before applying diffs\n            if (!this.enableLogging.value) {\n                var state = WeaveAPI.SessionManager.getSessionState(this._subject);\n                // baseDiff becomes the change that needs to occur to get back to the previous state\n                baseDiff = WeaveAPI.SessionManager.computeDiff(state, this._prevState);\n                if (baseDiff !== null && baseDiff !== undefined)\n                    combine = true;\n            }\n            while (stepsRemaining-- > 0) {\n                if (delta < 0) {\n                    logEntry = this._undoHistory.pop();\n                    this._redoHistory.unshift(logEntry);\n                    diff = logEntry.backward;\n                } else {\n                    logEntry = this._redoHistory.shift();\n                    this._undoHistory.push(logEntry);\n                    diff = logEntry.forward;\n                }\n                if (debug)\n                    console.log('apply ' + (delta < 0 ? 'undo' : 'redo'), logEntry.id + ':', diff);\n\n                if (stepsRemaining === 0 && this.enableLogging.value) {\n                    // remember the session state right before applying the last step so we can rewrite the history if necessary\n                    this._prevState = WeaveAPI.SessionManager.getSessionState(this._subject);\n                }\n\n                if (combine) {\n                    baseDiff = WeaveAPI.SessionManager.combineDiff(baseDiff, diff);\n                    if (stepsRemaining <= 1) {\n                        WeaveAPI.SessionManager.setSessionState(this._subject, baseDiff, false);\n                        combine = false;\n                    }\n                } else {\n                    WeaveAPI.SessionManager.setSessionState(this._subject, diff, false);\n                }\n\n                if (debug) {\n                    var newState = WeaveAPI.SessionManager.getSessionState(this._subject);\n                    var resultDiff = WeaveAPI.SessionManager.computeDiff(this._prevState, newState);\n                    console.log('resulting diff:', resultDiff);\n                }\n            }\n\n            WeaveAPI.SessionManager.getCallbackCollection(this._subject).resumeCallbacks.call(this._subject);\n\n            this._undoActive = delta < 0 && this._savePending;\n            this._redoActive = delta > 0 && this._savePending;\n            if (!this._savePending) {\n                this._prevState = WeaveAPI.SessionManager.getSessionState(this._subject);\n            }\n            var slcc = WeaveAPI.SessionManager.getCallbackCollection(this);\n            slcc.triggerCallbacks.call(slcc);\n        }\n    };\n\n\n\n    function debugHistory(logEntry) {\n        var h = this._undoHistory.concat();\n        for (var i = 0; i < h.length; i++)\n            h[i] = h[i].id;\n        var f = this._redoHistory.concat();\n        for (i = 0; i < f.length; i++)\n            f[i] = f[i].id;\n        if (logEntry) {\n            console.log(\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\");\n            console.log('NEW HISTORY (backward) ' + logEntry.id + ':', logEntry.backward);\n            console.log(\"===============================================================\");\n            console.log('NEW HISTORY (forward) ' + logEntry.id + ':', logEntry.forward);\n            console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\");\n        }\n        console.log('undo [' + h + ']', 'redo [' + f + ']');\n    }\n\n    /**\n     * This will generate an untyped session state object that contains the session history log.\n     * @return An object containing the session history log.\n     */\n    p.getSessionState = function () {\n        var cc = WeaveAPI.SessionManager.getCallbackCollection(this);\n        cc.delayCallbacks();\n        this.synchronizeNow.call(this);\n\n        // The \"version\" property can be used to detect old session state formats and should be incremented whenever the format is changed.\n        var state = {\n            \"version\": 0,\n            \"currentState\": this._prevState,\n            \"undoHistory\": this._undoHistory.concat(),\n            \"redoHistory\": this._redoHistory.concat(),\n            \"nextId\": this._nextId\n                // not including enableLogging\n        };\n\n        cc.resumeCallbacks();\n        return state;\n    };\n\n    /**\n     * This will load a session state log from an untyped session state object.\n     * @param input The ByteArray containing the output from seralize().\n     */\n    p.setSessionState = function (state) {\n        // make sure callbacks only run once while we set the session state\n        var cc = WeaveAPI.SessionManager.getCallbackCollection(this);\n        cc.delayCallbacks();\n        this.enableLogging.delayCallbacks();\n        try {\n            var version = state.version;\n            switch (version) {\n            case 0:\n                {\n                    // note: some states from version 0 may include enableLogging, but here we ignore it\n                    this._prevState = state.currentState;\n                    this._undoHistory = LogEntry.convertGenericObjectsToLogEntries(state.undoHistory, this._syncDelay);\n                    this._redoHistory = LogEntry.convertGenericObjectsToLogEntries(state.redoHistory, this._syncDelay);\n                    this._nextId = state.nextId;\n\n                    break;\n                }\n            default:\n                console.log(\"Weave history format version \" + version + \" is unsupported.\");\n            }\n\n            // reset these flags so nothing unexpected happens in later frames\n            this._undoActive = false;\n            this._redoActive = false;\n            this._savePending = false;\n            this._saveTime = 0;\n            this._triggerDelay = -1;\n            this._rsyncTime = getTimer();\n\n            WeaveAPI.SessionManager.setSessionState(this._subject, this._prevState);\n        } finally {\n            this.enableLogging.resumeCallbacks();\n            cc.triggerCallbacks(\"Log: Setsessionstate\");\n            cc.resumeCallbacks();\n        }\n    };\n    weavecore.SessionStateLog = SessionStateLog;\n\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/WeaveCoreJS/build/weavecore.js\n ** module id = 2\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./bower_components/WeaveCoreJS/build/weavecore.js?");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n},{}],2:[function(require,module,exports){\narguments[4][1][0].apply(exports,arguments)\n},{\"dup\":1}],3:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar kMaxLength = 0x3fffffff\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Note:\n *\n * - Implementation must support adding new properties to `Uint8Array` instances.\n *   Firefox 4-29 lacked support, fixed in Firefox 30+.\n *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *    incorrect length in some situations.\n *\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will\n * get the Object implementation, which is slower but will work correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {\n    return fromTypedArray(that, object)\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = String(string)\n\n  if (string.length === 0) return 0\n\n  switch (encoding || 'utf8') {\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      return string.length\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return string.length * 2\n    case 'hex':\n      return string.length >>> 1\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(string).length\n    case 'base64':\n      return base64ToBytes(string).length\n    default:\n      return string.length\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function toString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-z\\-]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n  var i = 0\n\n  for (; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (leadSurrogate) {\n        // 2 leads in a row\n        if (codePoint < 0xDC00) {\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          leadSurrogate = codePoint\n          continue\n        } else {\n          // valid surrogate pair\n          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n          leadSurrogate = null\n        }\n      } else {\n        // no lead yet\n\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else {\n          // valid lead\n          leadSurrogate = codePoint\n          continue\n        }\n      }\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n      leadSurrogate = null\n    }\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x200000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n},{\"base64-js\":4,\"ieee754\":5,\"is-array\":6}],4:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],5:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],6:[function(require,module,exports){\n\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n},{}],7:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],8:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],9:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],10:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":11}],11:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],12:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],13:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],14:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":13,\"./encode\":14}],16:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":17}],17:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_readable\":19,\"./_stream_writable\":21,\"_process\":11,\"core-util-is\":22,\"inherits\":8}],18:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":20,\"core-util-is\":22,\"inherits\":8}],19:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":17,\"_process\":11,\"buffer\":3,\"core-util-is\":22,\"events\":7,\"inherits\":8,\"isarray\":9,\"stream\":27,\"string_decoder/\":28,\"util\":2}],20:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":17,\"core-util-is\":22,\"inherits\":8}],21:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":17,\"_process\":11,\"buffer\":3,\"core-util-is\":22,\"inherits\":8,\"stream\":27}],22:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return Buffer.isBuffer(arg);\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":3}],23:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":18}],24:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":17,\"./lib/_stream_passthrough.js\":18,\"./lib/_stream_readable.js\":19,\"./lib/_stream_transform.js\":20,\"./lib/_stream_writable.js\":21,\"stream\":27}],25:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":20}],26:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":21}],27:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":7,\"inherits\":8,\"readable-stream/duplex.js\":16,\"readable-stream/passthrough.js\":23,\"readable-stream/readable.js\":24,\"readable-stream/transform.js\":25,\"readable-stream/writable.js\":26}],28:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":3}],29:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar punycode = require('punycode');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a puny coded representation of \"domain\".\n      // It only converts the part of the domain name that\n      // has non ASCII characters. I.e. it dosent matter if\n      // you call it with a domain that already is in ASCII.\n      var domainArray = this.hostname.split('.');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            'xn--' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join('.');\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    Object.keys(relative).forEach(function(k) {\n      if (k !== 'protocol')\n        result[k] = relative[k];\n    });\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!isNull(result.pathname) || !isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!isNull(result.pathname) || !isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return  arg == null;\n}\n\n},{\"punycode\":12,\"querystring\":15}],30:[function(require,module,exports){\n/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n * \n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\n/*global window, navigator, document, require, process, module */\n(function (app) {\n  'use strict';\n  var namespace = 'cuid',\n    c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize),\n\n    pad = function pad(num, size) {\n      var s = \"000000000\" + num;\n      return s.substr(s.length-size);\n    },\n\n    randomBlock = function randomBlock() {\n      return pad((Math.random() *\n            discreteValues << 0)\n            .toString(base), blockSize);\n    },\n\n    safeCounter = function () {\n      c = (c < discreteValues) ? c : 0;\n      c++; // this is not subliminal\n      return c - 1;\n    },\n\n    api = function cuid() {\n      // Starting with a lowercase letter makes\n      // it HTML element ID friendly.\n      var letter = 'c', // hard-coded allows for sequential access\n\n        // timestamp\n        // warning: this exposes the exact date and time\n        // that the uid was created.\n        timestamp = (new Date().getTime()).toString(base),\n\n        // Prevent same-machine collisions.\n        counter,\n\n        // A few chars to generate distinct ids for different\n        // clients (so different computers are far less\n        // likely to generate the same id)\n        fingerprint = api.fingerprint(),\n\n        // Grab some more chars from Math.random()\n        random = randomBlock() + randomBlock();\n\n        counter = pad(safeCounter().toString(base), blockSize);\n\n      return  (letter + timestamp + counter + fingerprint + random);\n    };\n\n  api.slug = function slug() {\n    var date = new Date().getTime().toString(36),\n      counter,\n      print = api.fingerprint().slice(0,1) +\n        api.fingerprint().slice(-1),\n      random = randomBlock().slice(-2);\n\n      counter = safeCounter().toString(36).slice(-4);\n\n    return date.slice(-2) + \n      counter + print + random;\n  };\n\n  api.globalCount = function globalCount() {\n    // We want to cache the results of this\n    var cache = (function calc() {\n        var i,\n          count = 0;\n\n        for (i in window) {\n          count++;\n        }\n\n        return count;\n      }());\n\n    api.globalCount = function () { return cache; };\n    return cache;\n  };\n\n  api.fingerprint = function browserPrint() {\n    return pad((navigator.mimeTypes.length +\n      navigator.userAgent.length).toString(36) +\n      api.globalCount().toString(36), 4);\n  };\n\n  // don't change anything from here down.\n  if (app.register) {\n    app.register(namespace, api);\n  } else if (typeof module !== 'undefined') {\n    module.exports = api;\n  } else {\n    app[namespace] = api;\n  }\n\n}(this.applitude || this));\n\n},{}],31:[function(require,module,exports){\n/**\n * The base implementation of `_.isFunction` without support for environments\n * with incorrect `typeof` results.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n */\nfunction baseIsFunction(value) {\n  // Avoid a Chakra JIT bug in compatibility modes of IE 11.\n  // See https://github.com/jashkenas/underscore/issues/1621 for more details.\n  return typeof value == 'function' || false;\n}\n\nmodule.exports = baseIsFunction;\n\n},{}],32:[function(require,module,exports){\n/**\n * Converts `value` to a string if it's not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  if (typeof value == 'string') {\n    return value;\n  }\n  return value == null ? '' : (value + '');\n}\n\nmodule.exports = baseToString;\n\n},{}],33:[function(require,module,exports){\nvar isNative = require('../lang/isNative');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n},{\"../lang/isNative\":36}],34:[function(require,module,exports){\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n},{}],35:[function(require,module,exports){\n(function (global){\nvar baseIsFunction = require('../internal/baseIsFunction'),\n    getNative = require('../internal/getNative');\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Native method references. */\nvar Uint8Array = getNative(global, 'Uint8Array');\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nvar isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return objToString.call(value) == funcTag;\n};\n\nmodule.exports = isFunction;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../internal/baseIsFunction\":31,\"../internal/getNative\":33}],36:[function(require,module,exports){\nvar escapeRegExp = require('../string/escapeRegExp'),\n    isObjectLike = require('../internal/isObjectLike');\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  escapeRegExp(fnToString.call(hasOwnProperty))\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n\n},{\"../internal/isObjectLike\":34,\"../string/escapeRegExp\":37}],37:[function(require,module,exports){\nvar baseToString = require('../internal/baseToString');\n\n/**\n * Used to match `RegExp` [special characters](http://www.regular-expressions.info/characters.html#special).\n * In addition to special characters the forward slash is escaped to allow for\n * easier `eval` use and `Function` compilation.\n */\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n/**\n * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n *\n * @static\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escapeRegExp('[lodash](https://lodash.com/)');\n * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n */\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, '\\\\$&')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n\n},{\"../internal/baseToString\":32}],38:[function(require,module,exports){\nmodule.exports = require('./lib/draggable');\n\n},{\"./lib/draggable\":39}],39:[function(require,module,exports){\n'use strict';\n\nvar React = require('react');\nvar emptyFunction = function(){};\nvar assign = require('object-assign');\nvar classNames = require('classnames');\n\n//\n// Helpers. See Element definition below this section.\n//\n\nfunction createUIEvent(draggable) {\n  // State changes are often (but not always!) async. We want the latest value.\n  var state = draggable._pendingState || draggable.state;\n  return {\n    node: draggable.getDOMNode(),\n    position: {\n      top: state.clientY,\n      left: state.clientX\n    }\n  };\n}\n\nfunction canDragY(draggable) {\n  return draggable.props.axis === 'both' ||\n      draggable.props.axis === 'y';\n}\n\nfunction canDragX(draggable) {\n  return draggable.props.axis === 'both' ||\n      draggable.props.axis === 'x';\n}\n\nfunction isFunction(func) {\n  return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';\n}\n\n// @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc\nfunction findInArray(array, callback) {\n  for (var i = 0, length = array.length; i < length; i++) {\n    if (callback.apply(callback, [array[i], i, array])) return array[i];\n  }\n}\n\nfunction matchesSelector(el, selector) {\n  var method = findInArray([\n    'matches',\n    'webkitMatchesSelector',\n    'mozMatchesSelector',\n    'msMatchesSelector',\n    'oMatchesSelector'\n  ], function(method){\n    return isFunction(el[method]);\n  });\n\n  return el[method].call(el, selector);\n}\n\n/**\n * simple abstraction for dragging events names\n * */\nvar eventsFor = {\n  touch: {\n    start: 'touchstart',\n    move: 'touchmove',\n    end: 'touchend'\n  },\n  mouse: {\n    start: 'mousedown',\n    move: 'mousemove',\n    end: 'mouseup'\n  }\n};\n\n// Default to mouse events\nvar dragEventFor = eventsFor['mouse'];\n\n/**\n * get {clientX, clientY} positions of control\n * */\nfunction getControlPosition(e) {\n  var position = (e.touches && e.touches[0]) || e;\n  return {\n    clientX: position.clientX,\n    clientY: position.clientY\n  };\n}\n\nfunction addEvent(el, event, handler) {\n  if (!el) { return; }\n  if (el.attachEvent) {\n    el.attachEvent('on' + event, handler);\n  } else if (el.addEventListener) {\n    el.addEventListener(event, handler, true);\n  } else {\n    el['on' + event] = handler;\n  }\n}\n\nfunction removeEvent(el, event, handler) {\n  if (!el) { return; }\n  if (el.detachEvent) {\n    el.detachEvent('on' + event, handler);\n  } else if (el.removeEventListener) {\n    el.removeEventListener(event, handler, true);\n  } else {\n    el['on' + event] = null;\n  }\n}\n\nfunction outerHeight(node) {\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetTop which is including margin. See getBoundPosition\n  var height = node.clientHeight;\n  var computedStyle = window.getComputedStyle(node);\n  height += int(computedStyle.borderTopWidth);\n  height += int(computedStyle.borderBottomWidth);\n  return height;\n}\n\nfunction outerWidth(node) {\n  // This is deliberately excluding margin for our calculations, since we are using\n  // offsetLeft which is including margin. See getBoundPosition\n  var width = node.clientWidth;\n  var computedStyle = window.getComputedStyle(node);\n  width += int(computedStyle.borderLeftWidth);\n  width += int(computedStyle.borderRightWidth);\n  return width;\n}\nfunction innerHeight(node) {\n  var height = node.clientHeight;\n  var computedStyle = window.getComputedStyle(node);\n  height -= int(computedStyle.paddingTop);\n  height -= int(computedStyle.paddingBottom);\n  return height;\n}\n\nfunction innerWidth(node) {\n  var width = node.clientWidth;\n  var computedStyle = window.getComputedStyle(node);\n  width -= int(computedStyle.paddingLeft);\n  width -= int(computedStyle.paddingRight);\n  return width;\n}\n\nfunction isNum(num) {\n  return typeof num === 'number' && !isNaN(num);\n}\n\nfunction int(a) {\n  return parseInt(a, 10);\n}\n\nfunction getBoundPosition(draggable, clientX, clientY) {\n  var bounds = JSON.parse(JSON.stringify(draggable.props.bounds));\n  var node = draggable.getDOMNode();\n  var parent = node.parentNode;\n\n  if (bounds === 'parent') {\n    var nodeStyle = window.getComputedStyle(node);\n    var parentStyle = window.getComputedStyle(parent);\n    // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.\n    bounds = {\n      left: -node.offsetLeft + int(parentStyle.paddingLeft) +\n            int(nodeStyle.borderLeftWidth) + int(nodeStyle.marginLeft),\n      top: -node.offsetTop + int(parentStyle.paddingTop) +\n            int(nodeStyle.borderTopWidth) + int(nodeStyle.marginTop),\n      right: innerWidth(parent) - outerWidth(node) - node.offsetLeft,\n      bottom: innerHeight(parent) - outerHeight(node) - node.offsetTop\n    };\n  }\n\n  // Keep x and y below right and bottom limits...\n  if (isNum(bounds.right)) clientX = Math.min(clientX, bounds.right);\n  if (isNum(bounds.bottom)) clientY = Math.min(clientY, bounds.bottom);\n\n  // But above left and top limits.\n  if (isNum(bounds.left)) clientX = Math.max(clientX, bounds.left);\n  if (isNum(bounds.top)) clientY = Math.max(clientY, bounds.top);\n\n  return [clientX, clientY];\n}\n\nfunction snapToGrid(grid, pendingX, pendingY) {\n  var x = Math.round(pendingX / grid[0]) * grid[0];\n  var y = Math.round(pendingY / grid[1]) * grid[1];\n  return [x, y];\n}\n\n// Useful for preventing blue highlights all over everything when dragging.\nvar userSelectStyle = ';user-select: none;-webkit-user-select:none;-moz-user-select:none;' +\n  '-o-user-select:none;-ms-user-select:none;';\n\nfunction addUserSelectStyles(draggable) {\n  if (!draggable.props.enableUserSelectHack) return;\n  var style = document.body.getAttribute('style') || '';\n  document.body.setAttribute('style', style + userSelectStyle);\n}\n\nfunction removeUserSelectStyles(draggable) {\n  if (!draggable.props.enableUserSelectHack) return;\n  var style = document.body.getAttribute('style') || '';\n  document.body.setAttribute('style', style.replace(userSelectStyle, ''));\n}\n\nfunction createCSSTransform(style) {\n  // Replace unitless items with px\n  var x = style.x + 'px';\n  var y = style.y + 'px';\n  return {\n    transform: 'translate(' + x + ',' + y + ')',\n    WebkitTransform: 'translate(' + x + ',' + y + ')',\n    OTransform: 'translate(' + x + ',' + y + ')',\n    msTransform: 'translate(' + x + ',' + y + ')',\n    MozTransform: 'translate(' + x + ',' + y + ')'\n  };\n}\n\n\n//\n// End Helpers.\n//\n\n//\n// Define <Draggable>\n//\n\nmodule.exports = React.createClass({\n  displayName: 'Draggable',\n\n  propTypes: {\n    /**\n     * `axis` determines which axis the draggable can move.\n     *\n     * 'both' allows movement horizontally and vertically.\n     * 'x' limits movement to horizontal axis.\n     * 'y' limits movement to vertical axis.\n     *\n     * Defaults to 'both'.\n     */\n    axis: React.PropTypes.oneOf(['both', 'x', 'y']),\n\n    /**\n     * `bounds` determines the range of movement available to the element.\n     * Available values are:\n     *\n     * 'parent' restricts movement within the Draggable's parent node.\n     *\n     * Alternatively, pass an object with the following properties, all of which are optional:\n     *\n     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}\n     *\n     * All values are in px.\n     *\n     * Example:\n     *\n     * ```jsx\n     *   var App = React.createClass({\n     *       render: function () {\n     *         return (\n     *            <Draggable bounds={{right: 300, bottom: 300}}>\n     *              <div>Content</div>\n     *           </Draggable>\n     *         );\n     *       }\n     *   });\n     * ```\n     */\n    bounds: React.PropTypes.oneOfType([\n      React.PropTypes.shape({\n        left: React.PropTypes.Number,\n        right: React.PropTypes.Number,\n        top: React.PropTypes.Number,\n        bottom: React.PropTypes.Number\n      }),\n      React.PropTypes.oneOf(['parent', false])\n    ]),\n\n    /**\n     * By default, we add 'user-select:none' attributes to the document body\n     * to prevent ugly text selection during drag. If this is causing problems\n     * for your app, set this to `false`.\n     */\n    enableUserSelectHack: React.PropTypes.bool,\n\n    /**\n     * `handle` specifies a selector to be used as the handle that initiates drag.\n     *\n     * Example:\n     *\n     * ```jsx\n     *   var App = React.createClass({\n     *       render: function () {\n     *         return (\n     *            <Draggable handle=\".handle\">\n     *              <div>\n     *                  <div className=\"handle\">Click me to drag</div>\n     *                  <div>This is some other content</div>\n     *              </div>\n     *           </Draggable>\n     *         );\n     *       }\n     *   });\n     * ```\n     */\n    handle: React.PropTypes.string,\n\n    /**\n     * `cancel` specifies a selector to be used to prevent drag initialization.\n     *\n     * Example:\n     *\n     * ```jsx\n     *   var App = React.createClass({\n     *       render: function () {\n     *           return(\n     *               <Draggable cancel=\".cancel\">\n     *                   <div>\n     *                     <div className=\"cancel\">You can't drag from here</div>\n     *            <div>Dragging here works fine</div>\n     *                   </div>\n     *               </Draggable>\n     *           );\n     *       }\n     *   });\n     * ```\n     */\n    cancel: React.PropTypes.string,\n\n    /**\n     * `grid` specifies the x and y that dragging should snap to.\n     *\n     * Example:\n     *\n     * ```jsx\n     *   var App = React.createClass({\n     *       render: function () {\n     *           return (\n     *               <Draggable grid={[25, 25]}>\n     *                   <div>I snap to a 25 x 25 grid</div>\n     *               </Draggable>\n     *           );\n     *       }\n     *   });\n     * ```\n     */\n    grid: React.PropTypes.arrayOf(React.PropTypes.number),\n\n    /**\n     * `start` specifies the x and y that the dragged item should start at\n     *\n     * Example:\n     *\n     * ```jsx\n     *      var App = React.createClass({\n     *          render: function () {\n     *              return (\n     *                  <Draggable start={{x: 25, y: 25}}>\n     *                      <div>I start with transformX: 25px and transformY: 25px;</div>\n     *                  </Draggable>\n     *              );\n     *          }\n     *      });\n     * ```\n     */\n    start: React.PropTypes.shape({\n      x: React.PropTypes.number,\n      y: React.PropTypes.number\n    }),\n\n    /**\n     * `moveOnStartChange`, if true (default false) will move the element if the `start`\n     * property changes.\n     */\n    moveOnStartChange: React.PropTypes.bool,\n\n\n    /**\n     * `zIndex` specifies the zIndex to use while dragging.\n     *\n     * Example:\n     *\n     * ```jsx\n     *   var App = React.createClass({\n     *       render: function () {\n     *           return (\n     *               <Draggable zIndex={100}>\n     *                   <div>I have a zIndex</div>\n     *               </Draggable>\n     *           );\n     *       }\n     *   });\n     * ```\n     */\n    zIndex: React.PropTypes.number,\n\n    /**\n     * Called when dragging starts.\n     * If this function returns the boolean false, dragging will be canceled.\n     *\n     * Example:\n     *\n     * ```js\n     *  function (event, ui) {}\n     * ```\n     *\n     * `event` is the Event that was triggered.\n     * `ui` is an object:\n     *\n     * ```js\n     *  {\n     *    position: {top: 0, left: 0}\n     *  }\n     * ```\n     */\n    onStart: React.PropTypes.func,\n\n    /**\n     * Called while dragging.\n     * If this function returns the boolean false, dragging will be canceled.\n     *\n     * Example:\n     *\n     * ```js\n     *  function (event, ui) {}\n     * ```\n     *\n     * `event` is the Event that was triggered.\n     * `ui` is an object:\n     *\n     * ```js\n     *  {\n     *    position: {top: 0, left: 0}\n     *  }\n     * ```\n     */\n    onDrag: React.PropTypes.func,\n\n    /**\n     * Called when dragging stops.\n     *\n     * Example:\n     *\n     * ```js\n     *  function (event, ui) {}\n     * ```\n     *\n     * `event` is the Event that was triggered.\n     * `ui` is an object:\n     *\n     * ```js\n     *  {\n     *    position: {top: 0, left: 0}\n     *  }\n     * ```\n     */\n    onStop: React.PropTypes.func,\n\n    /**\n     * A workaround option which can be passed if onMouseDown needs to be accessed,\n     * since it'll always be blocked (due to that there's internal use of onMouseDown)\n     */\n    onMouseDown: React.PropTypes.func,\n  },\n\n  componentWillReceiveProps: function(newProps) {\n    // React to changes in the 'start' param.\n    if (newProps.moveOnStartChange && newProps.start) {\n      this.setState(this.getInitialState(newProps));\n    }\n  },\n\n  componentWillUnmount: function() {\n    // Remove any leftover event handlers\n    removeEvent(document, dragEventFor['move'], this.handleDrag);\n    removeEvent(document, dragEventFor['end'], this.handleDragEnd);\n    removeUserSelectStyles(this);\n  },\n\n  getDefaultProps: function () {\n    return {\n      axis: 'both',\n      bounds: false,\n      handle: null,\n      cancel: null,\n      grid: null,\n      moveOnStartChange: false,\n      start: {x: 0, y: 0},\n      zIndex: NaN,\n      enableUserSelectHack: true,\n      onStart: emptyFunction,\n      onDrag: emptyFunction,\n      onStop: emptyFunction,\n      onMouseDown: emptyFunction\n    };\n  },\n\n  getInitialState: function (props) {\n    // Handle call from CWRP\n    props = props || this.props;\n    return {\n      // Whether or not we are currently dragging.\n      dragging: false,\n\n      // Offset between start top/left and mouse top/left while dragging.\n      offsetX: 0, offsetY: 0,\n\n      // Current transform x and y.\n      clientX: props.start.x, clientY: props.start.y\n    };\n  },\n\n  handleDragStart: function (e) {\n    // Make it possible to attach event handlers on top of this one\n    this.props.onMouseDown(e);\n\n    // Short circuit if handle or cancel prop was provided and selector doesn't match\n    if ((this.props.handle && !matchesSelector(e.target, this.props.handle)) ||\n      (this.props.cancel && matchesSelector(e.target, this.props.cancel))) {\n      return;\n    }\n\n    // Call event handler. If it returns explicit false, cancel.\n    var shouldStart = this.props.onStart(e, createUIEvent(this));\n    if (shouldStart === false) return;\n\n    var dragPoint = getControlPosition(e);\n\n    // Add a style to the body to disable user-select. This prevents text from\n    // being selected all over the page.\n    addUserSelectStyles(this);\n\n    // Initiate dragging. Set the current x and y as offsets\n    // so we know how much we've moved during the drag. This allows us\n    // to drag elements around even if they have been moved, without issue.\n    this.setState({\n      dragging: true,\n      offsetX: dragPoint.clientX - this.state.clientX,\n      offsetY: dragPoint.clientY - this.state.clientY\n    });\n\n\n    // Add event handlers\n    addEvent(document, dragEventFor['move'], this.handleDrag);\n    addEvent(document, dragEventFor['end'], this.handleDragEnd);\n  },\n\n  handleDragEnd: function (e) {\n    // Short circuit if not currently dragging\n    if (!this.state.dragging) {\n      return;\n    }\n\n    removeUserSelectStyles(this);\n\n    // Turn off dragging\n    this.setState({\n      dragging: false\n    });\n\n    // Call event handler\n    this.props.onStop(e, createUIEvent(this));\n\n    // Remove event handlers\n    removeEvent(document, dragEventFor['move'], this.handleDrag);\n    removeEvent(document, dragEventFor['end'], this.handleDragEnd);\n  },\n\n  handleDrag: function (e) {\n    var dragPoint = getControlPosition(e);\n\n    // Calculate X and Y\n    var clientX = dragPoint.clientX - this.state.offsetX;\n    var clientY = dragPoint.clientY - this.state.offsetY;\n\n    // Snap to grid if prop has been provided\n    if (Array.isArray(this.props.grid)) {\n      var coords = snapToGrid(this.props.grid, clientX, clientY);\n      clientX = coords[0], clientY = coords[1];\n    }\n\n    if (this.props.bounds) {\n      var pos = getBoundPosition(this, clientX, clientY);\n      clientX = pos[0], clientY = pos[1];\n    }\n\n    // Call event handler. If it returns explicit false, cancel.\n    var shouldUpdate = this.props.onDrag(e, createUIEvent(this));\n    if (shouldUpdate === false) return this.handleDragEnd();\n\n    // Update transform\n    this.setState({\n      clientX: clientX,\n      clientY: clientY\n    });\n  },\n\n  onMouseDown: function(ev) {\n    // Prevent 'ghost click' which happens 300ms after touchstart if the event isn't cancelled.\n    // We don't cancel the event on touchstart because of #37; we might want to make a scrollable item draggable.\n    // More on ghost clicks: http://ariatemplates.com/blog/2014/05/ghost-clicks-in-mobile-browsers/\n    if (dragEventFor == eventsFor['touch']) {\n      return ev.preventDefault();\n    }\n\n    return this.handleDragStart.apply(this, arguments);\n  },\n\n  onTouchStart: function(ev) {\n    // We're on a touch device now, so change the event handlers\n    dragEventFor = eventsFor['touch'];\n\n    return this.handleDragStart.apply(this, arguments);\n  },\n\n  // Intended for use by a parent component. Resets internal state on this component. Useful for\n  // <Resizable> and other components in case this element is manually resized and start/moveOnStartChange\n  // don't work for you.\n  resetState: function() {\n    this.setState({\n      offsetX: 0, offsetY: 0, clientX: 0, clientY: 0\n    });\n  },\n\n  render: function () {\n    // Create style object. We extend from existing styles so we don't\n    // remove anything already set (like background, color, etc).\n    var childStyle = this.props.children.props.style || {};\n\n    // Add a CSS transform to move the element around. This allows us to move the element around\n    // without worrying about whether or not it is relatively or absolutely positioned.\n    // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>\n    // has a clean slate.\n    var transform = createCSSTransform({\n      // Set left if horizontal drag is enabled\n      x: canDragX(this) ?\n        this.state.clientX :\n        0,\n\n      // Set top if vertical drag is enabled\n      y: canDragY(this) ?\n        this.state.clientY :\n        0\n    });\n\n    // Workaround IE pointer events; see #51\n    // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278\n    var touchHacks = {\n      touchAction: 'none'\n    };\n\n    var style = assign({}, childStyle, transform, touchHacks);\n\n    // Set zIndex if currently dragging and prop has been provided\n    if (this.state.dragging && !isNaN(this.props.zIndex)) {\n      style.zIndex = this.props.zIndex;\n    }\n\n    var className = classNames((this.props.children.props.className || ''), 'react-draggable', {\n      'react-draggable-dragging': this.state.dragging,\n      'react-draggable-dragged': this.state.dragged\n    });\n\n    // Reuse the child provided\n    // This makes it flexible to use whatever element is wanted (div, ul, etc)\n    return React.cloneElement(React.Children.only(this.props.children), {\n      style: style,\n      className: className,\n\n      onMouseDown: this.onMouseDown,\n      onTouchStart: this.onTouchStart,\n      onMouseUp: this.handleDragEnd,\n      onTouchEnd: this.handleDragEnd\n    });\n  }\n});\n\n},{\"classnames\":40,\"object-assign\":41,\"react\":undefined}],40:[function(require,module,exports){\n/*!\n  Copyright (c) 2015 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n\nfunction classNames() {\n\tvar classes = '';\n\tvar arg;\n\n\tfor (var i = 0; i < arguments.length; i++) {\n\t\targ = arguments[i];\n\t\tif (!arg) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ('string' === typeof arg || 'number' === typeof arg) {\n\t\t\tclasses += ' ' + arg;\n\t\t} else if (Object.prototype.toString.call(arg) === '[object Array]') {\n\t\t\tclasses += ' ' + classNames.apply(null, arg);\n\t\t} else if ('object' === typeof arg) {\n\t\t\tfor (var key in arg) {\n\t\t\t\tif (!arg.hasOwnProperty(key) || !arg[key]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tclasses += ' ' + key;\n\t\t\t}\n\t\t}\n\t}\n\treturn classes.substr(1);\n}\n\n// safely export classNames for node / browserify\nif (typeof module !== 'undefined' && module.exports) {\n\tmodule.exports = classNames;\n}\n\n// safely export classNames for RequireJS\nif (typeof define !== 'undefined' && define.amd) {\n\tdefine('classnames', [], function() {\n\t\treturn classNames;\n\t});\n}\n\n},{}],41:[function(require,module,exports){\n'use strict';\n\nfunction ToObject(val) {\n\tif (val == null) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nmodule.exports = Object.assign || function (target, source) {\n\tvar from;\n\tvar keys;\n\tvar to = ToObject(target);\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = arguments[s];\n\t\tkeys = Object.keys(Object(from));\n\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tto[keys[i]] = from[keys[i]];\n\t\t}\n\t}\n\n\treturn to;\n};\n\n},{}],42:[function(require,module,exports){\n'use strict';\n\nvar Lang = require(\"thicket\").c(\"lang\");\n\nvar ExplicitPropDeclarationError            = Lang.makeErrorClass('ExplicitPropDeclarationError'),\n    ExplicitPropDeclarationDependencyError  = Lang.makeErrorClass('ExplicitPropDeclarationDependencyError');\n\n\n/*\n * This Mixin will validate the props on a ReactJS component both during\n * `componentWillMount` (the first life-cycle method we have available in a\n * component's lifecycle), as well as during `componentWillRecieveProps.` If\n * there are any props set in the component at either of these times that are\n * not explicitly defined in the component's `propTypes` object, it will throw\n * a validation error.\n *\n * The reason for this mixin is to enforce explicit interface definitions ONLY\n * for all of our new components. This ensures one can more-easily reason-about\n * a component, and the properties that it can interact with.\n */\n\n\n/*\n * Ensures the component we are mixed in to actually has a `propTypes`\n * definition. Will throw if `componentPropTypes` is falsy for this component.\n *\n * @param componentName {String} - The string name of the component. Used for\n *                                 the error message.\n * @param componentPropTypes {Object} - The propTypes object for this component.\n *                                      Used to ensure there are properties\n *                                      defined for this component.\n */\nfunction ensureComponentHasPropTypesDeclared (componentName, componentPropTypes) {\n  var errorMessage = ('Component \"' + componentName + '\" does not have ' +\n                      '`propTypes` defined. All components must have ' +\n                      'defined `propTypes`.')\n\n  if (!componentPropTypes) {\n    throw new ExplicitPropDeclarationError(errorMessage);\n  }\n}\n\n/*\n * Does a shallow traversal of the supplied `propsToCheck` and ensures each\n * property name also exists in the supplied `componentPropTypes`. Throws if\n * there are properties in `propsToCheck` which do not exist in `propTypes`.\n *\n * @param componentName {String} - Used for the error message thrown.\n * @param componentPropTypes {Object} - The `propTypes` declaration for this\n *                                      component.\n * @param propsToCheck {Object} - The props object to check against\n *                                `componentPropTypes`, if any keys exist in\n *                                this object that are not in\n *                                `componentPropTypes`, this will throw.\n */\nfunction ensurePropsMatchComponentPropTypes (componentName, componentPropTypes, propsToCheck) {\n  var invalidProperties = [],\n      invalidPropertiesString,\n      errorMessage;\n\n  Object.keys(propsToCheck).forEach(function (propName) {\n    if (!componentPropTypes[propName]) {\n      invalidProperties.push(propName);\n    }\n  });\n\n  if (invalidProperties.length) {\n    invalidPropertiesString = invalidProperties.join(', ');\n    errorMessage = ('The properties \"' + invalidPropertiesString + '\" were ' +\n                    'set on the ' + componentName + ', which were not ' +\n                    'declared in ' + componentName + '.propTypes. Only ' +\n                    'properties defined in ' + componentName + '.propTypes ' +\n                    'are allowed to be set on ' + componentName + '.');\n\n    throw new ExplicitPropDeclarationError(errorMessage);\n  }\n}\n\n/*\n * Ensures the React instance we are working with has the required dependency\n * properties that this mixin requires to do its checks. If not, it will throw\n * with a leading error message to track down the source of the problem. This is\n * likely only to be hit upon a version upgrade/downgrade to the React package\n * itself. At the time of writing this, React is at version 0.13.0.\n *\n * @param reactComponentInstance {Object} - A React component instance.\n */\nfunction ensureInternalPropertyValidityInReact (reactComponentInstance) {\n  var errorMessage;\n\n  if (!reactComponentInstance._reactInternalInstance ||\n      !reactComponentInstance._reactInternalInstance._currentElement) {\n    errorMessage = ('This React mixin depends on an instance of a React ' +\n                    'component to have a `_reactInternalInstance` property ' +\n                    'as well as a `_reactInternalInstance._currentElement` ' +\n                    'property. This instance does not. Was React updated ' +\n                    'recently?');\n\n    throw new ExplicitPropDeclarationDependencyError(errorMessage)\n  }\n}\n\n\nvar ExplicitPropDeclarationMixin = {\n\n  // Validate the props after initial instantiation. Since we have no sort of\n  // `beforeInstantiation` lifecycle method, this is the first time we can hook\n  // into the component lifecycle, so we must validate the props after they are\n  // already set on this component (as this.props).\n  componentWillMount: function () {\n    ensureInternalPropertyValidityInReact(this);\n\n    var componentType = this._reactInternalInstance._currentElement.type;\n\n    ensureComponentHasPropTypesDeclared(componentType.displayName, componentType.propTypes);\n    ensurePropsMatchComponentPropTypes(componentType.displayName, componentType.propTypes, this.props);\n  },\n\n  // After initial instantiation, we can now hook into the component lifecycle\n  // right before the props are set on this component (as this.props). In this\n  // lifecycle method, we have access to the old props (this.props) and the ones\n  // about to be set (first argument of `componentWillReceiveProps`). We will\n  // now validate the newProps about to be set here...\n  componentWillReceiveProps: function (newProps) {\n    ensureInternalPropertyValidityInReact(this);\n\n    var componentType = this._reactInternalInstance._currentElement.type;\n\n    ensurePropsMatchComponentPropTypes(componentType.displayName, componentType.propTypes, newProps);\n  }\n\n};\n\nmodule.exports = ExplicitPropDeclarationMixin;\n\n},{\"thicket\":76}],43:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Logger,\n  Options,\n  StateGuard,\n  Runtime,\n  ProcessKeepAlive\n) {\n  var Log = Logger.create(\"App\");\n\n  var App = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(App.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._guard = new StateGuard([\"starting\", \"started\", \"stopping\", \"stopped\"]);\n      this._rawConfig = opts.getOrError(\"configuration\");\n      this._config = Options.fromObject(this._rawConfig);\n\n      // The default Runtime has sensible defaults.\n      this._runtime = opts.getOrElseFn(\"runtime\", function() {\n        return new Runtime();\n      });\n\n      this._keepAlive = new ProcessKeepAlive({\n        scheduler: this._runtime.scheduler()\n      });\n\n      var up   = opts.getOrElse(\"up\"),\n          down = opts.getOrElse(\"down\");\n\n      if (up) {\n        this.up = Promise.method(_.bind(function() {\n          return up.call(this, this._config);\n        }, this));\n      }\n\n      if (down) {\n        this.down = Promise.method(_.bind(function() {\n          return down.call(this, this._config);\n        }, this));\n      }\n\n    },\n\n    start: Promise.method(function() {\n      Log.debug(\"Starting App\");\n      this._guard\n        .deny(\"starting\")\n        .apply(\"starting\");\n\n      this._keepAlive.start();\n      Log.debug(\"Calling App#up()\");\n\n      return this.up()\n        .then(this._guard.applyAsyncFn(\"started\"));\n    }),\n\n    stop: Promise.method(function() {\n      Log.debug(\"Stopping App\");\n      this._guard\n        .deny(\"stopping\")\n        .apply(\"stopping\");\n\n      this._keepAlive.stop();\n      Log.debug(\"Calling App#down()\");\n\n      return this.down()\n        .then(this._guard.applyAsyncFn(\"stopped\"));\n    }),\n\n    /**\n     * Returns the requested configuration value, or throws an error.\n     * @param key the configuration key request from the Configuration.\n     * @returns {Object}\n     */\n    config: function(key) {\n      return this._config.getOrError(key);\n    },\n\n    /**\n     * TODO: Doc. Subclass should override.\n     */\n    up: Promise.method(function() {}),\n\n    /**\n     * TODO: Doc. Subclass should override.\n     */\n    down: Promise.method(function() {})\n  });\n\n  return App;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../core/logging/logger\"),\n  require(\"../core/options\"),\n  require(\"../core/state-guard\"),\n  require(\"../runtime\"),\n  require(\"./internal/process-keep-alive\")\n);\n\n},{\"../core/logging/logger\":62,\"../core/options\":63,\"../core/state-guard\":74,\"../runtime\":90,\"./internal/process-keep-alive\":48,\"bluebird\":107,\"underscore\":174}],44:[function(require,module,exports){\n\"use strict\";\n\nvar mod = function(\n  fs,\n  yaml,\n  nopt,\n  _,\n  Promise,\n  Options,\n  Logger,\n  ConfigurationMagic,\n  AppContainer,\n  App\n  ) {\n  var f   = Promise.promisifyAll(fs),\n      Log = Logger.create(\"Bootstrapper\");\n\n  var Bootstrapper = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Bootstrapper.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._appKlass = opts.getOrElse(\"applicationConstructor\");\n      if (!this._appKlass) {\n        this._up = opts.getOrError(\"up\");\n        this._down = opts.getOrError(\"down\");\n      }\n    },\n    bootstrap: Promise.method(function(cb) {\n      var args        = Options.fromObject(this._getArgs()),\n          scopes      = (args.getOrElse(\"scopes\", \"\")).split(\",\"),\n          configFiles = (args.getOrElse(\n            \"configurationFiles\",\n            \"configuration/default.json\"\n          )).split(\",\");\n\n      Log.info(\"Configuration scopes:\", scopes, \"Configuration files:\", configFiles);\n      var readConfigs = _.map(configFiles, function(configFile) {\n        return f\n          .readFileAsync(configFile)\n          .then(function(contents) {\n            return yaml.safeLoad(contents);\n          });\n      });\n\n      return Promise\n        .all(readConfigs)\n        .bind(this)\n        .then(function(configs) {\n          var config       = ConfigurationMagic.resolveConfig(scopes, configs),\n              AppKlass     = this._appKlass;\n\n          Log.info(\"Using resolved configuration: \", JSON.stringify(config));\n\n          var app          = AppKlass ? new AppKlass({configuration: config}) : new App({configuration: config, up: this._up, down: this._down}),\n              appContainer = new AppContainer({app: app});\n\n          return appContainer;\n        }).nodeify(cb);\n    }),\n    _getArgs: function() {\n      return nopt({\n        \"scopes\": String,\n        \"configurationFiles\": String\n      });\n    }\n  });\n\n  return Bootstrapper;\n};\n\nmodule.exports = mod(\n  require(\"fs\"),\n  require(\"js-yaml\"),\n  require(\"nopt\"),\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../core/options\"),\n  require(\"../core/logging/logger\"),\n  require(\"./configuration-magic\"),\n  require(\"./node-app-container\"),\n  require(\"./app\")\n);\n\n},{\"../core/logging/logger\":62,\"../core/options\":63,\"./app\":43,\"./configuration-magic\":47,\"./node-app-container\":49,\"bluebird\":107,\"fs\":1,\"js-yaml\":140,\"nopt\":172,\"underscore\":174}],45:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  ScopedConfiguration\n) {\n\n  /**\n   * A device for resolving a set of raw configurations given a set of\n   * scopes.\n   *\n   * This is useful for having things like region- or stage-specific (and/or both)\n   * configurations.\n   *\n   * Given sets of raw configurations of the form:\n   *\n   *   {\n   *     \"scope-1\" : {\n   *       \"key1\" : \"val1\"\n   *     },\n   *     \"scope-1+env1\": {\n   *       \"key2\" : \"val-env-1\"\n   *     },\n   *     \"scope-1+env2\": {\n   *       \"key2\" : \"val-env-2\"\n   *     }\n   *   }\n   *\n   * `resolve([\"scope-1\"])` will return:\n   *\n   *   {\n   *     \"key1\" : \"val2\"\n   *   }\n   *\n   * `resolve([\"scope-1\", \"env-1\"])` will return:\n   *\n   *   {\n   *     \"key1\" : \"val1\",\n   *     \"key2\" : \"val-env-1\"\n   *   }\n   *\n   * `resolve([\"scope-1\", \"env-2\"])` will return:\n   *\n   *   {\n   *     \"key1\" : \"val1\",\n   *     \"key2\" : \"val-env-2\"\n   *   }\n   *\n   * Scopes unions are resolved in the following manner:\n   *   1. a given scope union's parts are sorted\n   *   2. scope unions as a whole are applied in sorted order\n   *   3. repeat the process for a given configuration\n   *\n   * So, given three configs:\n   *\n   *  {\n   *    \"aaa\": ... // 1\n   *    \"ccc\": ... // 2\n   *  }\n   *\n   *  {\n   *    \"aaa+ccc\": ... // 3\n   *    \"ccc\"    : ... // 4\n   *  }\n   *\n   *  {\n   *    \"aaa+bbb\": ... // 5\n   *    \"bbb\"    : ... // 6\n   *  }\n   *\n   * The resulting order will be:\n   *   1, 2, 4, 3, 6, 5\n   *\n   * Notice 3 comes before 5 even though it's logically \"after\" in sorted order,\n   * because configuration order overrides scope order. That is, scope unions\n   * are ordered within a config, and then in config order.\n   *\n   */\n  var ScopedConfigurationResolver = function() {\n    this.initialize.apply(this, arguments);\n  }\n\n  _.extend(ScopedConfigurationResolver.prototype, {\n    initialize: function() {\n      this._configs = [];\n    },\n\n    /**\n     * A rawConfig is a set of configuration scopes and their configuration\n     * values, e.g.:\n     *\n     *   {\n     *     \"scope-1\" : {\n     *       \"key1\" : \"val1\"\n     *     },\n     *     \"scope-1+env1\": {\n     *       \"key2\" : \"val-env-1\"\n     *     },\n     *     \"scope-1+env2\": {\n     *       \"key2\" : \"val-env-2\"\n     *     }\n     *   }\n     *\n     * Note that the plus (+) sign is reserved for specifying scope unions.\n     *\n     * @param rawConfig {object} (required)\n     *\n     * @returns this\n     */\n    add: function(rawConfig) {\n      this._configs.push(new ScopedConfiguration(rawConfig));\n      return this;\n    },\n\n    /**\n     * Resolves a computed final configuration given a set of scopes to apply,\n     * and a set of configs loaded via `ScopedConfigurationResolver#add()`.\n     *\n     * @param scopes {Array<string>}\n     *\n     * @returns {object} the computed configuration\n     */\n    resolve: function(scopes) {\n      scopes = powerset(_.clone(scopes).sort());\n      scopes.shift(); // Get rid of the empty set.\n\n      scopes = _.collect(scopes, function(s) {\n        return s.join(\"+\");\n      });\n\n      var relevantConfigs = _\n        .chain(this._configs)\n        .collect(function(c) {\n          return _.collect(scopes, function(scope) {\n            return c.blobForScope(scope);\n          })\n        }).flatten().value();\n\n      relevantConfigs.unshift({});\n      return _.extend.apply(_, relevantConfigs);\n    }\n  });\n\n  var powerset = function (ary) {\n      var ps = [[]];\n      for (var i=0; i < ary.length; i++) {\n          for (var j = 0, len = ps.length; j < len; j++) {\n              ps.push(ps[j].concat(ary[i]));\n          }\n      }\n      return ps;\n  }\n\n  return ScopedConfigurationResolver;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"./scoped-configuration\")\n);\n\n},{\"./scoped-configuration\":46,\"underscore\":174}],46:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  /**\n   * Given a raw config, ensures blobs can be fetched regardless of\n   * scope union scope (i.e., does union canonicalization).\n   *\n   * For example, a config with scope union `\"bbb+aaa\"` can later be\n   * fetched using either `\"aaa+bbb\"` or `\"bbb+aaa\"`. It does this\n   * by uniformly ordering the union's composite scopes.\n   *\n   * This probably isn't a useful class on its own. Instead, defer to\n   * `ScopedConfigurationResolver` or `ConfigurationMagic`.\n   */\n  var ScopedConfiguration = function() {\n    this.initialize.apply(this, arguments);\n  }\n\n  _.extend(ScopedConfiguration.prototype, {\n    initialize: function(rawConfig) {\n      rawConfig = rawConfig || {};\n      this._scopes = {};\n      // Sort the scope strings\n      _.each(rawConfig, function(config, scopeString) {\n        var scope = scopeString.split(\"+\").sort().join(\"+\");\n        this._scopes[scope] = config;\n      }, this);\n    },\n\n    blobForScope: function(scope) {\n      return _.clone(this._scopes[scope.split(\"+\").sort().join(\"+\")] || {});\n    }\n  });\n\n  return ScopedConfiguration;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],47:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  ScopedConfigurationResolver\n) {\n\n  /**\n   * A utility \"class\" for configuration-related functionality.\n   * @constructor\n   */\n  var ConfigurationMagic = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(ConfigurationMagic.prototype, {\n    initialize: function() {}\n  });\n\n  _.extend(ConfigurationMagic, {\n    /**\n     * Returns a resolved configuration, given multiple configuration documents and a set of scopes. See\n     * `ScopedConfigurationResolver`.\n     */\n    resolveConfig: function(scopes, configObjects) {\n      var r = new ScopedConfigurationResolver();\n      _.each(configObjects, function(c) {\n        r.add(c);\n      });\n      return r.resolve(scopes);\n    }\n  });\n\n  return ConfigurationMagic;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"./config/scoped-configuration-resolver\")\n);\n\n},{\"./config/scoped-configuration-resolver\":45,\"underscore\":174}],48:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Logger,\n  Options\n) {\n\n  var TEN_MINUTES_IN_MILLISECONDS = 60 * 1000 * 10;\n\n  var Log = Logger.create(\"ProcessKeepAlive\");\n\n  /**\n   * Keeps a (node) process \"alive\" by keeping at least one bit of (noop) work scheduled for execution.\n   *\n   * @constructor\n   */\n  var ProcessKeepAlive = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(ProcessKeepAlive.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._scheduler = opts.getOrError(\"scheduler\");\n      this._timeoutId = null;\n\n      _.bindAll(this, \"_cycle\");\n    },\n    start: function() {\n      Log.debug(\"Starting ProcessKeepAlive\");\n      this._cycle();\n    },\n    stop: function() {\n      Log.debug(\"Stopping ProcessKeepAlive\");\n      if (this._timeoutId) {\n        this._scheduler.get().unschedule(this._timeoutId);\n        this._timeoutId = null;\n      }\n    },\n    _cycle: function() {\n      this._timeoutId = this._scheduler.get().schedule(\n        this._cycle,\n        TEN_MINUTES_IN_MILLISECONDS\n      );\n    }\n  });\n\n  return ProcessKeepAlive;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../../core/logging/logger\"),\n  require(\"../../core/options\")\n);\n\n},{\"../../core/logging/logger\":62,\"../../core/options\":63,\"underscore\":174}],49:[function(require,module,exports){\n(function (process){\n/*global require: false, module: false, process: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options,\n  Logger,\n  CountdownLatch\n) {\n\n  var Log = Logger.create(\"AppContainer\");\n\n  var NodeAppContainer = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(NodeAppContainer.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts)\n      this._app = opts.getOrError(\"app\");\n\n      var shutdownLatch = new CountdownLatch(1, _.bind(function() {\n        Promise\n          .bind(this)\n          .then(function() {\n            Log.info(\"Received shutdown request, stopping...\");\n            return this._app.stop();\n          })\n          .then(function() {\n            process.exit(0);\n          })\n          .caught(function(err) {\n            Log.error(\"Caught error shutting down:\", err);\n            process.exit(1);\n          });\n      }, this));\n\n      this._requestShutdown = shutdownLatch.step.bind(shutdownLatch);\n    },\n\n    start: Promise.method(function() {\n      return Promise\n        .bind(this)\n        .then(function() {\n          return this._registerSig();\n        })\n        .then(function() {\n          return this._app.start();\n        });\n    }),\n\n    stop: Promise.method(function(reason) {\n      return this._app.stop().then(function() {\n        if (reason) {\n          Log.error(\"Stopping due to reason:\", reason);\n          process.exit(1);\n        } else {\n          process.exit(0)\n        }\n      });\n    }),\n\n    _registerSig: Promise.method(function() {\n      process.on(\"SIGINT\", _.bind(function() {\n        this._requestShutdown()\n      }, this));\n\n      process.on(\"SIGTERM\", _.bind(function() {\n        this._requestShutdown()\n      }, this));\n    })\n  });\n\n  return NodeAppContainer;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../core/options\"),\n  require(\"../core/logging/logger\"),\n  require(\"../core/countdown-latch\")\n);\n\n}).call(this,require('_process'))\n},{\"../core/countdown-latch\":58,\"../core/logging/logger\":62,\"../core/options\":63,\"_process\":11,\"bluebird\":107,\"underscore\":174}],50:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options,\n  ObjectHashMap\n) {\n\n  var DEFAULT_DEFAULT_FN = function(key) {\n    return null;\n  };\n\n  var DefaultingHashmap = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(DefaultingHashmap.prototype, ObjectHashMap.prototype, {\n    initialize: function(opts) {\n      ObjectHashMap.prototype.initialize.apply(this, arguments);\n      opts = Options.fromObject(opts);\n      this._defaultFn = opts.getOrElse(\"defaultFn\", DEFAULT_DEFAULT_FN);\n    },\n    get: function(key) {\n      var realKey = this._makeKey(key);\n      var v = this._store[realKey];\n      if (typeof v === \"undefined\") {\n        v = this._store[realKey] = this._defaultFn(key);\n      }\n      return v;\n    }\n  });\n\n  return DefaultingHashmap;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../core/options\"),\n  require(\"./object-hash-map\")\n);\n\n},{\"../core/options\":63,\"./object-hash-map\":54,\"underscore\":174}],51:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options\n) {\n\n  /**\n   * A doubly-linked list implementation.\n   *\n   */\n  var DoublyLinkedList = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(DoublyLinkedList.prototype, {\n    initialize: function() {\n      this._front = null;\n      this._back = null;\n      this._size = 0;\n    },\n\n    get: function(idx) {\n      this._checkElementIdxOrThrow(idx);\n      var node = this._walkToIdx(idx);\n      return node.value();\n    },\n\n    exists: function(value) {\n      var node = this._walkToValue(value);\n      return !!node;\n    },\n\n    size: function() {\n      return this._size;\n    },\n\n    add: function(value) {\n      return this.addBack.apply(this, arguments);\n    },\n\n    addFront: function(value) {\n      this._linkFront(value);\n    },\n\n    addBack: function(value) {\n      this._linkBack(value);\n    },\n\n    remove: function(value) {\n      var node = this._walkToValue(value);\n      return this._unlink(node);\n    },\n\n    removeFront: function() {\n      if (this._front === null) {\n        throw new Error(\"No such element\");\n      }\n      return this._unlinkFront(this._front);\n    },\n\n    removeBack: function() {\n      if (this._back === null) {\n        throw new Error(\"No such element\");\n      }\n      return this._unlinkBack(this._back);\n    },\n\n    insertAtIndex: function(idx, value) {\n      this._checkIsElementPositionOrThrow(idx);\n\n      if (idx === this._size) {\n        this.addBack(value);\n      } else {\n        var node = this._walkToIdx(idx);\n        this._linkBefore(value, node);\n      }\n    },\n\n    removeAtIndex: function(idx) {\n      this._checkElementIdxOrThrow(idx);\n      if (idx === 0) {\n        return this._unlinkFront(this._front);\n      } else if ( idx === (this._size - 1) ) {\n        return this._unlinkBack(this._back);\n      } else {\n        var node = this._walkToIdx(idx);\n        return this._unlink(node);\n      }\n    },\n\n    clear: function() {\n      var node = this._front,\n          next;\n\n      while (node !== null) {\n        next = node.next();\n        node.dispose();\n        node = next;\n      }\n      this._front = null;\n      this._back  = null;\n      this._size = 0;\n    },\n\n    _linkFront: function(value) {\n      var oldFront = this._front,\n          newNode = new Node({value: value});\n      this._front = newNode;\n\n      if (oldFront === null) {\n        this._back = newNode;\n      } else {\n        oldFront.setPrev(newNode);\n        newNode.setNext(oldFront);\n      }\n\n      this._size++;\n      return newNode;\n    },\n\n    _linkBack: function(value) {\n      var oldBack = this._back,\n          newNode = new Node({value: value});\n\n      this._back = newNode;\n      if (oldBack === null) {\n        this._front = newNode;\n      } else {\n        oldBack.setNext(newNode);\n        newNode.setPrev(oldBack);\n      }\n\n      this._size++;\n      return newNode;\n    },\n\n    _linkBefore: function(value, node) {\n      var pred    = node.prev(),\n          newNode = new Node({value: value, prev: pred, next: node});\n\n      node.setPrev(newNode);\n      if (pred === null) {\n        this._front = newNode;\n      } else {\n        pred.setNext(newNode);\n      }\n      this._size++;\n      return newNode;\n    },\n\n    _unlinkFront: function(node) {\n      var value    = node.value(),\n          newFront = node.next();\n\n      node.dispose();\n      this._front = newFront;\n      if (newFront === null) {\n        this._back = null;\n      } else {\n        newFront.setPrev(null);\n      }\n      this._size--;\n      return value;\n    },\n\n    _unlinkBack: function(node) {\n      var value   = node.value(),\n          newBack = node.prev();\n\n      node.dispose();\n      this._back = newBack;\n      if (newBack == null) {\n        this._front = null;\n      } else {\n        newBack.setNext(null);\n      }\n      this._size--;\n      return value;\n    },\n\n    _unlink: function(node) {\n      var prev  = node.prev(),\n          next  = node.next(),\n          value = node.value();\n\n      if (prev === null) {\n        this._front = next;\n      } else {\n        prev.setNext(next);\n      }\n\n      if (next === null) {\n        this._back = prev;\n      } else {\n        next.setPrev(prev);\n      }\n\n      node.dispose();\n      this._size--;\n      return value;\n    },\n\n    _walkToIdx: function(idx) {\n      var node, current;\n      if (idx < this._size / 2) {\n        node = this._front;\n        current = 0;\n        while(current !== idx) {\n          node = node.next();\n          current++;\n        }\n      } else {\n        node = this._back;\n        current = this._size - 1;\n\n        while(current !== idx) {\n          node = node.prev();\n          current--;\n        }\n      }\n      return node;\n    },\n\n    _walkToValue: function(value) {\n      var n = this._front;\n      while (n !==null ) {\n        if (n.match(value)) {\n          return n;\n        }\n        n = n.next();\n      }\n      return null;\n    },\n\n    _isElementIdx: function(idx) {\n      return (idx >= 0 && idx < this._size);\n    },\n\n    _isElementPosition: function(idx) {\n      return (idx >= 0 && idx <= this._size);\n    },\n\n    _checkElementIdxOrThrow: function(idx) {\n      if (!this._isElementIdx(idx)) {\n        throw new Error(\"Index out of bounds; size: \" + this._size + \"; idx: \" + idx);\n      }\n    },\n\n    _checkIsElementPositionOrThrow: function(idx) {\n      if (!this._isElementPosition(idx)) {\n        throw new Error(\"Index out of bounds; size: \" + this._size + \"; idx: \" + idx);\n      }\n    }\n\n  });\n\n  var Node = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Node.prototype, {\n    initialize: function(opts) {\n      opts        = Options.fromObject(opts);\n      this._next  = opts.getOrElse(\"next\", null);\n      this._prev  = opts.getOrElse(\"prev\", null);\n      this._value = opts.getOrElse(\"value\", null);\n    },\n\n    next: function() {\n      return this._next;\n    },\n\n    prev: function() {\n      return this._prev;\n    },\n\n    setNext: function(node) {\n      this._next = node;\n    },\n\n    setPrev: function(node) {\n      this._prev = node;\n    },\n\n    value: function() {\n      return this._value;\n    },\n\n    dispose: function() {\n      this._next  = null;\n      this._prev  = null;\n      this._value = null;\n    },\n\n    match: function(value) {\n      return this._value === value;\n    }\n  });\n\n  return DoublyLinkedList;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../core/options\")\n);\n\n},{\"../core/options\":63,\"underscore\":174}],52:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options,\n  ObjectHashMap,\n  DoublyLinkedList\n) {\n\n  /**\n   * An in-memory hash map with an LRU eviction policy.\n   *\n   */\n  var LRUHashMap = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(LRUHashMap.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._capacity = opts.getOrError(\"capacity\");\n      this._keyAccessList = new DoublyLinkedList();\n      // TODO: Really need a proper HashMap at some point...\n      this._store = new ObjectHashMap();\n    },\n    get: function(key) {\n      var entry = this._store.get(key);\n      if (!entry) {\n        return;\n      }\n\n      // As a perf optimization, we keep a ref\n      // to the node in the entry.\n      var node = entry.node();\n      this._keyAccessList._unlink(node);\n\n      // Get the new node\n      node = this._keyAccessList._linkFront(entry.key());\n\n      // Save it\n      entry.setNode(node);\n      // Return the value\n      return entry.value();\n    },\n\n    put: function(key, val) {\n      var entry = this._store.get(key),\n          node;\n      if (!entry) {\n        // If no entry, make a new entry\n        if (this._keyAccessList.size() >= this._capacity) {\n          // Have to make room for it\n          var evictedKey = this._keyAccessList.removeBack(),\n              evictedEntry = this._store.get(evictedKey);\n\n          evictedEntry.dispose();\n          this._store.remove(evictedKey);\n        }\n\n        node = this._keyAccessList._linkFront(key);\n        entry = new Entry({\n          key: key,\n          value: val,\n          node: node\n        });\n        this._store.put(key, entry);\n      } else {\n        // \"Touch\" the entry, set new value\n        node = entry.node();\n        this._keyAccessList._unlink(node);\n        node = this._keyAccessList._linkFront(entry.key());\n        // Update with the new node and value\n        entry.setNode(node);\n        entry.setValue(val);\n      }\n    },\n\n    remove: function(key) {\n      var entry = this._store.get(key),\n          value,\n          node;\n      if (entry) {\n        value = entry.value();\n        node = entry.node();\n        this._keyAccessList._unlink(node);\n        entry.dispose();\n        this._store.remove(key);\n        return value;\n      }\n    },\n\n    exists: function(key) {\n      return this._store.exists(key);\n    },\n\n    size: function() {\n      return this._store.size();\n    },\n\n    clear: function() {\n      this._store.clear();\n      this._keyAccessList.clear();\n    }\n  });\n\n  var Entry = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Entry.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      // Though the Node should have the key, if the node\n      // is unlinked from the list, its boxed value will disappear\n      this._key   = opts.getOrError(\"key\");\n      this._value = opts.getOrError(\"value\");\n      this._node  = opts.getOrError(\"node\");\n    },\n    node: function() {\n      return this._node;\n    },\n    setNode: function(node) {\n      this._node = node;\n    },\n    value: function() {\n      return this._value;\n    },\n    setValue: function(value) {\n      this._value = value;\n    },\n    key: function() {\n      return this._key;\n    },\n    dispose: function() {\n      this._key = null;\n      this._value = null;\n      this._node = null;\n    }\n  });\n\n  return LRUHashMap;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../core/options\"),\n  require(\"./object-hash-map\"),\n  require(\"./doubly-linked-list\")\n);\n\n},{\"../core/options\":63,\"./doubly-linked-list\":51,\"./object-hash-map\":54,\"underscore\":174}],53:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  DefaultingHashMap\n) {\n\n  var MultiMap = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(MultiMap.prototype, {\n    initialize: function() {\n      this._store = new DefaultingHashMap({\n        defaultFn: function(key) {\n          return [];\n        }\n      });\n    },\n    get: function(key) {\n      return this._store.get(key);\n    },\n    put: function(key, val) {\n      var v = this._store.get(key);\n      v.push(val);\n    },\n    remove: function(key, val) {\n      var v = this._store.get(key);\n      var idx = v.indexOf(val);\n      if (idx !== -1) {\n        v.splice(idx, 1);\n        return v;\n      }\n      return void 0;\n    },\n    removeAll: function(key) {\n      var v = this._store.get(key);\n      this._store.remove(key);\n      return v;\n    },\n    exists: function(key, val) {\n      return this._store.exists(key) && _.contains(this._store.get(key), val)\n    },\n    keys: function() {\n      return this._store.keys();\n    },\n    values: function() {\n      return _\n        .chain(this._store.keys())\n        .map(_.bind(function(key) {\n          return this._store.get(key);\n        }, this))\n        .flatten()\n        .value();\n    },\n    size: function() {\n      return _.size(this.values());\n    },\n    clear: function() {\n      this._store.clear();\n    }\n  });\n\n  return MultiMap;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"./defaulting-hash-map\")\n);\n\n},{\"./defaulting-hash-map\":50,\"underscore\":174}],54:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options\n) {\n\n  /**\n   * Delegates storage to a JS object.\n   */\n  var ObjectHashMap = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n\n  _.extend(ObjectHashMap.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._store = {};\n      this._keyPrefix = opts.getOrElse(\"keyPrefix\", \"ohm-\");\n    },\n    get: function(key){\n      return this._store[this._makeKey(key)];\n    },\n    put: function(key, val) {\n      this._store[this._makeKey(key)] = val;\n    },\n    remove: function(key) {\n      var val;\n      key = this._makeKey(key);\n      if (_.has(this._store, key)) {\n        val = this._store[key];\n        delete this._store[key];\n      }\n      return val;\n    },\n    exists: function(key) {\n      return _.has(this._store, this._makeKey(key));\n    },\n    size: function() {\n      return _.size(this._store);\n    },\n    clear: function() {\n      this._store = {};\n    },\n    keys: function() {\n      return _\n        .chain(this._store)\n        .keys()\n        .map(_.bind(function(key) {\n          return this._unmakeKey(key);\n        }, this))\n        .value();\n    },\n    values: function() {\n      return _.values(this._store);\n    },\n    _makeKey: function(key) {\n      return this._keyPrefix + key;\n    },\n    _unmakeKey: function(madeKey) {\n      return madeKey.substr(this._keyPrefix.length);\n    }\n  });\n\n\n  return ObjectHashMap;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../core/options\")\n);\n\n},{\"../core/options\":63,\"underscore\":174}],55:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  M,\n  Options,\n  Channel\n) {\n\n  // FIXME: Delete this in favor of CompositeChannel\n  var ChainedChannel = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(ChainedChannel.prototype, Channel.prototype, {\n    initialize: function(opts) {\n      Channel.prototype.initialize.apply(this, arguments);\n      opts = Options.fromObject(opts);\n\n      _.bindAll(this, \"_forward\");\n      this._chainedSubs = M.vector();\n\n      var initiallyChainedTo = opts.getOrElse(\"chainTo\");\n      if (initiallyChainedTo) {\n        this.chainTo(initiallyChainedTo);\n      }\n    },\n\n    chainTo: function(otherChannel) {\n      this._chainedSubs = M.conj(this._chainedSubs, otherChannel.subscribe(this._forward));\n    },\n\n    dispose: function() {\n      var subs = this._chainedSubs;\n\n      this._chainedSubs = M.vector();\n\n      M.each(subs, function(sub) {\n        sub.dispose();\n      });\n\n      return this._dispose.apply(this, arguments);\n    },\n\n    _forward: function(msg) {\n      this._publish(this._sentinel, msg);\n    }\n  });\n\n  return ChainedChannel;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"mori\"),\n  require(\"../options\"),\n  require(\"./channel\")\n);\n\n},{\"../options\":63,\"./channel\":56,\"mori\":171,\"underscore\":174}],56:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  M,\n  UUID,\n  Options,\n  StateGuard\n) {\n\n  /**\n   * A channel is a path through which messages flow.\n   *\n   * Channels are meant to have a single publisher, multiple subscribers.\n   *\n   * This is \"enforced\" using a sentinel. The same sentinel provided during\n   * instantiation must be used when calling `publish`, else an exception\n   * is raised.\n   *\n   */\n  var Channel = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Channel.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._sentinel      = opts.getOrError(\"sentinel\");\n      this._stateGuard    = new StateGuard([\"disposed\"]);\n      this._subscriptions = M.hash_map();\n    },\n\n    reset: function() {\n      M.each(this._subscriptions, function(pair) {\n        M.nth(pair, 1).dispose();\n      });\n      this._subscriptions = M.hash_map();\n    },\n\n    publish: function(sentinel, msg) {\n      return this._publish.apply(this, arguments);\n    },\n\n\n    subscribe: function(handler) {\n      return this._subscribe.apply(this, arguments);\n    },\n\n\n    dispose: function() {\n      return this._dispose.apply(this, arguments);\n    },\n\n\n    isDisposed: function() {\n      return this._stateGuard.applied(\"disposed\");\n    },\n\n\n    _publish: function(sentinel, msg) {\n      this._stateGuard.deny(\"disposed\");\n\n      if (this._sentinel !== sentinel) {\n        throw new Error(\"Invalid sentinel provided; publisher must have same sentinel provided during instantiation.\");\n      }\n      this._dispatch(msg);\n      return true;\n    },\n\n\n    _subscribe: function(handler) {\n      this._stateGuard.deny(\"disposed\");\n\n      var sub = new Subscription(this, handler),\n          id  = sub.id();\n\n      this._subscriptions = M.assoc(this._subscriptions, id, sub);\n\n      return sub;\n    },\n\n\n    _dispose: function() {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      // Gnarly, as this hops back and forth between the channel and the sub, but\n      // easier than splitting the dispose logic into two methods in the sub.\n      M.each(this._subscriptions, function(pair) {\n        M.nth(pair, 1).dispose();\n      });\n\n      this._subscriptions = M.hash_map();\n\n      this._stateGuard.apply(\"disposed\");\n    },\n\n\n    _dispatch: function(msg) {\n      M.each(this._subscriptions, function(pair) {\n        M.nth(pair, 1).dispatch(msg);\n      });\n    },\n\n\n    _disposeHandle: function(id) {\n      this._subscriptions = M.dissoc(this._subscriptions, id);\n    }\n  });\n\n  var Subscription = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Subscription.prototype, {\n    initialize: function(channel, handler) {\n      this._id         = UUID.v4();\n      this._channel    = channel;\n      this._handler    = handler;\n      this._stateGuard = new StateGuard([\"disposed\"]);\n\n      _.bindAll(this, \"dispose\");\n    },\n\n\n    dispose: function() {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      this._channel._disposeHandle(this._id);\n\n      this._handler = null;\n      this._channel = null;\n\n      this._stateGuard.apply(\"disposed\");\n    },\n\n\n    id: function() {\n      return this._id;\n    },\n\n\n    dispatch: function(msg) {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      this._handler(msg);\n    }\n  });\n\n  return Channel;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"mori\"),\n  require(\"../uuid\"),\n  require(\"../options\"),\n  require(\"../state-guard\")\n);\n\n},{\"../options\":63,\"../state-guard\":74,\"../uuid\":75,\"mori\":171,\"underscore\":174}],57:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  M,\n  Options,\n  Channel\n) {\n\n  /**\n   * A channel which listens to other channels, and forwards their messages as through published to this channel\n   *\n   */\n  var CompositeChannel = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(CompositeChannel.prototype, Channel.prototype, {\n    initialize: function(opts) {\n      Channel.prototype.initialize.apply(this, arguments);\n      opts = Options.fromObject(opts);\n\n      this._forwarding = M.hash_map();\n\n      var listen = opts.getOrElse(\"listen\", []);\n      if (!_.isArray(listen)) {\n        listen = [listen];\n      }\n\n      _.each(listen, _.bind(function(c) {\n        this.listen(c);\n      }, this));\n    },\n\n\n    dispose: function() {\n      Channel.prototype.dispose.apply(this, arguments);\n      var forwarding = this._forwarding;\n      this._forwarding = M.hash_map();\n\n      M.each(forwarding, _.bind(function(pair) {\n        M.nth(pair, 1).dispose();\n      }, this));\n    },\n\n\n    listen: function(channel) {\n      var sub = channel.subscribe(_.bind(function(msg) {\n        this._forward(msg)\n      }, this));\n      this._forwarding = M.assoc(this._forwarding, channel, sub);\n\n      return {\n        dispose: _.bind(function() {\n          this._forwarding = M.dissoc(this._forwarding, channel);\n          sub.dispose();\n        }, this)\n      };\n    },\n\n\n    _forward: function(msg) {\n      this.publish(this._sentinel, msg);\n    }\n  });\n\n  return CompositeChannel;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"mori\"),\n  require(\"../options\"),\n  require(\"./channel\")\n);\n\n},{\"../options\":63,\"./channel\":56,\"mori\":171,\"underscore\":174}],58:[function(require,module,exports){\n/*global require: false, module: false */\n\nvar mod = function (\n  _\n  ) {\n\n  /**\n   * A device which calls the provided completionCallback after `steps` calls to `CountdownLatch#step()`.\n   *\n   */\n\n  var CountdownLatch = function () {\n        this.initialize.apply(this, arguments);\n      },\n      noop = function() {};\n\n  _.extend(CountdownLatch.prototype, {\n    initialize: function (steps, completionCallback) {\n      this._steps = steps || 0;\n      this._completionCallback = completionCallback || noop;\n      _.bindAll(this, \"_completionCallback\", \"_triggerCompletion\");\n      if(isNaN(this._steps) || this._steps < 0) {\n        throw new Error(\"CountdownLatch: Number of steps are invalid.\");\n      }\n      this._current = 0;\n      this._complete = false;\n      this._error = null;\n      if(this._steps === 0) {\n        _.defer(this._triggerCompletion);\n        return;\n      }\n    },\n    step: function (steps) {\n      if (this._complete || this._steps === 0) {\n        return;\n      }\n      this._current += steps || 1;\n      if (this._current >= this._steps) {\n        this._triggerCompletion();\n      }\n    },\n    error: function (err) {\n      if (this._complete || this._steps === 0) {\n        return;\n      }\n      this._error = err;\n      this._triggerCompletion();\n    },\n    _triggerCompletion: function () {\n      if (this._complete) {\n        return;\n      }\n      this._complete = true;\n      if (this._error) {\n        _.defer(_.bind(this._completionCallback, null, this._error));\n      } else {\n        _.defer(this._completionCallback);\n      }\n    }\n  });\n\n  return CountdownLatch;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],59:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  M,\n  Options,\n  StateGuard\n) {\n\n  /**\n   * Attempts to intelligently dispatch an object with an mT attribute, using\n   * the rules provided at instantiation.\n   *\n   * For a given mTyped object, searches the provided `delegate` for a method\n   * named [prefix][camel-cased mT], and if present, calls it. If not found,\n   * looks for [prefix]Else. If the mT attribute isn't found, dispatches to\n   * [prefix]Malformed.\n   */\n  var Dispatcher = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  var DEFAULT_CONTEXT_DELEGATE = function() {\n    return {};\n  };\n\n  _.extend(Dispatcher.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._delegate        = opts.getOrError(\"delegate\"),\n      this._prefix          = opts.getOrElse(\"prefix\", \"onMsg\");\n      this._elseSuffix      = opts.getOrElse(\"elseSuffix\", \"else\");\n      this._malformedSuffix = opts.getOrElse(\"malformedSuffix\", \"malformed\");\n      this._contextDelegate = opts.getOrElse(\"contextDelegate\", DEFAULT_CONTEXT_DELEGATE);\n      this._stateGuard      = new StateGuard([\"disposed\"]);\n      this._subs            = M.hash_map();\n\n      var channels = opts.getOrElse(\"listen\", []);\n\n      if (!_.isArray(channels)) {\n        channels = [channels];\n      }\n\n      _.each(channels, _.bind(function(c) {\n        this.listen(c)\n      }, this));\n    },\n\n    listen: function(channel) {\n      this._stateGuard.deny(\"disposed\");\n\n      var sub = channel.subscribe(_.bind(function(msg) {\n        this.dispatch(msg);\n      }, this));\n\n      this._subs = M.assoc(this._subs, sub.id(), sub);\n\n      return {\n        dispose: _.bind(function(){\n          var nSub = M.get(this._subs, sub.id());\n          if (nSub) {\n            this._subs = M.dissoc(this._subs, sub.id());\n            nSub.dispose();\n          }\n        }, this)\n      }\n    },\n\n    dispatch: function(mTyped, ctx) {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      var handler = this._getVettedHandlerName(mTyped);\n\n      if (handler) {\n        this._delegate[handler](mTyped, this._contextDelegate(mTyped, ctx));\n      }\n    },\n\n    /**\n     * Like `dispatch`, but expects delegate to return a Promise<object>\n     */\n    dispatchAsync: Promise.method(function(mTyped, ctx) {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      var handler = this._getVettedHandlerName(mTyped);\n      if (handler) {\n        return this._delegate[handler](mTyped, this._contextDelegate(mTyped, ctx));\n      } else {\n        // Not having a handler when a reply is requested is the same as returning\n        // a promise that never resolves.\n        return new Promise(function(resolve) {});\n      }\n    }),\n\n    dispose: function() {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      var subs = this._subs;\n      this._subs = M.hash_map();\n\n      M.each(subs, function(pair) {\n        M.nth(pair, 1).dispose();\n      });\n\n      this._delegate = null;\n\n      this._stateGuard.apply(\"disposed\");\n    },\n\n    _getHandlerName: function(prefix, suffix) {\n      return prefix + suffix.charAt(0).toUpperCase() + suffix.substr(1);\n    },\n\n    // FIXME: Check for \"reserved\" mTypes (_elseSuffix, _malformedSuffix, etc), log warning\n    _getVettedHandlerName: function(mTyped) {\n      var mT = mTyped.mT,\n          prefix = this._prefix,\n          potentialHandlerName,\n          finalHandlerName;\n\n      if (!mT) {\n        finalHandlerName = this._getHandlerName(prefix, this._malformedSuffix);\n      } else {\n        potentialHandlerName = this._getHandlerName(prefix, mT);\n        if (_.isFunction(this._delegate[potentialHandlerName])) {\n          finalHandlerName = potentialHandlerName;\n        } else {\n          finalHandlerName = this._getHandlerName(prefix, this._elseSuffix);\n        }\n      }\n\n      if (_.isFunction(this._delegate[finalHandlerName])) {\n        return finalHandlerName;\n      }\n    }\n  });\n\n  return Dispatcher;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"mori\"),\n  require(\"./options\"),\n  require(\"./state-guard\")\n);\n\n},{\"./options\":63,\"./state-guard\":74,\"bluebird\":107,\"mori\":171,\"underscore\":174}],60:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar factory = function(\n  _,\n  Promise,\n  Options\n) {\n\n  /**\n   * A utility singleton for \"language extensions\".\n   */\n  var Lang = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Lang.prototype, {\n    initialize: function(){}\n  });\n\n  _.extend(Lang, {\n    noop: function() {},\n\n    partiallyApply: function() {\n      var args = _.toArray(arguments),\n          fun  = args.shift();\n\n      return function() {\n        return fun.apply(null, args.concat(arguments));\n      };\n    },\n\n    makeErrorClass: function(name, defaultMessage) {\n      if (!name) {\n        throw new Error(\"makeErrorClass requires `name`\");\n      }\n\n      var klass = function(message) {\n        this.name    = name;\n        this.message = this.name + \": \" + (message || defaultMessage || \"An unexpected error occurred\");\n\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(this, klass);\n        }\n      };\n\n      klass.prototype = Object.create(Error.prototype);\n      klass.prototype.constructor = klass;\n      return klass;\n    },\n\n    pojoClass: function(attributes, options) {\n      if (!_.isArray(attributes)) {\n        throw new Error(\"Lang#pojoClass requires attributes array\");\n      }\n\n      var options = Options.fromObject(options),\n          // optional specifies keys that are optional, with values that are default if not provided\n          defaults = options.getOrElse(\"defaults\", {}),\n          optionalAttributes = _.keys(defaults);\n\n      var toAttributeName = function(attr) {\n            return \"_\" + attr;\n          },\n          toGetter = function(attr) {\n            return attr;\n          },\n          toSetter = function(attr) {\n            return \"set\" + attr.charAt(0).toUpperCase() + attr.substr(1);\n          };\n\n      var klass = function() {\n        this.initialize.apply(this, arguments);\n      };\n\n      _.extend(klass.prototype, {\n        initialize: function(opts) {\n          opts = Options.fromObject(opts);\n          _.each(attributes, function(attr) {\n            if (_.contains(optionalAttributes, attr)) {\n              this[toAttributeName(attr)] = opts.getOrElse(attr, defaults[attr]);\n            } else {\n              this[toAttributeName(attr)] = opts.getOrError(attr);\n            }\n          }, this);\n        },\n\n        toObj: function() {\n          return _.inject(attributes, function(m, k) {\n            m[k] = this[k]();\n            return m;\n          }, {}, this);\n        }\n      });\n\n      _.each(attributes, function(attr) {\n        klass.prototype[toGetter(attr)] = function() {\n          return this[toAttributeName(attr)];\n        };\n        klass.prototype[toSetter(attr)] = function(v) {\n          this[toAttributeName(attr)] = v;\n        };\n      });\n\n      return klass;\n    },\n\n    deferred: function(promiseClass) {\n      promiseClass = promiseClass || Promise;\n      var res = null, rej = null;\n      var p = new promiseClass(function() {\n        res = arguments[0];\n        rej = arguments[1];\n      });\n\n      return {\n        promise: p,\n        resolve: res,\n        reject:  rej\n      };\n    },\n\n    /**\n     * I suddenly regret using 'new' for everything. This function returns an mType factory function.\n     *\n     * @param mType\n     * @param attributes\n     * @param options\n     * @returns {Function}\n     */\n    makeMTypeBuilder: function(mType, attributes, options) {\n      attributes = attributes || [];\n      options    = options || {};\n      options.defaults = _.extend({}, options.defaults || {}, {\n        mT: mType\n      });\n      attributes.unshift(\"mT\");\n\n      var pojoClass = Lang.pojoClass(attributes, options);\n\n      return function() {\n        var args = _.toArray(arguments);\n\n        var f = function() {\n          return pojoClass.apply(this, args);\n        }\n\n        f.prototype = pojoClass.prototype;\n        return (new f()).toObj();\n      }\n    }\n  });\n\n  return Lang;\n};\n\nmodule.exports = factory(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"./options\")\n);\n\n},{\"./options\":63,\"bluebird\":107,\"underscore\":174}],61:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options\n) {\n\n  /**\n   * An appender which logs to the global `console`.\n   *\n   */\n  var ConsoleLogAppender = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  var p = function(num) {\n    if ((\"\" + num).length === 1) {\n      return \"0\" + num;\n    } else {\n      return num;\n    }\n  };\n\n  _.extend(ConsoleLogAppender.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._console = opts.getOrElse(\"console\", console);\n      this._timeDelegate = opts.getOrElse(\"timeDelegate\", function(){\n        var d = new Date();\n        return [d.getUTCFullYear(), p(d.getUTCMonth()), p(d.getUTCDay())].join(\"/\") +\n          \" \" + [p(d.getUTCHours()), p(d.getUTCMinutes()), p(d.getUTCSeconds())].join(\":\") +\n          \".\" + d.getUTCMilliseconds();\n      });\n    },\n\n    log: function(loggerName, descendants, logLevel, logLevelName, args) {\n      // Use the furthest ancestor as the logged name (since it originated there)\n      var furthestAncestor = descendants[descendants.length - 1];\n      if (furthestAncestor) {\n        loggerName = furthestAncestor;\n      }\n      this._log([\"[\"+logLevelName+\"][\"+this._getTime()+\"][\"+loggerName+\"]\"].concat(args));\n    },\n\n    _getTime: function() {\n      return this._timeDelegate();\n    },\n\n    _log: function(logItems) {\n      // Why does he do this? Is he insane? Well, yes.\n      //\n      // But mostly, I do this because console.log isn't, in all cases,\n      // something you can call .apply on. Last I checked, in IE calling\n      // console.log.apply(console, []) will throw an error. So that's why the\n      // big ugly switch.\n      //\n      // If you need more than 7 items, well, I can't help you (but you can - add another\n      // switch case).\n      switch(logItems.length) {\n        case 0:\n          this._console.log();\n          break;\n        case 1:\n          this._console.log(logItems[0]);\n          break;\n        case 2:\n          this._console.log(logItems[0], logItems[1]);\n          break;\n        case 3:\n          this._console.log(logItems[0], logItems[1], logItems[2]);\n          break;\n        case 4:\n          this._console.log(logItems[0], logItems[1], logItems[2], logItems[3]);\n          break;\n        case 5:\n          this._console.log(logItems[0], logItems[1], logItems[2], logItems[3], logItems[4]);\n          break;\n        case 6:\n          this._console.log(logItems[0], logItems[1], logItems[2], logItems[3], logItems[4], logItems[5]);\n          break;\n        case 7:\n          this._console.log(logItems[0], logItems[1], logItems[2], logItems[3], logItems[4], logItems[5], logItems[6]);\n          break;\n        default:\n          var label = logItems.shift();\n          this._console.log(label, logItems);\n      }\n    }\n  });\n\n  return ConsoleLogAppender;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../../options\")\n);\n\n},{\"../../options\":63,\"underscore\":174}],62:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Ref,\n  Options\n) {\n\n  /**\n   * A Logger.\n   *\n   * Any appender provided to `addAppender` should have a .log method (see `ConsoleLogAppender`).\n   *\n   */\n  var Logger = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Logger.prototype, {\n\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._name         = opts.getOrElse(\"name\", \"Default\");\n      this._logLevel     = opts.getOrElse(\"logLevel\", LogUtil.Level.Info);\n      this._parent       = opts.getOrElseFn(\"refParent\", function() { return Ref(null) });\n      this._muted        = {};\n      this._appenders = [];\n    },\n\n    mute: function(name) {\n      this._muted[name] = true;\n    },\n\n    unmute: function(name) {\n      delete this._muted[name];\n    },\n\n    trace: function() {\n      this._log(LogUtil.Level.Trace, _.toArray(arguments));\n    },\n\n    debug: function() {\n      this._log(LogUtil.Level.Debug, _.toArray(arguments));\n    },\n\n    info: function() {\n      this._log(LogUtil.Level.Info, _.toArray(arguments));\n    },\n\n    warn: function() {\n      this._log(LogUtil.Level.Warn, _.toArray(arguments));\n    },\n\n    error: function() {\n      this._log(LogUtil.Level.Error, _.toArray(arguments));\n    },\n\n    fatal: function() {\n      this._log(LogUtil.Level.Fatal, _.toArray(arguments));\n    },\n\n    isTraceEnabled: function() {\n      return this.isLogLevelEnabled(LogUtil.Level.Trace);\n    },\n\n    isDebugEnabled: function() {\n      return this.isLogLevelEnabled(LogUtil.Level.Debug);\n    },\n\n    isInfoEnabled: function() {\n      return this.isLogLevelEnabled(LogUtil.Level.Info);\n    },\n\n    isWarnEnabled: function() {\n      return this.isLogLevelEnabled(LogUtil.Level.Warn);\n    },\n\n    isErrorEnabled: function() {\n      return this.isLogLevelEnabled(LogUtil.Level.Error);\n    },\n\n    isFatalEnabled: function() {\n      return this.isLogLevelEnabled(LogUtil.Level.Fatal);\n    },\n\n    isLogLevelEnabled: function(logLevel) {\n      var coercedLogLevel = b(logLevel);\n      return this._isCoercedLogLevelEnabledInTree(coercedLogLevel);\n    },\n\n    _isCoercedLogLevelEnabledInTree: function(coercedLogLevel) {\n      return ((this._logLevel & coercedLogLevel) === coercedLogLevel) ||\n        (this._parent.get() && this._parent.get()._isCoercedLogLevelEnabledInTree(coercedLogLevel));\n    },\n\n    addAppender: function(appender) {\n      this._appenders.push(appender);\n    },\n\n    setLogLevel: function(logLevel) {\n      // Save a copy for the potential error message\n      var originalLogLevel = logLevel;\n\n      // If name is specified, e.g., \"Info\", convert to\n      // int\n      if (_.isString(logLevel)) {\n        logLevel = LogUtil.Level[logLevel]\n      }\n\n      var exists = _.detect(LogUtil.Level, function(level, name) {\n        return level === logLevel;\n      });\n\n      if (!exists) {\n        throw new Error(\"Invalid logLevel: \" + originalLogLevel);\n      }\n\n      this._logLevel = logLevel;\n    },\n\n\n    _log: function(logLevel, logArgs) {\n      this._logWithMetadata([], logLevel, logArgs);\n    },\n\n    _isMuted: function(name) {\n      return !!this._muted[name];\n    },\n\n    _logWithMetadata: function(descendants, logLevel, args) {\n      var leaf = descendants[descendants.length - 1] || this._name;\n      if (this.isLogLevelEnabled(logLevel) && !this._isMuted(leaf)) {\n        _.each(this._appenders, function(appender) {\n          appender.log(this._name, descendants, logLevel, LogUtil._Label[logLevel], args);\n        }, this);\n      }\n\n      if (this._parent.get()) {\n        this._parent.get()._logWithMetadata([this._name].concat(descendants), logLevel, args);\n      }\n    }\n  });\n\n  var LogUtil = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  // Coerce (just use rightmost 8 bits)!; because JS is dumb, and everything is\n  // actually a float with 53-bit precision\n  var b = function(v) {\n    return 0xFF & v;\n  };\n\n  _.extend(LogUtil, {\n    Level: {\n      Trace: b(parseInt(\"111111\", 2)),\n      Debug: b(parseInt(\"011111\", 2)),\n      Info:  b(parseInt(\"001111\", 2)),\n      Warn:  b(parseInt(\"000111\", 2)),\n      Error: b(parseInt(\"000011\", 2)),\n      Fatal: b(parseInt(\"000001\", 2))\n    }\n  });\n\n  _.extend(LogUtil.prototype, {\n    Level: LogUtil.Level,\n    initialize: function() {\n      this._rootLogger = Ref(new Logger({\n        name: \"Root\"\n      }));\n    },\n\n    create: function(name, opts) {\n      opts = _.clone(opts || {});\n\n      var parent;\n      if (opts.parent) {\n        parent = Ref(opts.parent);\n        delete(opts.parent);\n      } else {\n        parent = Ref.delegating(this._rootLogger);\n      }\n\n      opts.refParent = parent;\n\n      opts.name = name;\n\n      return new Logger(opts);\n    },\n\n    root: function() {\n      return this._rootLogger.get();\n    },\n\n    resetRootLogger: function() {\n      this._rootLogger.set(new Logger({\n        name: \"Root\"\n      }));\n    }\n  });\n\n\n  LogUtil._Label = _.reduce(LogUtil.Level, function(memo, val, key) {\n    memo[val] = key;\n    return memo;\n  }, {});\n\n  return new LogUtil();\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../ref\"),\n  require(\"../options\")\n);\n\n},{\"../options\":63,\"../ref\":66,\"underscore\":174}],63:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar factory = function(\n  _\n) {\n\n  /**\n   *\n   * Helper for dealing with hash-style function arguments, which can be useful\n   * in methods with optional/default values.\n   *\n   * Usage:\n   *\n   *   var foo = function(opts) {\n   *       opts = Options.fromObject(opts);\n   *\n   *       var one = opts.getOrError(\"one\"),\n   *           two = opts.getOrElse(\"two\", 2),\n   *           three = opts.getOrElseFn(\"three\", function() {\n   *             return 3;\n   *           });\n   *\n   *     console.log(one, two, three);\n   *   };\n   *\n   *   foo({ one: 1 }); // logs \"1, 2, 3\"\n   *   foo(); // throws Error\n   *   foo({one: 1, two: false, three: 4}); // logs \"1, false, 4\"\n   *\n   */\n  var Options = function(opts) {\n    this.initialize.apply(this, arguments);\n  }\n\n  _.extend(Options.prototype, {\n    initialize: function(opts) {\n      this._providedOpts = opts || {};\n    },\n\n    /**\n     * Attempts to return the value for the requested `key`. If the value\n     * is undefined or null, instead returns the provided `fallbackValue`.\n     *\n     * @param key (required) attribute to be read\n     * @param fallbackValue  returned if `key` attribute is null or undefined\n     *\n     * @returns requested value for `key`, or fallbackValue`\n     */\n    getOrElse: function(key, defaultValue) {\n      if (this._isUndefOrNull(key)) {\n        return defaultValue;\n      } else {\n        return this._providedOpts[key];\n      }\n    },\n\n    /**\n     * Attempts to return the value for the requested `key`. If the value\n     * is undefined or null, throws an error.\n     *\n     * @param key (required) attribute to be read\n     * @param err            message provided to Error constructor if `key`\n     *                       is null or not defined\n     *\n     * @returns the value for the requested key\n     */\n    getOrError: function(key, errorMsg) {\n      if (this._isUndefOrNull(key)) {\n        errorMsg = errorMsg || \"Option requested but not found: `\"+key+\"`\";\n        throw new Error(errorMsg);\n      }\n\n      return this._providedOpts[key];\n    },\n\n    /**\n     * Attempts to return the value for the requested `key`. If the value\n     * is undefined or null, instead evaluates `fallbackValueFn` and returns\n     * its value.\n     *\n     * This is useful for simulating non-strict evaluation.\n     *\n     * @param key (required)  attribute to be read\n     * @param fallbackValueFn evaluated and return value returned if `key`\n     *                        attribute is null or undefined\n     *\n     * @returns requested value for `key` or the return value of evaluated\n     *          `fallbackValueFn`\n     */\n    getOrElseFn: function(key, defaultValueFn) {\n      if (typeof defaultValueFn !== \"function\") {\n        throw new Error(\"Options#getOrElseFn requires a defaultValueFn\");\n      }\n\n      if (this._isUndefOrNull(key)) {\n        return defaultValueFn();\n      } else {\n        return this._providedOpts[key];\n      }\n    },\n\n\n    toObject: function() {\n      return _.clone(this._providedOpts);\n    },\n\n    scope: function(prefix) {\n      return Options.fromObjectWithPrefix(this.toObject(), prefix);\n    },\n\n    _isUndefOrNull: function(key) {\n      return typeof this._providedOpts[key] === \"undefined\" || this._providedOpts[key] === null;\n    }\n  });\n\n  _.extend(Options, {\n    fromObject: function(opts) {\n      return new Options(opts);\n    },\n\n\n    fromObjectWithPrefix: function(opts, prefix) {\n      opts = _.reduce(opts, function(memo, val, key) {\n        var rest, newKey;\n        if (key.indexOf(prefix) === 0) {\n          rest = key.substr(prefix.length);\n          if (rest.length > 1) {\n            newKey = rest.charAt(0).toLowerCase() + rest.substr(1);\n            memo[newKey] = val;\n          }\n        }\n        return memo;\n      }, {});\n\n      return new Options(opts);\n    }\n  })\n\n  return Options;\n};\n\nmodule.exports = factory(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],64:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  /**\n   * A mixin enabling pubsub on an object. To use, copy the singleton methods into the object or object prototype:\n   *\n   *     var myObj = _.extend({}, PubSub);\n   *     myObj.on('foo', function(evt) { console.log(evt) }); // logs `{ 'some': 'data' }`\n   *     myObj.notify('foo', { some: 'data' });\n   *\n   */\n  var PubSub = {\n    on: function(eventName, handler, context) {\n      var bucket = this.__pubSubBucket(eventName);\n      bucket.subscribe(handler, context);\n    },\n    off: function(eventName, handler, context) {\n      var bucket = this.__pubSubBucket(eventName);\n      bucket.unsubscribe(handler, context);\n    },\n    notify: function() {\n      var args      = _.toArray(arguments),\n          eventName = args.shift();\n\n      var bucket = this.__pubSubBucket(eventName);\n      bucket.notify(args);\n    },\n    __pubSubBucket: function(eventName) {\n      this.__pubSubEvents = this.__pubSubEvents || {};\n      this.__pubSubEvents[eventName] = this.__pubSubEvents[eventName] || new EventBucket(eventName);\n      return this.__pubSubEvents[eventName];\n    }\n  };\n\n  var EventBucket = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(EventBucket.prototype, {\n    initialize: function(eventName) {\n      this._eventName = eventName;\n      this._subscriptions = [];\n    },\n    subscribe: function(handler, context) {\n      if (handler) {\n        this._subscriptions.push(new Subscription(handler, context));\n      } else {\n        throw new Error(\"Subscription requires handler: \" + this._eventName);\n      }\n    },\n    unsubscribe: function(handler, context) {\n      var subs;\n      if (handler) {\n        subs = _.filter(this._subscriptions, function(sub) {\n          return sub.matches(handler, context);\n        });\n      } else {\n        subs = this._subscriptions;\n      }\n\n      _.each(subs, function(sub) {\n        sub.dispose();\n      });\n\n      this._subscriptions = _.difference(this._subscriptions, subs);\n    },\n    notify: function(args) {\n      _.invoke(this._subscriptions, \"notify\", args);\n    }\n  });\n\n  var Subscription = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Subscription.prototype, {\n    initialize: function(handler, context) {\n      this._handler = handler;\n      this._context = context;\n    },\n    matches: function(handler, context) {\n      if (this._context) {\n        // Compare context refs as refs iff we have a context object\n        return (handler === this._handler && context === this._context);\n      } else {\n        // Otherwise, just make sure we don't have a context (null or undefined are fine)\n        return (handler === this._handler && !context);\n      }\n    },\n    notify: function(args) {\n      // We shouldn't be called after dispose, but\n      // just in case...\n      if (this._handler) {\n        this._handler.apply(this._context, args);\n      } else {\n        // Something went wrong here...\n      }\n    },\n    dispose: function() {\n      this._handler = null;\n      this._context = null;\n    }\n  })\n\n  return PubSub;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],65:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  /**\n   * A ref whose boxed value is another ref\n   */\n  var DelegatingRef = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(DelegatingRef.prototype, {\n    initialize: function(ref) {\n      this._delegateRef = ref;\n    },\n    get: function() {\n      return this._delegateRef.get();\n    }\n  });\n\n  return DelegatingRef;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],66:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Ref,\n  DelegatingRef\n) {\n\n  var helper = function(val) {\n    return new Ref(val);\n  };\n\n  helper.delegating = function(ref) {\n    return new DelegatingRef(ref);\n  };\n\n  return helper;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"./ref\"),\n  require(\"./delegating-ref\")\n);\n\n},{\"./delegating-ref\":65,\"./ref\":67,\"underscore\":174}],67:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  /**\n   * A basic Ref serves as a means of indirection between references and their\n   * values, allowing an outside agent to modify the underlying value.\n   */\n  var Ref = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Ref.prototype, {\n    initialize: function(val) {\n      this._val = val;\n    },\n\n    /**\n     * Return the value boxed by this Ref\n     *\n     * @returns {dynamic}\n     */\n    get: function() {\n      return this._val;\n    },\n\n    /**\n     * Set a new boxed value. Note this method is specific to this Ref\n     * implementation, and not the Ref protocol, which only defines\n     * `Ref#get()`.\n     *\n     * @param newVal {dynamic} the value to box\n     */\n    set: function(newVal) {\n      if (newVal instanceof Ref) {\n        this._val = newVal.get();\n      } else {\n        this._val = newVal;\n      }\n    }\n  });\n\n  return Ref;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],68:[function(require,module,exports){\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  var SetTimeoutScheduler = function() {\n    this.initialize.apply(this, arguments);\n  }\n\n  _.extend(SetTimeoutScheduler.prototype, {\n    initialize: function() {},\n\n    runSoon: function(fn) {\n      this.schedule(fn);\n    },\n\n    schedule: function(fn, delay) {\n      delay = delay || 1;\n      return setTimeout(fn, delay);\n    },\n\n    unschedule: function(id) {\n      return clearTimeout(id);\n    }\n  });\n\n  return SetTimeoutScheduler;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],69:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options\n) {\n\n  /**\n   * See `UnitSequencer` for a high-level explanation of Sequencer semantics.\n   *\n   * A Sequencer which advances by reading from a Clock.\n   * Note that this ClockSequencer relies on the Clock protocol, which\n   * only provides `Clock#getTime()`. It does not modify the clock itself.\n   * This means if you're using a LogicalClock, it's still up to the clock's\n   * owner to advance the clock for the sequencer to advance.\n   */\n  var ClockSequencer = function() {\n    this.initialize.apply(this, arguments);\n  }\n\n  _.extend(ClockSequencer.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._clock    = opts.getOrError(\"clock\");\n      this._sequence = opts.getOrElse(\"initialSequence\", 0);\n    },\n\n    /**\n     * Advances by setting its sequence to the backing clock's time.\n     * Note that if this method is called twice within the same time unit,\n     * the sequence will not actually advance, since unique time is not\n     * guaranteed by our clocks.\n     *\n     * @async\n     * @returns {Promise<>}\n     */\n    advance: Promise.method(function() {\n      return Promise\n        .bind(this)\n        .then(function() {\n          return this._clock.getTime();\n        })\n        .then(function(t) {\n          this._sequence = t;\n        });\n    }),\n\n    /**\n     * Returns the current sequence. This value should always be the same\n     * or greater than a value returned previously (in time).\n     *\n     * @returns {number} the current sequence\n     */\n    value: function() {\n      return this._sequence;\n    }\n  });\n\n  return ClockSequencer;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../options\")\n);\n\n},{\"../options\":63,\"bluebird\":107,\"underscore\":174}],70:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options\n) {\n\n  /**\n   * See `UnitSequencer` for a high-level explanation of Sequencer semantics.\n   *\n   * A UnitSequencer which reports its sequence summed with the sequences\n   * of its internal collection of sequencers.\n   *\n   * This device is useful for tracking the state of data comprised from multiple\n   * sources. For instance, you might have CachingDataStore(A) storing data\n   * from Source(A), tracked by Sequencer(A), and CachingDataStore(B) storing\n   * data from Source(B), tracked by Sequencer(B). Meanwhile, you may have\n   * CachingDataStore(C), storing data from Source(A + B), and tracked by\n   * Sequencer(C) = Sequencer(A + B) - a DelegatingCompositeSequencer.\n   *\n   * Thus, if Sequencer(A) is advanced, it may invalidate CachingDataStore(A) or\n   * CachingDataStore(C) or both.\n   *\n   * Note this particular usage is generally only useful for Unit sequencers.\n   *\n   * If you'd like the above functionality, but with Sequencer(A) and\n   * Sequencer(B) as ClockSequencers, and Sequencer(C) merely tracking\n   * modification, you'd need to use a DelegatingForwardingSequencer for A and B,\n   * forwarding them to UnitSequencer(C).\n   *\n   * DelegatingCompositeSequencer and DelegatingForwardingSequencer are effectivly\n   * opposites of each other. DelegatingCompositeSequencer composes the `value`\n   * of multiple underlying sequencers (pull), and DelegatingForwardingSequencer\n   * forwards the `advance` call to multiple targets (push).\n   */\n  var DelegatingCompositeSequencer = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(DelegatingCompositeSequencer.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._delegateSequencer = opts.getOrError(\"delegate\");\n      this._sequencers = _.clone(opts.getOrElse(\"sequencers\", []));\n    },\n    addSequencer: function(seq) {\n      this._sequencers.push(seq);\n    },\n    advance: function() {\n      var s = this._delegateSequencer;\n      return s.advance.apply(s, arguments);\n    },\n    value: function() {\n      return _\n        .chain(this._sequencers)\n        .invoke(\"value\")\n        .reduce(function(sum, n) {\n          return sum + n;\n        }, 0)\n        .value() + this._delegateSequencer.value();\n    }\n  });\n\n  return DelegatingCompositeSequencer;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../options\")\n);\n\n},{\"../options\":63,\"bluebird\":107,\"underscore\":174}],71:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options\n) {\n\n  /**\n   * See `UnitSequencer` for a high-level explanation of Sequencer semantics.\n   *\n   * A Sequencer which delegates to another sequencer for both `advance` and `value`, and also forwards `advance` to\n   * other `target` sequencers. It is the logical complement of a `DelegatingCompositeSequencer`, which derives its `value` from\n   * its underlying `sequencers`.\n   *\n   *\n   */\n  var DelegatingForwardingSequencer = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(DelegatingForwardingSequencer.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._delegateSequencer = opts.getOrError(\"delegate\");\n      this._forwardTargets = _.clone(opts.getOrElse(\"targets\", []));\n    },\n    addTarget: function(seq) {\n      this._forwardTargets.push(seq);\n    },\n    advance: Promise.method(function() {\n      var s = this._delegateSequencer;\n      return s.advance.apply(s, arguments)\n      .bind(this)\n      .then(function(val) {\n        return Promise\n          .all(_.invoke(this._forwardTargets, \"advance\"))\n          .then(function() {\n            // Return the value returned by the delegate sequencer's\n            // advance call (if any). The advancement of the forward\n            // targets should be transparent.\n            return val;\n          });\n      });\n    }),\n    value: function() {\n      var s = this._delegateSequencer;\n      return s.value.apply(s, arguments);\n    }\n  });\n\n  return DelegatingForwardingSequencer;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../options\")\n);\n\n},{\"../options\":63,\"bluebird\":107,\"underscore\":174}],72:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options\n) {\n\n  /**\n   * A `Sequencer` advances its underlying sequence on `advance()`, and provides that value on `value()`. The only\n   * guarantee a sequencer provides is that `value()` is always non-decreasing over time (i.e., after multiple calls\n   * to `advance()`, a sequencer will never be smaller than the previous call - but it may also not be bigger).\n   *\n   */\n  var UnitSequencer = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(UnitSequencer.prototype, {\n    initialize: function(opts) {\n      opts           = Options.fromObject(opts);\n      this._sequence = opts.getOrElse(\"initialSequence\", 0);\n    },\n\n    /**\n     * Advances its sequence by `by`, or by `1` if `by` is not provided.\n     *\n     * @param by {number} the amount to advance by. Defaults to `1`.\n     * @async\n     * @returns {Promise<undefined>}\n     */\n    advance: Promise.method(function(by) {\n      // Wahh wahh - don't use `by || 1`, or you can't advance by 0, which is silly\n      // but potentially necessary.\n      by             = _.isUndefined(by) ? 1 : by;\n\n      if (by < 0) {\n        throw new Error(\"UnitSequencer#advance() requires positive `by` offset\");\n      }\n\n      this._sequence = this._sequence + by;\n    }),\n\n    /**\n     * Returns the current sequence. This value should always be the same\n     * or greater than a value returned previously (in time).\n     *\n     * @returns {number} the current sequence\n     */\n    value: function() {\n      return this._sequence;\n    }\n  });\n\n  return UnitSequencer;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../options\")\n);\n\n},{\"../options\":63,\"bluebird\":107,\"underscore\":174}],73:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  /**\n   * A 'serde' is a thing that can \"ser\"-ialize and \"de\"-erialize an object. This one just does JSON, and ignores\n   * any additional options.\n   *\n   *\n   */\n  var JSONSerde = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(JSONSerde.prototype, {\n    initialize: function() {},\n\n    serialize: function(payload, opts) {\n      return JSON.stringify(payload);\n    },\n\n    deserialize: function(payload, opts) {\n      return JSON.parse(payload);\n    }\n  });\n\n  return JSONSerde;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],74:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise\n) {\n\n  /**\n   * A StateGuard does what its name implies. Valid states are provided during instantiation, and are applied, ensured,\n   * denied, etc, through the course of the owner's lifetime.\n   *\n   * For example, if you'd like to ensure that Foo#bar raises an error after Foo#dispose is called, you might do the\n   * following:\n   *\n   *   var Foo = function() {\n   *     this.initialize.apply(this, arguments);\n   *   };\n   *\n   *   _.extend(Foo.prototype, {\n   *     initialize: function() {\n   *       this._expensiveResource = new ExpensiveResource();\n   *       this._stateGuard = new StateGuard([\"disposed\"]);\n   *     },\n   *     dispose: function() {\n   *       // #dispose should be idempotent, so here we just check to see if we've already disposed, and return.\n   *       // Note that if dispose were async, we'd need to add a \"disposing\" state.\n   *       if (this._stateGuard.applied(\"disposed\")) {\n   *         return;\n   *       }\n   *\n   *       if (this._expensiveResource) {\n   *         this._expensiveResource.dispose();\n   *         this._expensiveResource = null;\n   *       }\n   *       this._stateGuard.apply(\"disposed\");\n   *     },\n   *     bar: function() {\n   *       this._stateGuard.deny(\"disposed\"); // Throws exception if #dispose was called\n   *\n   *       return this._expensiveResource.someMethod();\n   *     }\n   *   });\n   *\n   * In this case, where we have only one state, it's useful to simply create a scoped StateGuard, which behaves\n   * identically to a regular one, except every enforcement/query method has the scope provided during instantiation\n   * as a first, implicit argument:\n   *\n   *   // Identical to previous version.\n   *\n   *   var Foo = function() {\n   *     this.initialize.apply(this, arguments);\n   *   };\n   *\n   *   _.extend(Foo.prototype, {\n   *     initialize: function() {\n   *       this._expensiveResource = new ExpensiveResource();\n   *       this._stateGuard = StateGuard.scoped(\"disposed\");\n   *     },\n   *     dispose: function() {\n   *       // #dispose should be idempotent, so here we just check to see if we've already disposed, and return.\n   *       // Note that if dispose were async, we'd need to add a \"disposing\" state.\n   *       if (this._stateGuard.applied()) {\n   *         return;\n   *       }\n   *\n   *       if (this._expensiveResource) {\n   *         this._expensiveResource.dispose();\n   *         this._expensiveResource = null;\n   *       }\n   *       this._stateGuard.apply();\n   *     },\n   *     bar: function() {\n   *       this._stateGuard.deny(); // Throws exception if #dispose was called\n   *\n   *       return this._expensiveResource.someMethod();\n   *     }\n   *   });\n   *\n   */\n  var StateGuard = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(StateGuard.prototype, {\n    initialize: function(states) {\n      this._validStates = _.reduce(states, function(memo, state) {\n        memo[state] = true;\n        return memo;\n      }, {});\n\n      this._appliedStates = {};\n    },\n\n    scope: function(state) {\n      var skip = [\"scope\", \"initialize\"],\n          self = this,\n          scoped = {};\n\n      _.each(StateGuard.prototype, function(fun, methodName) {\n        if (_.contains(skip, methodName)) {\n          return;\n        }\n\n        scoped[methodName] = function() {\n          var args = _.toArray(arguments);\n          args.unshift(state);\n          return fun.apply(self, args);\n        };\n      });\n\n      return scoped;\n    },\n\n    apply: function() {\n      var states = aryOrVariadicToArray(arguments);\n      checkValidStatesOrThrow(this._validStates, states);\n\n      _.each(states, function(state) {\n        this._appliedStates[state] = true;\n      }, this);\n\n      return this;\n    },\n\n    applyAsync: Promise.method(function() {\n      return this.apply.apply(this, arguments);\n    }),\n\n    applyAsyncFn: function() {\n      var args = arguments;\n      return _.bind(function() {\n        return this.applyAsync.apply(this, args);\n      }, this);\n    },\n\n    unapply: function() {\n      var states = aryOrVariadicToArray(arguments);\n      checkValidStatesOrThrow(this._validStates, states);\n\n      _.each(states, function(state) {\n        if (this._appliedStates[state]) {\n          delete this._appliedStates[state];\n        }\n      }, this);\n\n      return this;\n    },\n\n    unapplyAsync: Promise.method(function() {\n      return this.unapply.apply(this, arguments);\n    }),\n\n    unapplyAsyncFn: function(states) {\n      var args = arguments;\n      return _.bind(function() {\n        return this.unapplyAsync.apply(this, args)\n      }, this);\n    },\n\n    deny: function() {\n      var states = aryOrVariadicToArray(arguments);\n      checkValidStatesOrThrow(this._validStates, states);\n\n      var applied = _.filter(states, function(state) {\n        return this._appliedStates[state];\n      }, this);\n\n      if (applied.length > 0) {\n        throw new Error(\"State denial requested, but applied: \" + pretty(applied));\n      }\n\n      return this;\n    },\n\n    denyAsync: Promise.method(function() {\n      return this.deny.apply(this, arguments);\n    }),\n\n    denyAsyncFn: function() {\n      var args = arguments;\n      return _.bind(function() {\n        return this.denyAsync.apply(this, args)\n      }, this);\n    },\n\n    ensure: function() {\n      var states = aryOrVariadicToArray(arguments);\n      checkValidStatesOrThrow(this._validStates, states);\n      var missing = _.reject(states, function(state) {\n        return this._appliedStates[state];\n      }, this);\n\n      if (missing.length > 0) {\n        throw new Error(\"State ensurance requested, but not applied: \" + pretty(missing));\n      }\n      return this;\n    },\n\n    ensureAsync: Promise.method(function() {\n      return this.ensure.apply(this, arguments);\n    }),\n\n    ensureAsyncFn: function() {\n      var args = arguments;\n      return _.bind(function() {\n        return this.ensureAsync.apply(this, args);\n      }, this);\n    },\n\n    applied: function() {\n      var states = aryOrVariadicToArray(arguments);\n      checkValidStatesOrThrow(this._validStates, states);\n\n      return _.every(states, function(state) {\n        return this._appliedStates[state];\n      }, this);\n    },\n\n    appliedAsync: Promise.method(function() {\n      return this.applied.apply(this, arguments);\n    }),\n\n    appliedAsyncFn: function() {\n      var args = arguments;\n      return _.bind(function() {\n        return this.appliedAsync.apply(this, args)\n      }, this);\n    }\n  });\n\n  var aryOrVariadicToArray = function(args) {\n    return _.chain(args).toArray().flatten().value();\n  };\n\n  var checkValidStatesOrThrow = function(validStatesMap, states) {\n    var invalidStates = _.reject(states, function(state) {\n      return !!validStatesMap[state];\n    });\n\n    if (invalidStates.length > 0) {\n      throw new Error(\"Invalid states provided: \" + pretty(invalidStates));\n    }\n  };\n\n  var pretty = function(states) {\n    return \"[\"+states.join(\",\")+\"]\";\n  };\n\n  _.extend(StateGuard, {\n    scoped: function(scope) {\n      return (new StateGuard([scope])).scope(scope);\n    }\n  })\n\n  return StateGuard;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\")\n);\n\n},{\"bluebird\":107,\"underscore\":174}],75:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\n/**\n * Utility for generating V4 UUIDs. Exports a singleton.\n */\n\nvar mod = function(\n  _\n) {\n\n  var UUID = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(UUID.prototype, {\n    initialize: function() {},\n    // See: http://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29\n    v4: function() {\n      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16 | 0;\n        // 0x3       = 0b00011\n        // 0x8       = 0b01000\n        // 0x3 | 0x8 = 0b01011\n        // r & 0x3   = (0b00000 | 0b00001 | 0b00010 | 0b00011)\n        var v = (c == 'x' ? r : (r & 0x3 | 0x8));\n        return v.toString(16);\n      });\n    }\n  });\n\n  return new UUID();\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],76:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  ComponentRegistry,\n  webAliases,\n  nodeAliases\n) {\n  var c = new ComponentRegistry();\n\n\n  c.registerMany([\n    {\n      module: require(\"./util/component-loader\"),\n      as: \"component-loader\"\n    },\n\n    {\n      module: require(\"./util/periodic\"),\n      as: \"periodic\"\n    },\n\n    {\n      module: require(\"./util/retryable\"),\n      as: \"retryable\"\n    },\n\n    {\n      module: require(\"./util/timer\"),\n      as: \"timer\"\n    },\n\n    {\n      module: require(\"./core/dispatcher\"),\n      as: \"dispatcher\"\n    },\n\n    {\n      module: require(\"./core/countdown-latch\"),\n      as: \"countdown-latch\"\n    },\n\n    {\n      module: require(\"./core/options\"),\n      as: \"options\"\n    },\n\n    {\n      module: require(\"./core/lang\"),\n      as: \"lang\"\n    },\n\n    {\n      module: require(\"./core/ref\"),\n      as: \"ref\"\n    },\n\n    {\n      module: require(\"./core/state-guard\"),\n      as: \"state-guard\"\n    },\n\n\n    {\n      module: require(\"./core/pub-sub\"),\n      as: \"pub-sub\"\n    },\n\n    {\n      module: require(\"./core/sequencer/unit-sequencer\"),\n      as: [\"unit-sequencer\", \"sequencer\"]\n    },\n\n\n    {\n      module: require(\"./core/sequencer/clock-sequencer\"),\n      as: \"clock-sequencer\"\n    },\n\n    {\n      module: require(\"./core/sequencer/delegating-composite-sequencer\"),\n      as: \"delegating-composite-sequencer\"\n    },\n\n    {\n      module: require(\"./core/sequencer/delegating-forwarding-sequencer\"),\n      as: \"delegating-forwarding-sequencer\"\n    },\n\n    {\n      module: require(\"./collection/doubly-linked-list\"),\n      as: \"doubly-linked-list\"\n    },\n\n    {\n      module: require(\"./collection/object-hash-map\"),\n      as: [\"hash-map\", \"object-hash-map\"]\n    },\n\n    {\n      module: require(\"./collection/defaulting-hash-map\"),\n      as: \"defaulting-hash-map\"\n    },\n\n    {\n      module: require(\"./collection/multi-map\"),\n      as: \"multi-map\"\n    },\n\n    {\n      module: require(\"./collection/lru-hash-map\"),\n      as: \"lru-hash-map\"\n    },\n\n    {\n      module: require(\"./storage/caching-data-store\"),\n      as: \"caching-data-store\"\n    },\n\n    {\n      module: require(\"./storage/in-memory-data-store\"),\n      as: \"in-memory-data-store\"\n    },\n\n    {\n      module: require(\"./storage/lru-data-store\"),\n      as: \"lru-data-store\"\n    },\n\n    {\n      module: require(\"./storage/signaling-data-store\"),\n      as: \"signaling-data-store\"\n    },\n\n    {\n      module: require(\"./time/clock/logical-clock\"),\n      as: \"logical-clock\"\n    },\n\n    {\n      module: require(\"./time/clock/system-clock\"),\n      as: \"system-clock\"\n    },\n\n    {\n      module: require(\"./appkit/configuration-magic\"),\n      as: \"configuration-magic\"\n    },\n\n    {\n      module: require(\"./appkit/config/scoped-configuration-resolver\"),\n      as: \"scoped-configuration-resolver\"\n    },\n\n    {\n      module: require(\"./appkit/config/scoped-configuration\"),\n      as: [\"scoped-configuration\", \"config/scoped-configuration\"]\n    },\n\n    {\n      module: require(\"./appkit/app\"),\n      as: \"app\"\n    },\n\n    {\n      module: require(\"./runtime\"),\n      as: \"runtime\"\n    },\n\n    {\n      module: require(\"./core/logging/logger\"),\n      as: \"logger\"\n    },\n\n    {\n      module: require(\"./core/logging/appenders/console-log-appender\"),\n      as: [\"appenders/console-log\", \"console-log-appender\"]\n    },\n\n    {\n      module: require(\"./core/channel/channel\"),\n      as: \"channel\"\n    },\n\n    {\n      module: require(\"./core/channel/chained-channel\"),\n      as: \"chained-channel\"\n    },\n\n    {\n      module: require(\"./core/channel/composite-channel\"),\n      as: \"composite-channel\"\n    },\n\n    {\n      module: require(\"./messaging/exchange\"),\n      as: \"messaging/exchange\"\n    },\n\n    {\n      module: require(\"./messaging/courier\"),\n      as: \"messaging/courier\"\n    },\n\n    {\n      module: require(\"./messaging/fiber/in-memory-fiber\"),\n      as: \"messaging/fibers/in-memory\"\n    },\n\n    {\n      module: require(\"./messaging/fiber/linkable-fiber\"),\n      as: \"messaging/fibers/linkable\"\n    },\n\n    {\n      module: require(\"./core/uuid\"),\n      as: \"uuid\"\n    },\n\n    {\n      module: require(\"./core/serde/json-serde\"),\n      as: [\"serde/json\", \"json-serde\"]\n    },\n\n    {\n      module: require(\"./platform/client-builder/client-builder\"),\n      as: \"experimental/platform/client-builder\"\n    },\n\n    {\n      module: require(\"./platform/client-builder/client-spec\"),\n      as: \"experimental/platform/client-spec\"\n    }\n  ]);\n\n  c.selfRegister({\n    as: \"component-registry\"\n  });\n\n  webAliases(c);\n  nodeAliases(c);\n\n  return c;\n};\n\nvar g = (typeof window === \"undefined\" ? {} : window);\ng.thicket = module.exports = mod(\n  require(\"./util/component-registry\"),\n  require(\"./web\"),\n  require(\"./node\")\n);\n\n\n},{\"./appkit/app\":43,\"./appkit/config/scoped-configuration\":46,\"./appkit/config/scoped-configuration-resolver\":45,\"./appkit/configuration-magic\":47,\"./collection/defaulting-hash-map\":50,\"./collection/doubly-linked-list\":51,\"./collection/lru-hash-map\":52,\"./collection/multi-map\":53,\"./collection/object-hash-map\":54,\"./core/channel/chained-channel\":55,\"./core/channel/channel\":56,\"./core/channel/composite-channel\":57,\"./core/countdown-latch\":58,\"./core/dispatcher\":59,\"./core/lang\":60,\"./core/logging/appenders/console-log-appender\":61,\"./core/logging/logger\":62,\"./core/options\":63,\"./core/pub-sub\":64,\"./core/ref\":66,\"./core/sequencer/clock-sequencer\":69,\"./core/sequencer/delegating-composite-sequencer\":70,\"./core/sequencer/delegating-forwarding-sequencer\":71,\"./core/sequencer/unit-sequencer\":72,\"./core/serde/json-serde\":73,\"./core/state-guard\":74,\"./core/uuid\":75,\"./messaging/courier\":77,\"./messaging/exchange\":78,\"./messaging/fiber/in-memory-fiber\":79,\"./messaging/fiber/linkable-fiber\":80,\"./node\":84,\"./platform/client-builder/client-builder\":86,\"./platform/client-builder/client-spec\":87,\"./runtime\":90,\"./storage/caching-data-store\":92,\"./storage/in-memory-data-store\":93,\"./storage/lru-data-store\":95,\"./storage/signaling-data-store\":96,\"./time/clock/logical-clock\":97,\"./time/clock/system-clock\":98,\"./util/component-loader\":99,\"./util/component-registry\":100,\"./util/periodic\":101,\"./util/retryable\":102,\"./util/timer\":103,\"./web\":104}],77:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  M,\n  Options,\n  UUID,\n  StateGuard,\n  Logger,\n  Dispatcher\n) {\n\n  /**\n   * A Courier makes it easy for a maibox owner to deal with sending and receiving messages. It has a slightly more\n   * natural interface for sending messages (`send(to, msg)`, `sendAndReceive(to, msg, opts)`), and automatically\n   * dispatches incoming messages to delegate methods.\n   *\n   * Common usage is for a mailbox owner (let's call it \"owner A\") to create a new Courier (\"courier A\"), setting the\n   * `delegate` to itself, and the `mailbox` to the mailbox (\"mailbox A\") it owns. When a remote mailbox's\n   * (\"mailbox B\") courier (\"courier B\") performs a `courier.send(\"A\", { mT: \"foo\" })`, it will be automatically\n   * dispatched to \"owner A\"'s `onMsgFoo` method, if present.\n   *\n   * If \"courier B\" performs a `courier.sendAndReceive(\"A\", { mT: \"bar\" })`, it will get set to \"owner A\"'s\n   * `onReqBar` method, and the resulting promise's fulfilled value will be dispatched back to \"courier B\" as the\n   * fulfilled result of the originating `sendAndReceive`.\n   *\n   * A `send` or `sendAndReceive` call initiated on CourierB will result in a method call on DelegateA, and vice versa.\n   *\n   *  DelegateA <-> CourierA <-> MailboxA <-> ExchangeA\n   *                                            ^\n   *                                             \\\n   *                                              v\n   *                                           Fiber\n   *                                            ^\n   *                                             \\\n   *                                              v\n   *                                           ExchangeB <-> MailboxB <-> CourierB <-> DelegateB\n   *\n   *\n   *\n   */\n  var Courier = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  var MSG_REPLY = Courier.MSG_REPLY = \"cReply\";\n\n  var Log = Logger.create(\"Courier\");\n\n  _.extend(Courier.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._id         = UUID.v4();\n      this._delegate   = opts.getOrError(\"delegate\");\n      this._mailbox    = opts.getOrError(\"mailbox\");\n      this._stateGuard = new StateGuard([\"disposed\"]);\n\n      _.bindAll(this, \"_onOneShotMessage\", \"_onRequestReplyMessage\", \"_defaultContextDelegate\");\n\n      this._contextDelegate = opts.getOrElse(\"contextDelegate\", this._defaultContextDelegate);\n\n      this._oneShotDispatcher = new Dispatcher({\n        delegate: this._delegate,\n        prefix: opts.getOrElse(\"oneShotPrefix\", \"onMsg\"),\n        contextDelegate: this._contextDelegate\n      });\n\n      this._requestReplyDispatcher = new Dispatcher({\n        delegate: this._delegate,\n        prefix: opts.getOrElse(\"requestReplyPrefix\", \"onReq\"),\n        contextDelegate: this._contextDelegate\n      });\n\n      this._subs = M.vector(\n        this._mailbox.oneShotChannel().subscribe(this._onOneShotMessage),\n        this._mailbox.requestReplyChannel().subscribe(this._onRequestReplyMessage)\n      );\n    },\n\n\n    id: function() {\n      return this._id;\n    },\n\n    send: Promise.method(function(to, msg) {\n      this._stateGuard.deny(\"disposed\");\n\n      return this._mailbox.send({\n        to: to,\n        body: msg\n      });\n    }),\n\n    sendAndReceive: Promise.method(function(to, msg, opts) {\n      this._stateGuard.deny(\"disposed\");\n\n      return this._mailbox\n        .sendAndReceive({\n          to: to,\n          body: msg\n        }, opts)\n        .then(function(res) {\n\n          if (res.body && res.body.mT === MSG_REPLY && res.body.body) {\n            // Unwrap the remote message\n            if (res.body.body.err) {\n              throw new Error(res.body.body.err);\n            }\n            return res.body.body.res;\n          } else {\n            // Someone is misbehaving\n            Log.warn(\"Received sendAndReceive reply, but it isn't Courier-compatible\", this._mailbox.ownerIdentity(), res);\n            return res;\n          }\n        })\n    }),\n\n    dispose: function() {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n\n      M.each(this._subs, function(sub) {\n        sub.dispose();\n      });\n\n      this._subs     = null;\n      this._mailbox  = null;\n      this._delegate = null;\n\n      this._stateGuard.apply(\"disposed\");\n    },\n\n    _defaultContextDelegate: function(mTyped) {\n      return {\n        mailbox: this._mailbox\n      };\n    },\n\n    _onOneShotMessage: function(msg) {\n      this._oneShotDispatcher.dispatch(msg.body, msg);\n    },\n\n\n    _onRequestReplyMessage: function(msg) {\n      this._requestReplyDispatcher\n        .dispatchAsync(msg.body, msg)\n        .bind({\n          mbox: this._mailbox,\n          err: null,\n          result: null\n        })\n        .then(function(result){\n          this.result = result;\n        })\n        .caught(function(err) {\n          this.err = err.message;\n        })\n        .lastly(function() {\n          this.mbox.reply(msg.msgId, {\n            to: msg.from,\n            body: {\n              mT: MSG_REPLY,\n              body: {\n                err: this.err,\n                res: this.result\n              }\n            }\n          });\n        });\n    }\n  });\n\n  return Courier;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"mori\"),\n  require(\"../core/options\"),\n  require(\"../core/uuid\"),\n  require(\"../core/state-guard\"),\n  require(\"../core/logging/logger\"),\n  require(\"../core/dispatcher\")\n);\n\n},{\"../core/dispatcher\":59,\"../core/logging/logger\":62,\"../core/options\":63,\"../core/state-guard\":74,\"../core/uuid\":75,\"bluebird\":107,\"mori\":171,\"underscore\":174}],78:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  M,\n  Logger,\n  Options,\n  UUID,\n  DelegatingForwardingSequencer,\n  UnitSequencer,\n  InMemoryFiber,\n  Mailbox,\n  Dispatcher,\n  SignalingDataStore,\n  Periodic,\n  ClockSequencer,\n  SystemClock,\n  Runtime\n  ) {\n\n  /**\n   * An `Exchange` vends mailboxes. Messages sent from a mailbox are managed by the Exchange which vended the mailbox.\n   * The Exchange handles the work of:\n   *\n   *   1. Wrapping the message in the appropriate message envelope for the verb used (`send`, `sendAndReceive`,\n   *      `reply`)\n   *   2. Pairing a given `reply` with the originating `sendAndReceive` call, and fulfilling the associated result\n   *      promise.\n   *   3. Handling message timeouts for `sendAndReceive` calls. When a message times out, the promise associated with\n   *      the result is canceled.\n   *\n   * The actual work of sending messages is handled by an Exchange's underlying `Fiber`. The default fiber is\n   * an `InMemoryFiber`, which performs only local dispatch.\n   *\n   * Generally speaking, mailboxes sharing an underlying fiber (either by both being spawned from the same mailbox,\n   * or being spawned by exchanges sharing the same fiber) can send messages to each other, provided they know\n   * each other's addresses.\n   *\n   */\n  var Exchange = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  var MSG_SEND             = Exchange.MSG_SEND             = \"send\",\n      MSG_SEND_AND_RECEIVE = Exchange.MSG_SEND_AND_RECEIVE = \"sendAndReceive\",\n      MSG_REPLY            = Exchange.MSG_REPLY            = \"reply\";\n\n  // 7.5 seconds is reasonable, yes?\n  var DEFAULT_REPLY_TIMEOUT = 7500;\n\n  var Log = Logger.create(\"Exchange\");\n\n\n  _.extend(Exchange.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._identity = opts.getOrElse(\"identity\", UUID.v4());\n\n      this._runtime = opts.getOrElseFn(\"runtime\", function() {\n        return new Runtime();\n      });\n\n      this._mailboxFiberDelegate = {\n        receiveFiberMessage: this._receiveMailboxFiberMessage.bind(this)\n      };\n\n      this._mailboxes = M.hash_map();\n\n      this._fiber     = opts.getOrElseFn(\"fiber\", function() {\n        return new InMemoryFiber();\n      });\n\n      this._fiber.registerEntity({\n        identity: this._identity,\n        delegate: this\n      });\n\n      this._mailboxDispatcher = new Dispatcher({\n        delegate: this,\n        prefix: \"_onMbx\"\n      });\n\n      var usedDefaultClock = false;\n\n      // For requester-provided requestId to messageId mapping.\n      // Used for cancelling outstanding sendAndReceive requests.\n      this._reqToMsg = M.hash_map();\n\n      // Data store for pending requests\n      this._outstandingRequests = new SignalingDataStore({\n        ttl: opts.getOrElse(\"replyTimeout\", DEFAULT_REPLY_TIMEOUT),\n        sequencer: new ClockSequencer({\n          clock: opts.getOrElseFn(\"clock\", function() {\n            usedDefaultClock = true;\n            return new SystemClock();\n          }),\n          // Hax - Since we want time to be async, but provide a default system clock\n          // we need to get the initial clock sequence sync, by bypassing the clock call.\n          // If you provide an async clock, you should either provide an initial time, or\n          // ensure that the first getTime has resolved before instantiating the exchange.\n          // OR, in the future, we have to add a start()/stop() to Exchange.\n          initialSequence: opts.getOrElse(\"initialSequence\", (usedDefaultClock ? +new Date() : undefined))\n        })\n      });\n\n      // Dispatches store signals (e.g., expiry)\n      this._expiryDispatcher = new Dispatcher({\n        delegate: this,\n        prefix: \"_onStoreSignal\",\n        listen: this._outstandingRequests.signalChannel()\n      });\n\n      this._compositeSeq = new DelegatingForwardingSequencer({\n        delegate: new UnitSequencer(),\n        targets: [this._outstandingRequests.sequencer(), this._outstandingRequests.sentrySequencer()]\n      })\n\n      // This guy triggers periodic expiry checks in the store\n      this._checkExpiry = new Periodic({\n        scheduler: this._runtime.scheduler(),\n        task: _.bind(function() {\n          return this._compositeSeq.advance();\n        }, this),\n        interval: opts.getOrElse(\"expiryInterval\", 1000)\n      });\n\n      this._checkExpiry.start();\n    },\n\n\n    dispose: function() {\n      // TODO: Cancel outstanding requests\n\n      this._expiryDispatcher.dispose();\n\n      this._outstandingRequests.clear();\n\n      // TODO: Dispose all the things\n      this._checkExpiry.dispose();\n    },\n\n\n    /**\n     * Builds a Mailbox for the provided `requesterIdentity`. The\n     * `RequesterIdentity` must never have been used for requesting\n     * a mailbox previously.\n     *\n     * We attempt to validate unique mailbox names, but because mailbox names\n     * are global and there is no checking between fibers, it's only a best-effort.\n     *\n     * @param requesterIdentity\n     * @returns {Mailbox}\n     */\n    mailbox: function(requesterIdentity) {\n      this._assertUniqueOwner(requesterIdentity);\n\n      var mailbox = new Mailbox({\n        exchange:      this,\n        ownerIdentity: requesterIdentity\n      });\n\n      this._mailboxes = M.assoc(this._mailboxes, requesterIdentity, mailbox);\n\n      this._fiber.registerEntity({\n        identity: requesterIdentity,\n        delegate: this._mailboxFiberDelegate\n      });\n\n      return mailbox;\n    },\n\n\n    send: function(env) {\n      env = Options.fromObject(env);\n\n      return this._fiber.send({\n        from:  env.getOrError(\"from\"),\n        to:    env.getOrError(\"to\"),\n        body:  env.getOrError(\"body\"),\n        mT:    MSG_SEND,\n        msgId: UUID.v4()\n      });\n    },\n\n\n    reply: function(env) {\n      env = Options.fromObject(env);\n      return this._fiber.send({\n        from:   env.getOrError(\"from\"),\n        to:     env.getOrError(\"to\"),\n        body:   env.getOrError(\"body\"),\n        mT:     MSG_REPLY,\n        msgId:  UUID.v4(),\n        rMsgId: env.getOrError(\"rMsgId\")\n      });\n    },\n\n\n    sendAndReceive: function(env, opts) {\n      env  = Options.fromObject(env);\n      opts = Options.fromObject(opts);\n\n      var msgId = UUID.v4(),\n          reqId    = opts.getOrError(\"reqId\"),\n          deferred = defer(),\n          fibEnv   = {\n            from:  env.getOrError(\"from\"),\n            to:    env.getOrError(\"to\"),\n            body:  env.getOrError(\"body\"),\n            mT:    MSG_SEND_AND_RECEIVE,\n            msgId: msgId\n          },\n          req      = {\n            reqId:    reqId,\n            deferred: deferred,\n            fibEnv:   fibEnv\n          };\n\n      this._reqToMsg = M.assoc(this._reqToMsg, reqId, msgId);\n\n      return this\n        ._outstandingRequests\n        .put(msgId, req, {ttl: opts.getOrElse(\"replyTimeout\")})\n        .bind(this)\n        .then(function() {\n          return this._fiber.send(fibEnv);\n        })\n        .then(function() {\n          return req.deferred.promise;\n        });\n    },\n\n    cancelSendAndReceive: Promise.method(function(reqId) {\n      var msgId = M.get(this._reqToMsg, reqId);\n\n      if (msgId) {\n        Log.debug(\"Canceling request\", reqId, \"with msgId\", msgId);\n        this._reqToMsg = M.dissoc(this._reqToMsg, reqId);\n\n        return Promise\n          .bind(this)\n          .then(function() {\n            return this._outstandingRequests.remove(msgId);\n          })\n          .then(function(req) {\n            if (req) {\n              req.deferred.reject(new Promise.CancellationError());\n            }\n          })\n      } else {\n        Log.warn(\"Tried to cancel request, but no oustanding request with that ID found;\", reqId);\n      }\n    }),\n\n\n    _assertUniqueOwner: function(identity) {\n      if (M.get(this._mailboxes, identity)) {\n        throw new Error(\"Mailbox registration requires a unique identity\");\n      }\n    },\n\n\n    /**\n     * Fiber delegate protocol method for a message bound for a Mailbox owned by\n     * this exchange.\n     *\n     * @param env\n     * @private\n     */\n    _receiveMailboxFiberMessage: function(env) {\n      this._mailboxDispatcher.dispatch(env);\n    },\n\n\n    _onMbxSend: function(env) {\n      var oEnv     = Options.fromObject(env),\n          identity = oEnv.getOrElse(\"to\"),\n          body     = oEnv.getOrElse(\"body\");\n\n      if (!(identity || body)) {\n        Log.info(\"Exchange received a message with missing envelope information\", env);\n        return;\n      }\n\n      var mbox = M.get(this._mailboxes, identity);\n      if (mbox) {\n        mbox._receiveOneShot(env);\n      }\n    },\n\n    // TODO: Should this go along the mailbox ingress channel?\n    // Or should it be cb-based?\n    _onMbxSendAndReceive: function(env) {\n      var oEnv = Options.fromObject(env),\n          identity = oEnv.getOrElse(\"to\"),\n          body = oEnv.getOrElse(\"body\");\n\n      if (!(identity || body)) {\n        Log.info(\"Exchange received a message with missing envelope information\", env);\n        return;\n      }\n\n      var mbox = M.get(this._mailboxes, identity);\n      if (mbox) {\n        mbox._receiveRequestReply(env);\n      }\n    },\n\n\n    _onMbxReply: function(env) {\n      var oEnv     = Options.fromObject(env),\n          rMsgId   = oEnv.getOrElse(\"rMsgId\");\n\n\n\n      // Don't dispatch vetted replies. Just fulfill the promise\n      Promise\n        .bind(this)\n        .then(function(){\n          return this._outstandingRequests.remove(rMsgId);\n        })\n        .then(function(request) {\n          if (request) {\n            this._reqToMsg = M.dissoc(this._reqToMsg, request.reqId);\n            request.deferred.resolve(env);\n          }\n        });\n    },\n\n\n    /**\n     * Fired when a request in the outstanding requests store is past due.\n     */\n    _onStoreSignalExpired: function(sig) {\n      Log.debug(\"Expired entry in store\", sig);\n      Promise\n        .bind(this)\n        .then(function() {\n          return this._outstandingRequests.remove(sig.key);\n        })\n        .then(function(request) {\n          if (request) {\n            this._reqToMsg = M.dissoc(this._reqToMsg, request.reqId);\n            request.deferred.reject(new Promise.TimeoutError());\n          }\n        });\n    },\n\n\n    /**\n     * Fiber delegate protocol method for a message bound for this Exchange directly.\n     *\n     * @param env\n     * @private\n     */\n    receiveFiberMessage: function(env) {\n      throw new Error(\"Not implemented\");\n    }\n  });\n\n\n  var defer = function(){\n    var res, rej;\n    var p = new Promise(function() {\n      res = arguments[0];\n      rej = arguments[1];\n    });\n\n    return {\n      promise: p,\n      resolve: res,\n      reject: rej\n    };\n  };\n\n  return Exchange;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"mori\"),\n  require(\"../core/logging/logger\"),\n  require(\"../core/options\"),\n  require(\"../core/uuid\"),\n  require(\"../core/sequencer/delegating-forwarding-sequencer\"),\n  require(\"../core/sequencer/unit-sequencer\"),\n  require(\"./fiber/in-memory-fiber\"),\n  require(\"./internals/mailbox\"),\n  require(\"../core/dispatcher\"),\n  require(\"../storage/signaling-data-store\"),\n  require(\"../util/periodic\"),\n  require(\"../core/sequencer/clock-sequencer\"),\n  require(\"../time/clock/system-clock\"),\n  require(\"../runtime\")\n);\n\n},{\"../core/dispatcher\":59,\"../core/logging/logger\":62,\"../core/options\":63,\"../core/sequencer/clock-sequencer\":69,\"../core/sequencer/delegating-forwarding-sequencer\":71,\"../core/sequencer/unit-sequencer\":72,\"../core/uuid\":75,\"../runtime\":90,\"../storage/signaling-data-store\":96,\"../time/clock/system-clock\":98,\"../util/periodic\":101,\"./fiber/in-memory-fiber\":79,\"./internals/mailbox\":82,\"bluebird\":107,\"mori\":171,\"underscore\":174}],79:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  M,\n  Options,\n  UUID,\n  StateGuard,\n  Logger\n) {\n\n  /**\n   * A fiber dictates how an Exchange's messages are actually sent. When someone requests a mailbox from an Exchange,\n   * that exchange registers itself as an entity with that address on the mailbox's behalf. When a message for that\n   * address is received by the fiber, it routes it to the exchange, which forwards it to the mailbox, and onward.\n   *\n   * There's a picture in `Courier` that illustrates the component layout.\n   *\n   * An `InMemoryFiber` only has local entities, and only performs local dispatch. A `LinkableFiber` is an\n   * `InMemoryFiber` which will forward messages to its linked fibers in the event a local entity hasn't been\n   * registered with the address for which a message is bound.\n   */\n  var InMemoryFiber = (function() {\n    var Klass = function() {\n      this.initialize.apply(this, arguments);\n    };\n\n    var Log = Logger.create(\"InMemoryLogger\");\n\n    _.extend(Klass.prototype, {\n      initialize: function(opts) {\n        opts = Options.fromObject(opts);\n\n        this._entities = M.hash_map();\n        this._identity = opts.getOrElse(\"identity\", UUID.v4());\n\n        this._stateGuard = new StateGuard([\"disposed\"]);\n\n        _.bindAll(this, \"_receive\");\n      },\n\n\n      id: function() {\n        return this._identity;\n      },\n\n\n      dispose: function() {\n        if (this._stateGuard.applied(\"disposed\")) {\n          return;\n        }\n        this._dispose();\n        this._stateGuard.apply(\"disposed\");\n      },\n\n      _dispose: function() {\n\n        var entities = this._entities;\n        M.each(entities, function(pair) {\n          M.nth(pair, 1).dispose();\n        });\n\n        this._entities = null;\n      },\n\n      registerEntity: function(opts) {\n        opts = Options.fromObject(opts);\n\n        var identity = opts.getOrError(\"identity\"),\n            entity   = new LocalEntity({\n              identity: identity,\n              delegate: opts.getOrError(\"delegate\")\n            });\n\n        this._entities = M.assoc(this._entities, identity, entity);\n        return true;\n      },\n\n      /**\n       * Returns a promise which is fulfilled when the message is\n       * sent, not received by the remote end. This to let the\n       * caller know whether or not the message is stuck\n       * in a buffer somewhere when calculating its timeouts.\n       */\n      send: Promise.method(function(opts) {\n        this._stateGuard.deny(\"disposed\");\n\n        opts = Options.fromObject(opts);\n        var from   = opts.getOrError(\"from\"),\n            to     = opts.getOrError(\"to\"),\n            body   = opts.getOrError(\"body\"),\n            msgId  = opts.getOrError(\"msgId\"),\n\n            mT     = opts.getOrElse(\"mT\"),\n            rMsgId = opts.getOrElse(\"rMsgId\");\n\n\n        //XXX: This is in-memory, so it's as simple\n        // as invoking _receive in a future call stack\n        return Promise\n          .bind(this)\n          .then(function() {\n            _.defer(this._receive, {\n              from:   from,\n              to:     to,\n              body:   body,\n              msgId:  msgId,\n              mT:     mT,\n              rMsgId: rMsgId,\n              oFib:   this._identity\n            });\n          })\n          .then(function() {\n            return msgId;\n          });\n      }),\n\n      _receive: function(env) {\n        if (this._stateGuard.applied(\"disposed\")) {\n          return;\n        }\n\n        env = Options.fromObject(env);\n        var to, from, body, msgId, originFiber, mT, rMsgId;\n\n        try {\n          to          = env.getOrError(\"to\");\n          from        = env.getOrError(\"from\");\n          body        = env.getOrError(\"body\");\n          msgId       = env.getOrError(\"msgId\");\n\n          // Future-proofing for multi-fiber fabric.\n          originFiber = env.getOrError(\"oFib\");\n\n          mT     = env.getOrElse(\"mT\");\n          rMsgId = env.getOrElse(\"rMsgId\");\n        } catch (e) {\n          Log.error(\"Received malformed message\", env);\n        }\n\n        var entity = M.get(this._entities, to);\n\n        if (entity) {\n          entity.dispatch({\n            to:     to,\n            from:   from,\n            body:   body,\n            msgId:  msgId,\n            rMsgId: rMsgId,\n            oFib:   originFiber,\n            hFib:   this._identity,\n            mT: mT\n          });\n        }\n      }\n    });\n\n    return Klass;\n  })();\n\n\n\n  var LocalEntity = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(LocalEntity.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._identity = opts.getOrError(\"identity\");\n      this._delegate = opts.getOrError(\"delegate\");\n      this._stateGuard = new StateGuard([\"disposed\"]);\n    },\n    dispose: function() {\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      this._delegate = null;\n\n      this._stateGuard.apply(\"disposed\");\n    },\n    dispatch: function(env) {\n      this._stateGuard.deny(\"disposed\");\n\n      this._delegate.receiveFiberMessage(env);\n    }\n  });\n\n  return InMemoryFiber;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"mori\"),\n  require(\"../../core/options\"),\n  require(\"../../core/uuid\"),\n  require(\"../../core/state-guard\"),\n  require(\"../../core/logging/logger\")\n);\n\n},{\"../../core/logging/logger\":62,\"../../core/options\":63,\"../../core/state-guard\":74,\"../../core/uuid\":75,\"bluebird\":107,\"mori\":171,\"underscore\":174}],80:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  M,\n  Options,\n  InMemoryFiber,\n  Channel,\n  CompositeChannel\n) {\n\n  /**\n   * LinkableFiber is a reference implementation for implementing a multi-fiber \"fabric\". Whereas an `InMemoryFiber`\n   * only has local entities, and only performs local dispatch, a `LinkableFiber` is an `InMemoryFiber` which will\n   * forward messages to its linked fibers in the event a local entity hasn't been registered with the address for\n   * which a message is bound.\n   *\n   * For an example of how this might work in a multi-process or multi-machine environment, see the\n   * `thicket-zmq-fiber` node module.\n   */\n  var LinkableFiber = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(LinkableFiber.prototype, InMemoryFiber.prototype, {\n    initialize: function(opts) {\n      InMemoryFiber.prototype.initialize.apply(this, arguments);\n      opts = Options.fromObject(opts);\n\n\n      this._localDispatch  = new Channel({ sentinel: this });\n      this._ingressChannel = new CompositeChannel({\n        sentinel: this,\n        listen:   this._localDispatch\n      });\n\n      this._egressChannel  = new Channel({ sentinel: this });\n\n      // _receive is defined and bound in InMemoryFiber (\"protected\" method)\n      this._ingressChannel.subscribe(this._receive);\n    },\n\n\n    listen: function(channel) {\n      this._ingressChannel.listen(channel);\n    },\n\n\n    egressChannel: function() {\n      return this._egressChannel;\n    },\n\n\n    _dispose: function() {\n      InMemoryFiber.prototype._dispose.apply(this, arguments);\n    },\n\n    send: Promise.method(function(opts) {\n      this._stateGuard.deny(\"disposed\");\n\n      opts = Options.fromObject(opts);\n\n      var from   = opts.getOrError(\"from\"),\n          to     = opts.getOrError(\"to\"),\n          body   = opts.getOrError(\"body\"),\n          msgId  = opts.getOrError(\"msgId\"),\n          mT     = opts.getOrElse(\"mT\"),\n          rMsgId = opts.getOrElse(\"rMsgId\"),\n          chan   = null;\n\n      var msg = {\n        from:   from,\n        to:     to,\n        body:   body,\n        msgId:  msgId,\n        mT:     mT,\n        rMsgId: rMsgId,\n        oFib:   this._identity\n      };\n\n      // Local dispatch, skip the round-trip\n      if (M.get(this._entities, to)) {\n        chan = this._localDispatch;\n      } else {\n        chan = this._egressChannel;\n      }\n\n      _.defer(_.bind(function() {\n        chan.publish(this, msg);\n      }, this));\n\n      return msgId;\n    })\n\n\n  });\n\n  return LinkableFiber;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"mori\"),\n  require(\"../../core/options\"),\n  require(\"./in-memory-fiber\"),\n  require(\"../../core/channel/channel\"),\n  require(\"../../core/channel/composite-channel\")\n);\n\n},{\"../../core/channel/channel\":56,\"../../core/channel/composite-channel\":57,\"../../core/options\":63,\"./in-memory-fiber\":79,\"bluebird\":107,\"mori\":171,\"underscore\":174}],81:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  net,\n  Logger,\n  Options,\n  CompositeChannel,\n  UUID,\n  LinkableFiber,\n  MessagePusher\n) {\n\n  var Log = Logger.create(\"TcpFiber\");\n\n  /**\n   * Warning: Experimental\n   *\n   */\n  var TcpFiber = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(TcpFiber.prototype, LinkableFiber.prototype, {\n    initialize: function(opts) {\n      LinkableFiber.prototype.initialize.apply(this, arguments);\n      opts = Options.fromObject(opts);\n      this._port = opts.getOrElse(\"port\", 11013);\n      this._server = null;\n      this._sessions = {};\n    },\n\n    start: Promise.method(function() {\n      this._server = net.createServer(_.bind(function(client) {\n        Log.debug(\"New client connected\");\n        var session = new Session();\n        this.listen(session.ingressChannel());\n        session.forward(this.egressChannel());\n        session.listenStream(client);\n        session.statusChannel().subscribe(function(msg) {\n          if (msg.mT === \"StreamError\") {\n            Log.error(\"StreamError; destroying connection\", session.id());\n            client.destroy();\n          }\n        });\n\n        this._sessions[session.id()] = session;\n        Log.debug(\"Session started\", session.id());\n        client.on(\"close\", _.bind(this._cleanupSession, this, session.id()));\n      }, this));\n\n      return new Promise(_.bind(function(resolve, reject) {\n        this._server.on(\"error\", function(err) {\n          Log.error(\"Error starting TcpFiber. Error code:\", err.code);\n          reject(err)\n        });\n\n        Log.info(\"Starting TcpFiber on port\", this._port);\n        this._server.listen(this._port, _.bind(function() {\n          Log.info(\"TcpFiber listening on port\", this._port);\n          resolve();\n        }, this));\n      }, this));\n    }),\n\n    stop: Promise.method(function() {\n      // TODO: Wait for callback?\n      this._server.close();\n    }),\n\n    _cleanupSession: function(sessionId) {\n      Log.debug(\"Disposing session\", sessionId);\n      var session = this._sessions[sessionId];\n      if (session) {\n        session.dispose();\n        delete this._sessions[sessionId];\n      }\n    }\n  });\n\n  var Session = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Session.prototype, {\n    initialize: function() {\n      this._sessionId = UUID.v4();\n      this._pusher = new MessagePusher();\n      this._status = new CompositeChannel({ sentinel: this });\n      this._status.listen(this._pusher.statusChannel());\n    },\n    id: function() {\n      return this._sessionId;\n    },\n    statusChannel: function() {\n      return this._status;\n    },\n    ingressChannel: function() {\n      return this._pusher.ingressChannel();\n    },\n    forward: function(egressChannel) {\n      return this._pusher.forward(egressChannel);\n    },\n    listenStream: function(stream) {\n      this._pusher.listenStream(stream);\n    },\n    dispose: function() {\n      if (this._status) {\n        this._status.dispose();\n        this._status = null;\n      }\n\n      if (this._pusher) {\n        this._pusher.dispose();\n        this._pusher = null;\n      }\n    }\n  });\n\n  return TcpFiber;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"net\"),\n  require(\"../../core/logging/logger\"),\n  require(\"../../core/options\"),\n  require(\"../../core/channel/composite-channel\"),\n  require(\"../../core/uuid\"),\n  require(\"./linkable-fiber\"),\n  require(\"../internals/message-pusher\")\n);\n\n},{\"../../core/channel/composite-channel\":57,\"../../core/logging/logger\":62,\"../../core/options\":63,\"../../core/uuid\":75,\"../internals/message-pusher\":83,\"./linkable-fiber\":80,\"bluebird\":107,\"net\":1,\"underscore\":174}],82:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  M,\n  Options,\n  UUID,\n  ChainedChannel,\n  Channel,\n  CompositeChannel,\n  StateGuard\n) {\n\n\n  var Mailbox = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Mailbox.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._id                    = UUID.v4();\n      this._ownerIdentity         = opts.getOrError(\"ownerIdentity\");\n      this._exchange              = opts.getOrError(\"exchange\");\n      this._oneShotChannel        = new Channel({ sentinel: this });\n      this._requestReplyChannel   = new Channel({ sentinel: this });\n      this._ingressChannel        = new CompositeChannel({\n        sentinel: this,\n        listen: [this._oneShotChannel, this._requestReplyChannel]\n      });\n      this._stateGuard            = new StateGuard([\"disposed\"]);\n\n      this._outstandingRequestIds = M.set();\n    },\n\n    id: function() {\n      return this._id;\n    },\n\n    ownerIdentity: function() {\n      return this._ownerIdentity;\n    },\n\n    dispose: function() {\n      if (this._stateGuard.applied(\"disposed\")){\n        return;\n      }\n\n      this._oneShotChannel.dispose();\n      this._requestReplyChannel.dispose();\n      this._ingressChannel.dispose();\n\n      // Attempt to cancel all outstanding requests.\n      // This is an async request, so we just have to fire and\n      // forge them.\n      //\n      // If you're disposing of a mailbox before requests\n      // complete, you might have a bad time. The good\n      // news is because responses are ferried back from the fiber\n      // to the mailbox caller via the Promise interface rather\n      // than channels, they should still get CancellationErrors\n      var reqs = this._outstandingRequestIds;\n      this._outstandingRequestIds = M.set();\n\n      M.each(reqs, _.bind(function(reqId) {\n        this._exchange.cancelSendAndReceive(reqId);\n      }, this));\n\n      this._oneShotChannel      = null;\n      this._requestReplyChannel = null;\n      this._ingressChannel      = null;\n\n      this._stateGuard.apply(\"disposed\");\n    },\n\n    /**\n     * Returns a new ChainedChannel chained to this Mailbox's\n     * privately-owned inbound Channel.\n     * @returns {ChainedChannel}\n     */\n    ingressChannel: function() {\n      return this._ingressChannel;\n    },\n\n    oneShotChannel: function() {\n      return this._oneShotChannel;\n    },\n\n    requestReplyChannel: function() {\n      return this._requestReplyChannel;\n    },\n\n    send: Promise.method(function(env) {\n      this._stateGuard.deny(\"disposed\");\n\n      env = _.extend({}, env || {}, {\n        from: this._ownerIdentity\n      });\n      return this._exchange.send(env);\n    }),\n\n    reply: Promise.method(function(msgId, env) {\n      this._stateGuard.deny(\"disposed\");\n\n      env = _.extend({}, env || {}, {\n        rMsgId: msgId,\n        from: this._ownerIdentity\n      });\n\n      return this._exchange.reply(env);\n    }),\n\n    sendAndReceive: Promise.method(function(env, opts) {\n      this._stateGuard.deny(\"disposed\");\n\n      var reqId = (opts || {}).reqId || UUID.v4();\n\n      env = _.extend({}, env || {}, {\n        from: this._ownerIdentity\n      });\n\n      opts = _.extend({}, opts || {}, {\n        reqId: reqId\n      });\n\n      this._outstandingRequestIds = M.conj(this._outstandingRequestIds, reqId);\n\n      return this._exchange\n        .sendAndReceive(env, opts)\n        .bind(this)\n        .then(function(resp) {\n          this._outstandingRequestIds = M.disj(this._outstandingRequestIds, reqId);\n          return resp;\n        })\n        .caught(Promise.CancellationError, function(err) {\n          this._outstandingRequestIds = M.disj(this._outstandingRequestIds, reqId);\n          throw err;\n        })\n        .caught(Promise.TimeoutError, function(err) {\n          this._outstandingRequestIds = M.disj(this._outstandingRequestIds, reqId);\n          throw err;\n        });\n    }),\n\n\n    outstandingRequestCount: function() {\n      return M.count(this._outstandingRequestIds);\n    },\n\n\n    cancelSendAndReceive: Promise.method(function(reqId) {\n      return this._exchange\n        .cancelSendAndReceive(reqId)\n        .bind(this)\n        .then(function() {\n          this._outstandingRequestIds = M.disj(this._outstandingRequestIds, reqId);\n        });\n    }),\n\n    _receiveOneShot: function(msg) {\n      this._oneShotChannel.publish(this, msg);\n    },\n\n    _receiveRequestReply: function(msg) {\n      this._requestReplyChannel.publish(this, msg);\n    }\n  });\n\n  return Mailbox;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"mori\"),\n  require(\"../../core/options\"),\n  require(\"../../core/uuid\"),\n  require(\"../../core/channel/chained-channel\"),\n  require(\"../../core/channel/channel\"),\n  require(\"../../core/channel/composite-channel\"),\n  require(\"../../core/state-guard\")\n);\n\n},{\"../../core/channel/chained-channel\":55,\"../../core/channel/channel\":56,\"../../core/channel/composite-channel\":57,\"../../core/options\":63,\"../../core/state-guard\":74,\"../../core/uuid\":75,\"bluebird\":107,\"mori\":171,\"underscore\":174}],83:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Channel,\n  CompositeChannel,\n  Logger,\n  Options,\n  Lang,\n  UUID,\n  JSONSerde\n) {\n\n  var Log = Logger.create(\"MessagePusher\");\n\n  var TERMINATION_CHAR = \"\\0\";\n\n  var StreamError = function() {\n    return {\n      mT: \"StreamError\"\n    };\n  };\n\n  /**\n   * Warning: Experimental\n   *\n   */\n  var MessagePusher = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(MessagePusher.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._id = UUID.v4();\n\n      this._status = new Channel({ sentinel: this });\n      this._ingress = new Channel({ sentinel: this });\n      this._egress  = new CompositeChannel({ sentinel: this });\n\n      this._buffer = [];\n\n      this._serde = opts.getOrElseFn(\"serde\", function() {\n        return new JSONSerde();\n      });\n\n      _.bindAll(this, \"_onData\", \"_onPub\");\n\n      this._egress.subscribe(this._onPub);\n    },\n\n    dispose: function() {\n\n      if (this._status) {\n        this._status.dispose();\n        this._status = null;\n      }\n\n      if (this._ingress) {\n        this._ingress.dispose();\n        this._ingress = null;\n      }\n\n      if (this._egress) {\n        this._egress.dispose();\n        this._egress = null;\n      }\n\n      if (this._stream) {\n        this._stream.removeListener(\"data\", this._onData);\n        this._stream = null;\n      }\n\n      this._buffer = [];\n    },\n\n    statusChannel: function() {\n      return this._status;\n    },\n\n    egressChannel: function() {\n      return this._egress;\n    },\n\n    ingressChannel: function() {\n      return this._ingress;\n    },\n\n    forward: function(channel) {\n      this._egress.listen(channel);\n    },\n\n    listenStream: function(stream) {\n      if (this._stream) {\n        throw new MessagePusher.Error.DuplicateStreamError();\n      }\n\n      this._stream = stream;\n      this._stream.setEncoding(\"utf8\");\n      this._stream.on(\"data\", this._onData);\n    },\n\n    _onData: function(data) {\n      this._ingest(data);\n    },\n\n    _onPub: function(msg) {\n      if (this._stream) {\n        var outbound = this._encodeForWire(msg);\n        try {\n          this._stream.write(outbound, 'utf8');\n        } catch (e) {\n          this._status.publish(this, StreamError());\n        }\n      }\n    },\n\n    // Cheat cheat\n    _encodeForWire: function(msg) {\n      return this._serde.serialize(msg) + TERMINATION_CHAR;\n    },\n\n    _ingest: function(data) {\n      Log.trace(\"Raw ingest data\", this._id, data);\n      var idx = data.indexOf(TERMINATION_CHAR),\n          done = false,\n          messages = [],\n          current, buff;\n\n      while(!done) {\n        if (data.length === 0) {\n          done = true;\n        } else if (idx === -1) {\n          this._buffer.push(data);\n          done = true;\n        } else {\n          buff = this._buffer;\n          this._buffer = [];\n          current = data.substr(0, idx);\n          buff.push(current);\n          messages.push(buff.join(\"\"));\n          data = data.substr(idx + 1);\n          idx = data.indexOf(TERMINATION_CHAR);\n        }\n      }\n\n      try {\n        var messages = _.map(messages, _.bind(function(msgStr) {\n          return this._serde.deserialize(msgStr);\n        }, this));\n\n        _.each(messages, function(msg) {\n          _.defer(_.bind(function() {\n            this._ingress.publish(this, msg);\n          }, this));\n        }, this);\n      } catch (e) {\n        Log.debug(\"Caught error parsing message;\", e);\n        if (this._stream) {\n          this._stream.removeListener(\"data\", this._onData);\n          this._stream = null;\n          this._status.publish(this, StreamError());\n        }\n      }\n    }\n  });\n\n  _.extend(MessagePusher, {\n    Error: {\n      DuplicateStreamError: Lang.makeErrorClass(\"DuplicateStreamError\", \"cannot listen on multiple streams\")\n    }\n  })\n\n  return MessagePusher;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../../core/channel/channel\"),\n  require(\"../../core/channel/composite-channel\"),\n  require(\"../../core/logging/logger\"),\n  require(\"../../core/options\"),\n  require(\"../../core/lang\"),\n  require(\"../../core/uuid\"),\n  require(\"../../core/serde/json-serde\")\n);\n\n},{\"../../core/channel/channel\":56,\"../../core/channel/composite-channel\":57,\"../../core/lang\":60,\"../../core/logging/logger\":62,\"../../core/options\":63,\"../../core/serde/json-serde\":73,\"../../core/uuid\":75,\"underscore\":174}],84:[function(require,module,exports){\nmodule.exports = function(c) {\n  c.registerMany([\n    {\n      module: require(\"./appkit/bootstrapper\"),\n      as: \"bootstrapper\"\n    },\n    {\n      module: require(\"./appkit/node-app-container\"),\n      as: \"app-container\"\n    },\n    {\n      module: require(\"./scheduler/node-scheduler\"),\n      as: \"scheduler\"\n    },\n    {\n      module: require(\"./messaging/fiber/tcp-fiber\"),\n      as: \"messaging/fibers/tcp\"\n    },\n    {\n      module: require(\"./messaging/internals/message-pusher\"),\n      as: \"messaging/internals/message-pusher\"\n    }\n  ]);\n};\n\n},{\"./appkit/bootstrapper\":44,\"./appkit/node-app-container\":49,\"./messaging/fiber/tcp-fiber\":81,\"./messaging/internals/message-pusher\":83,\"./scheduler/node-scheduler\":91}],85:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options,\n  Lang,\n  UUID,\n  Courier\n) {\n\n  var BaseClient = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(BaseClient.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._exchange = opts.getOrError(\"exchange\");\n      this._identity = opts.getOrElseFn(\"identity\", function() {\n        return UUID.v4();\n      });\n      this._serviceIdentity = opts.getOrError(\"serviceIdentity\");\n      this._mailbox         = this._exchange.mailbox(this._identity);\n      this._courier         = new Courier({\n        delegate: this,\n        mailbox: this._mailbox\n      });\n    },\n\n    __registerMethod: function(name, methodSpec) {\n      var args          = methodSpec.args(),\n          defaults      = methodSpec.defaults(),\n          mType         = methodSpec.mType() || name,\n          courierMethod = methodSpec.requestReply() ? \"sendAndReceive\" : \"send\";\n\n      var getArgs = _.bind(function(defaults, methodArgs) {\n        var finalArgs = {}, argName, argVal;\n        for (var i = 0; i < args.length; i++) {\n          argName = args[i];\n          argVal = methodArgs[i];\n          if (typeof argVal === \"undefined\") {\n            if (defaults.hasOwnProperty(argName)) {\n              finalArgs[argName] = defaults[argName];\n            } else {\n              throw new Error.ArgumentMissingError(\"argument missing: \" + argName);\n            }\n          } else {\n            finalArgs[argName] = argVal;\n          }\n        }\n        return finalArgs;\n      }, null, defaults);\n\n      this[name] = Promise.method(_.bind(function() {\n        var msg = _.extend({\n          mT: mType\n        }, getArgs(_.toArray(arguments)));\n        return this._courier[courierMethod](this._serviceIdentity, msg);\n      }, this));\n\n    }\n  });\n\n  var Error = {\n    ArgumentMissingError: Lang.makeErrorClass(\"ArgumentMissingError\", \"argument missing\")\n  };\n\n  BaseClient.Error = Error;\n\n  return BaseClient;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../../core/options\"),\n  require(\"../../core/lang\"),\n  require(\"../../core/uuid\"),\n  require(\"../../messaging/courier\")\n);\n\n},{\"../../core/lang\":60,\"../../core/options\":63,\"../../core/uuid\":75,\"../../messaging/courier\":77,\"bluebird\":107,\"underscore\":174}],86:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options,\n  BaseClient\n) {\n\n  var ClientBuilder = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(ClientBuilder.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._spec = opts.getOrError(\"spec\");\n    },\n\n    build: function(opts) {\n      var c = new BaseClient(_.extend({}, this._spec.initOptions(), opts));\n      _.each(this._spec.methods(), function(spec, name) {\n        c.__registerMethod(name, spec);\n      });\n      return c;\n    }\n  });\n\n  return ClientBuilder;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../../core/options\"),\n  require(\"./base-client\")\n);\n\n},{\"../../core/options\":63,\"./base-client\":85,\"underscore\":174}],87:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options,\n  MethodSpec\n) {\n\n  var ClientSpec = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(ClientSpec.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._methodSpecs = _.reduce(opts.getOrElse(\"methods\", {}), function(memo, spec, name) {\n        memo[name] = new MethodSpec(spec);\n        return memo;\n      }, {});\n      this._initOptions = opts.getOrElse(\"initOptions\", {});\n    },\n\n    methods: function() {\n      return this._methodSpecs;\n    },\n\n    initOptions: function() {\n      return this._initOptions;\n    }\n  });\n\n  return ClientSpec;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../../core/options\"),\n  require(\"./method-spec\")\n);\n\n},{\"../../core/options\":63,\"./method-spec\":88,\"underscore\":174}],88:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  Lang\n) {\n\n  var MethodSpec = Lang.pojoClass([\"args\", \"defaults\", \"mType\", \"requestReply\"], {\n    defaults: {\n      args:         [],\n      defaults:     {},\n      requestReply: true\n    }\n  });\n\n  return MethodSpec;\n};\n\nmodule.exports = mod(\n  require(\"../../core/lang\")\n);\n\n},{\"../../core/lang\":60}],89:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options,\n  Ref,\n  SetTimeoutScheduler\n) {\n\n  var DefaultRuntime = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(DefaultRuntime.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n\n      this._schedulerRef = Ref(opts.getOrElseFn(\"scheduler\", function() {\n        return new SetTimeoutScheduler();\n      }));\n    },\n\n    /**\n     * @returns {Ref<Scheduler>}\n     */\n    scheduler: function() {\n      return Ref.delegating(this._schedulerRef);\n    },\n\n    setScheduler: function(scheduler) {\n      this._schedulerRef.set(scheduler);\n    }\n  });\n\n  return DefaultRuntime;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../core/options\"),\n  require(\"../core/ref\"),\n  require(\"../core/scheduler/set-timeout-scheduler\")\n);\n\n},{\"../core/options\":63,\"../core/ref\":66,\"../core/scheduler/set-timeout-scheduler\":68,\"underscore\":174}],90:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nmodule.exports = require(\"./default-runtime\");\n\n},{\"./default-runtime\":89}],91:[function(require,module,exports){\n(function (process){\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  var NodeScheduler = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(NodeScheduler.prototype, {\n    initialize: function() {},\n\n    runSoon: function(fn) {\n      process.nextTick(fn);\n    },\n\n    schedule: function(fn, delay) {\n      delay = delay || 1;\n      return setTimeout(fn, delay);\n    },\n\n    unschedule: function(id) {\n      return clearTimeout(id);\n    }\n  });\n\n  return NodeScheduler;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n}).call(this,require('_process'))\n},{\"_process\":11,\"underscore\":174}],92:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options,\n  InMemoryDataStore,\n  UnitSequencer,\n  Entry\n) {\n\n  // Appropriate for the default sequencer (non-temporal)\n  var DEFAULT_TTL = 1;\n\n\n  /**\n   * A look-aside caching data store. Note: it's generally not useful to allow\n   * null/undefined stored values. When an item is evicted from the cache, a\n   * subsequent `get` call will return `undefined`, so it can be difficult to\n   * determine if there was a cache miss if the value you're storing is, in fact,\n   * `undefined`, unless you prefix every check with `exists`, which also does\n   * cache eviction on check.\n   */\n  var CachingDataStore = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(CachingDataStore.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._ttl = opts.getOrElse(\"ttl\", DEFAULT_TTL);\n\n      // Default sequencer is a linear/unit sequencer. The default TTL is\n      // 1. Therefore, all values will expire with single advance of the\n      // sequencer. Note that the data store doesn't advance the\n      // sequencer itself. The store owner is responsible for doing\n      // this.\n      //\n      // This is especially important to note for time-based sequencers.\n      // Time will not advance automatically. The store owner is responsible\n      // for scheduling the sequencer to advance with time. This keeps the\n      // CachingDataStore's lifecycle simple with respect to time.\n      this._sequencer = opts.getOrElseFn(\"sequencer\", function() {\n        return new UnitSequencer();\n      });\n\n      // By default, we delegate to an in-memory store. Fine for simple\n      // cases, but not optimal.\n      this._backingStore = opts.getOrElseFn(\"backingStore\", function() {\n        return new InMemoryDataStore();\n      });\n\n      // Updates the lastUpdated time to \"now\" on read - keeps entries\n      // from expiring when they're being accessed, but can cause\n      // staleness issues.\n      this._shouldTouchOnRead = opts.getOrElse(\"touchOnRead\", false);\n    },\n\n    sequencer: function() {\n      return this._sequencer;\n    },\n\n\n    /**\n     * Gets the value associated with the provided key. If the object has\n     * expired, it will be evicted from the cache, and `undefined` will\n     * be returned instead.\n     *\n     * @param key {string} (required)\n     * @async\n     * @returns {Promise<Object>} requested value\n     */\n    get: Promise.method(function(key) {\n      return Promise\n        .bind(this)\n        .then(function() {\n          return this._backingStore.get(key);\n        })\n        .then(function(entry){\n          if (!entry) {\n            return;\n          }\n\n          if (!entry.isExpired(this._sequencer.value(), this._ttl)) {\n            if (this._shouldTouchOnRead) {\n              entry.touch(this._sequencer.value());\n            }\n            return Promise\n              .bind(this)\n              .then(function() {\n                return this._backingStore.put(key, entry);\n              })\n              .return(entry.value());\n          } else {\n            return Promise\n              .bind(this)\n              .then(function() {\n                return this.remove(key)\n              })\n              .then(function() {\n                // .thenReturn is a lie.\n                return;\n              });\n          }\n        });\n    }),\n\n    /**\n     * Stores the provided `val`, identified by `key`\n     *\n     * @param `key` {string}  (required) identifier for value to be stored\n     * @param `val` {dynamic} (required) value to be stored\n     * @async\n     * @returns {Promise<>}\n     */\n    put: Promise.method(function(key, val) {\n      return Promise\n        .bind(this)\n        .then(function() {\n          return this._backingStore.get(key);\n        })\n        .then(function(entry) {\n          // If we have an entry, we should just update\n          // Else, we make new one.\n          // Pesist, then return nothing.\n          if (entry) {\n            entry.update(val, this._sequencer.value());\n          } else {\n            entry = new Entry({\n              value: val,\n              initialSequence: this._sequencer.value()\n            });\n          }\n\n          return Promise\n            .bind(this)\n            .then(function() {\n              return this._backingStore.put(key, entry)\n            })\n            .then(function() {\n              return;\n            });\n        });\n    }),\n\n    /**\n     * Removes the value associated with the provided `key`\n     *\n     * @param `key` {string} (required) identifier for value to be removed\n     * @async\n     * @returns {Promise<dynamic>} Removed value, if present in store.\n     */\n    remove: Promise.method(function(key) {\n      var val;\n      return this._backingStore\n        .remove(key)\n        .then(function(entry) {\n          if (entry) {\n            val = entry.value();\n            entry.dispose();\n            return val;\n          }\n        });\n    }),\n\n    exists: Promise.method(function(key){\n      // It's not sufficient to delegate this call to the underlying\n      // backing store. We need to perform eviction, as a subsequent call\n      // to get would do the same. If the `exists` check says it exists,\n      // bet it doesn't when we `get`, then `exists` is a worthless operation.\n      //\n      // Note that if you're using a CachingDataStore backed by an InMemoryDataStore\n      // backed by an LRUHashMap, this will cause the entry to be \"touched\", whereas\n      // a normal \"exists\" check would not.\n      return Promise\n        .bind(this)\n        .then(function() {\n          return this._backingStore.get(key);\n        })\n        .then(function(entry) {\n            if (!entry) {\n              return false;\n            } else {\n              if (!entry.isExpired(this._sequencer.value(), this._ttl)) {\n                return true;\n              } else {\n                return this._backingStore.remove(key)\n                  .then(function() {\n                    entry.dispose();\n                  })\n                  .thenReturn(false);\n              }\n            }\n        });\n    }),\n\n    clear: Promise.method(function() {\n      return this._backingStore.clear();\n    })\n  });\n\n  return CachingDataStore;\n\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../core/options\"),\n  require(\"./in-memory-data-store\"),\n  require(\"../core/sequencer/unit-sequencer\"),\n  require(\"./internals/expiring-entry\")\n);\n\n},{\"../core/options\":63,\"../core/sequencer/unit-sequencer\":72,\"./in-memory-data-store\":93,\"./internals/expiring-entry\":94,\"bluebird\":107,\"underscore\":174}],93:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options,\n  ObjectHashMap\n) {\n\n  /**\n   * InMemoryDataStore delegates to a backing HashMap. By default, this\n   * will be a \"poor man's HashMap\", a.k.a., the ObjectHashMap.\n   */\n  var InMemoryDataStore = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(InMemoryDataStore.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._map = opts.getOrElseFn(\"backingHashMap\", function() {\n        return new ObjectHashMap();\n      });\n    },\n\n    get: Promise.method(function(key) {\n      return this._map.get(key);\n    }),\n\n    put: Promise.method(function(key, val) {\n      return this._map.put(key, val);\n    }),\n\n    remove: Promise.method(function(key) {\n      return this._map.remove(key);\n    }),\n\n    exists: Promise.method(function(key){\n      return this._map.exists(key);\n    }),\n\n    clear: Promise.method(function() {\n      return this._map.clear();\n    })\n  });\n\n  return InMemoryDataStore;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../core/options\"),\n  require(\"../collection/object-hash-map\")\n);\n\n},{\"../collection/object-hash-map\":54,\"../core/options\":63,\"bluebird\":107,\"underscore\":174}],94:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options\n) {\n\n  var StoreEntry = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(StoreEntry.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      // Perfectly acceptable to pass in undefined...\n      this._value = opts.getOrElse(\"value\", undefined);\n      this._lastSequence = opts.getOrError(\"initialSequence\");\n\n      this._ttl = opts.getOrElse(\"ttl\");\n    },\n\n    isExpired: function(sequence, fallbackTtl) {\n      var ttl = this._ttl || fallbackTtl;\n      if (!ttl) {\n        throw new Error(\"No TTL specified!\");\n      }\n      // E.g., lastSequence = 4, ttl = 1, sequence = 5: expired\n      //       lastSequence = 4, ttl = 1, sequence = 4: not expired\n      //       lastSequence = 4, ttl = 2, sequence = 5: not expired\n      return !(this._lastSequence + ttl > sequence);\n    },\n\n    touch: function(sequence) {\n      this._lastSequence = sequence;\n    },\n\n    update: function(val, sequence, opts) {\n      this._value        = val;\n      this._lastSequence = sequence;\n\n      opts = Options.fromObject(opts);\n      this._ttl = opts.getOrElse(\"ttl\");\n    },\n\n    dispose: function() {\n      this._value        = null;\n      this._lastSequence = null;\n    },\n\n    value: function() {\n      return this._value;\n    }\n  });\n\n  return StoreEntry;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../../core/options\")\n);\n\n},{\"../../core/options\":63,\"underscore\":174}],95:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options,\n  InMemoryDataStore,\n  LRUHashMap\n) {\n\n  /**\n   * A Data Store with an LRU eviction policy.\n   *\n   */\n  var LRUDataStore = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(LRUDataStore.prototype, InMemoryDataStore.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      var map = new LRUHashMap({\n        capacity: opts.getOrError(\"capacity\")\n      });\n      InMemoryDataStore.prototype.initialize.call(this, {\n        backingHashMap: map\n      });\n    }\n  });\n\n  return LRUDataStore;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../core/options\"),\n  require(\"./in-memory-data-store\"),\n  require(\"../collection/lru-hash-map\")\n);\n\n},{\"../collection/lru-hash-map\":52,\"../core/options\":63,\"./in-memory-data-store\":93,\"underscore\":174}],96:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  M,\n  Options,\n  Channel,\n  ChainedChannel,\n  UnitSequencer,\n  DelegatingForwardingSequencer,\n  InMemoryDataStore,\n  Entry\n) {\n\n  /**\n   * Semantically similar to a CachingDataStore, except:\n   *   1) Expiry is check both on access, and whenever `advance` is\n   *      called on the `sentrySequencer`.\n   *   2) Records are not automatically removed; instead, a signal is sent\n   *      along the `signalChannel`. The signal dispatch is deferred, so\n   *      an access-triggered evocation signal won't be received until a\n   *      subsequent tick. Since promises are asynchronous, this means\n   *      the caller may receive a value from the store, and may also\n   *      receive an event from the Store indicating expiry - in non-deterministic\n   *      order. It's up to the caller to choose a resolution.\n   *      Additionally, there is no guarantee that a single expiry event\n   *      will be sent for a given key; instead, the event will continue\n   *      to be dispatched for as long as the key remains in the store.\n   * @constructor\n   */\n  var SignalingDataStore = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  var DEFAULT_TTL = 1;\n\n  _.extend(SignalingDataStore.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._ttl = opts.getOrElse(\"ttl\", DEFAULT_TTL);\n\n      this._sequencer = opts.getOrElseFn(\"sequencer\", function() {\n        return new UnitSequencer();\n      });\n\n      _.bindAll(this, \"_doCheck\");\n\n      this._sentrySequencer = new DelegatingForwardingSequencer({\n        delegate: new UnitSequencer(),\n        targets: [{\n          advance: this._doCheck\n        }]\n      });\n\n      this._backingStore = opts.getOrElseFn(\"backingStore\", function() {\n        return new InMemoryDataStore();\n      });\n\n      this._shouldTouchOnRead = opts.getOrElse(\"touchOnRead\", false);\n\n      this._signalChannel = new Channel({ sentinel: this });\n\n      this._keys = M.set();\n    },\n\n    sequencer: function() {\n      return this._sequencer;\n    },\n\n    sentrySequencer: function() {\n      return this._sentrySequencer;\n    },\n\n    signalChannel: function() {\n      return new ChainedChannel({\n        sentinel: this,\n        chainTo: this._signalChannel\n      });\n    },\n\n    _doCheck: function() {\n      var work = M.map(_.bind(function(key) {\n        return Promise\n          .bind(this)\n          .then(function() {\n            return this._backingStore.get(key);\n          })\n          .then(function(entry) {\n            if (entry && entry.isExpired(this._sequencer.value(), this._ttl)) {\n              this._signalExpirySoon(key, this._sequencer.value());\n            }\n          });\n        }, this), this._keys);\n\n      return Promise.all(M.into_array(work));\n    },\n\n    /**\n     * Gets the value associated with the provided `key`. If the object\n     * has expired, it will still be returned from the Store, but an mT:expired\n     * message will be sent along the `signalChannel`.\n     *\n     * @param key {string}\n     * @async\n     * @returns {Promise<object>} requested value\n     */\n    get: Promise.method(function(key){\n      return Promise\n        .bind(this)\n        .then(function() {\n          return this._backingStore.get(key);\n        })\n        .then(function(entry) {\n          if (!entry) {\n            return;\n          }\n\n          var isExpired = entry.isExpired(this._sequencer.value(), this._ttl);\n\n          if (isExpired) {\n            this._signalExpirySoon(key, this._sequencer.value());\n          }\n\n          if (!isExpired && this._shouldTouchOnRead) {\n            entry.touch(this._sequencer.value());\n            return Promise\n              .bind(this)\n              .then(function() {\n                return this._backingStore.put(key, entry);\n              })\n              .thenReturn(entry.value());\n          } else {\n            return entry.value();\n          }\n        });\n    }),\n\n    /**\n     * Stores the provided `val`, identified by `key`, with a TTL optionally\n     * supplied by `opts.ttl` (overrides pre-configured Store TTL.\n     *\n     * @param key {String}\n     * @param val {object} value to be stored\n     * @async\n     * @returns {Promise<>}\n     */\n    put: Promise.method(function(key, val, opts) {\n      opts = Options.fromObject(opts);\n\n      return Promise\n        .bind(this)\n        .then(function() {\n          return this._backingStore.get(key);\n        })\n        .then(function(entry) {\n          if (entry) {\n            entry.update(val, this._sequencer.value(), {\n              ttl: opts.getOrElse(\"ttl\")\n            });\n          } else {\n            entry = new Entry({\n              value: val,\n              initialSequence: this._sequencer.value(),\n              ttl: opts.getOrElse(\"ttl\")\n            });\n          }\n          return Promise\n            .bind(this)\n            .then(function () {\n              return this._backingStore.put(key, entry);\n            })\n            .then(function() {\n              this._keys = M.conj(this._keys, key);\n              return; // Because thenReturn doesn't work with an empty value.\n            });\n        });\n    }),\n\n\n    /**\n     * Removes the value associated with the provided `key`\n     */\n    remove: Promise.method(function(key){\n      var val;\n      return this._backingStore\n        .remove(key)\n        .bind(this)\n        .then(function(entry) {\n          if (entry) {\n            this._keys = M.disj(this._keys, key);\n\n            val = entry.value();\n            entry.dispose();\n            return val;\n          }\n        });\n    }),\n\n\n    exists: Promise.method(function(key){\n      // Unlike in the CachingDataStore, where we have to perform eviction rules before\n      // returning the answer, here we can just delegate straight to the backing store.\n      return this._backingStore.exists(key);\n    }),\n\n\n    clear: Promise.method(function(){\n      return this._backingStore.clear();\n    }),\n\n\n    _signalExpirySoon: function(key, sequence) {\n      _.defer(_.bind(function(){\n        this._signalChannel.publish(this, {\n          mT: \"expired\",\n          key: key,\n          sequence: sequence\n        });\n      }, this));\n    }\n  });\n\n  return SignalingDataStore;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"mori\"),\n  require(\"../core/options\"),\n  require(\"../core/channel/channel\"),\n  require(\"../core/channel/chained-channel\"),\n  require(\"../core/sequencer/unit-sequencer\"),\n  require(\"../core/sequencer/delegating-forwarding-sequencer\"),\n  require(\"./in-memory-data-store\"),\n  require(\"./internals/expiring-entry\")\n);\n\n},{\"../core/channel/chained-channel\":55,\"../core/channel/channel\":56,\"../core/options\":63,\"../core/sequencer/delegating-forwarding-sequencer\":71,\"../core/sequencer/unit-sequencer\":72,\"./in-memory-data-store\":93,\"./internals/expiring-entry\":94,\"bluebird\":107,\"mori\":171,\"underscore\":174}],97:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options\n) {\n  /**\n   * A Clock which allows manually manipulating the underlying time value,\n   * irrespective of real time. Useful for testing.\n   */\n  var LogicalClock = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(LogicalClock.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._currentTime = opts.getOrElse(\"initialTime\", 0);\n    },\n\n    /**\n     * @async\n     * @returns {Promise<number>} Time in milliseconds since epoch\n     * @see Clock#getTime()\n     */\n    getTime: Promise.method(function() {\n      return this._currentTime;\n    }),\n\n    /**\n     * Advances internal time, either `opts.by` a certain offset, or\n     * `opts.to` a particular absolute time. If successful, returns the result\n     * of calling `LogicalClock#getTime()` as a convenience.\n     *\n     * @param opts.to {number} absolute time to set clock to. Must be larger\n     *                         than the current time\n     * @param opts.by {number} offset to add to current time. Must be positive.\n     *                         Defaults to `1` if neither `opts.to` or `opts.by`\n     *                         are specified.\n     * @async\n     * @returns {Promise<number>} result of `LogicalClock#getTime()`\n     */\n    advanceTime: Promise.method(function(opts){\n      opts = Options.fromObject(opts);\n      var by = opts.getOrElse(\"by\", 1),\n          to = opts.getOrElse(\"to\", undefined);\n      if (!_.isUndefined(to)) {\n        if (to < this._currentTime) {\n          throw new Error(\"LogicalClock#advanceTime() requires forward movement of time\")\n        }\n        this._currentTime = to;\n      } else {\n        if (by < 0) {\n          throw new Error(\"LogicalClock#advanceTime() requires forward movement of time\");\n        }\n        this._currentTime = this._currentTime + by;\n      }\n      return this.getTime();\n    })\n  });\n\n  return LogicalClock;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../../core/options\")\n);\n\n},{\"../../core/options\":63,\"bluebird\":107,\"underscore\":174}],98:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise\n) {\n\n  /**\n   * A Clock which delegates to the system clock.\n   */\n  var SystemClock = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(SystemClock.prototype, {\n    initialize: function() {},\n    /**\n     * @async\n     * @returns {Promise<number>} Time in milliseconds since epoch\n     * @see Clock#getTime()\n     */\n    getTime: Promise.method(function() {\n      return Date.now();\n    })\n  });\n\n  return SystemClock;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\")\n);\n\n},{\"bluebird\":107,\"underscore\":174}],99:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar factory = function(\n  _,\n  Options\n) {\n\n  /**\n   * Like a `ComponentRegistry`, but modules are loaded on-demand rather than eagerly required and aliased. This is\n   * done by providing the top-level `require` method as an initialization parameter, which maintains the appropriate\n   * path context for resolving relative imports later.\n   *\n   * Note this only works in Node, not environments like Browserify, which need to eagerly resolve all required\n   * modules via static analysis. For that, use the `ComponentRegistry`.\n   */\n  var ComponentLoader = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(ComponentLoader.prototype, {\n    initialize: function(requireFun) {\n      this._requireFun = requireFun;\n      this._aliases = {};\n      this._pathTransform = function(id) { return id;};\n    },\n\n    setPathTransform: function(pathTransform) {\n      this._pathTransform = pathTransform;\n      return this;\n    },\n\n    alias: function(opts) {\n      opts = Options.fromObject(opts);\n      var aliasName  = opts.getOrError(\"as\");\n      this._aliases[aliasName] = opts.getOrError(\"module\");\n    },\n\n    bulkAlias: function(aliases) {\n      _.each(aliases, function(aliasNames, moduleName) {\n        if (!_.isArray(aliasNames)) {\n          aliasNames = [aliasNames]\n        }\n        _.each(aliasNames, function(aliasName) {\n          this.alias({module: moduleName, as: aliasName});\n        }, this);\n      }, this);\n    },\n\n    component: function(alias) {\n      var mod = this._aliases[alias];\n      if (!mod) {\n        throw new Error(\"Invalid alias provided (no such module): `\"+alias+\"'\");\n      }\n      return this._requireFun(this._pathTransform(mod));\n    },\n\n    c: function(alias) {\n      return this.component.apply(this, arguments);\n    }\n  });\n\n  return ComponentLoader;\n};\n\nmodule.exports = factory(\n  require(\"underscore\"),\n  require(\"../core/options\")\n);\n\n},{\"../core/options\":63,\"underscore\":174}],100:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Options\n) {\n\n  /**\n   * A registry for modules. Allows an NPM package to expose internal modules without needing to know the explicit\n   * file path, which may change from release to release. Each module may have one or more aliases which can be\n   * used to request it later.\n   *\n   */\n  var ComponentRegistry = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(ComponentRegistry.prototype, {\n    initialize: function() {\n      this._modules = {};\n    },\n\n\n    register: function(opts) {\n      opts = Options.fromObject(opts);\n      var aliases   = opts.getOrError(\"as\"),\n          modObject = opts.getOrError(\"module\");\n\n      if (!_.isArray(aliases)) {\n        aliases = [ aliases ];\n      }\n\n      _.each(aliases, _.bind(function(alias) {\n        this._modules[alias] = modObject;\n      }, this));\n\n      return this;\n    },\n\n    selfRegister: function(opts) {\n      opts = Options.fromObject(opts);\n\n      return this.register({\n        as: opts.getOrError(\"as\"),\n        module: ComponentRegistry\n      });\n    },\n\n\n    registerMany: function(aliasesAry) {\n      _.each(aliasesAry, _.bind(function(alias) {\n        this.register(alias);\n      }, this));\n      return this;\n    },\n\n    component: function(alias) {\n      var m = this._modules[alias];\n      if (!m) {\n        throw new Error(\"Invalid alias provided (no such module): `\"+alias+\"'\");\n      }\n      return m;\n    }\n\n  });\n\n  ComponentRegistry.prototype.c = ComponentRegistry.prototype.component;\n\n  return ComponentRegistry;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"../core/options\")\n);\n\n},{\"../core/options\":63,\"underscore\":174}],101:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options,\n  StateGuard,\n  Channel,\n  ChainedChannel,\n  Logger\n) {\n\n  /**\n   * Upon `start()`, runs the provided Promisified `task` every `interval` milliseconds until `stop()` is called. The results\n   * of each `task` are sent along the `egressChannel()`, as `msg.result` or `msg.err`.\n   *\n   * @constructor\n   */\n  var Periodic = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  var Log = Logger.create(\"Periodic\");\n\n  _.extend(Periodic.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._schedulerRef = opts.getOrError(\"scheduler\");\n      this._task         = opts.getOrElse(\"task\");\n      this._interval     = opts.getOrError(\"interval\");\n\n      this._stateGuard   = new StateGuard([\"disposed\", \"started\"]);\n      this._channel      = new Channel({ sentinel: this });\n      this._taskId       = null;\n\n      _.bindAll(this, \"_runTask\");\n    },\n\n\n    start: function(){\n      this._stateGuard\n        .deny(\"disposed\", \"started\")\n        .apply(\"started\");\n\n      this._scheduleNext(true);\n    },\n\n\n    stop: function() {\n      this._cancelPending();\n      this._cancelOutstanding();\n      this._stateGuard.unapply(\"started\");\n    },\n\n    egressChannel: function() {\n      return new ChainedChannel({\n        sentinel: this,\n        chainTo: this._channel\n      });\n    },\n\n    _runTask: function() {\n      var results = {\n        mT: \"results\",\n        result: null,\n        err: null\n      };\n\n      this._taskId = null;\n      this._currentRun = Promise\n        .bind(this)\n        .cancellable()\n        .then(function() {\n          return this._task();\n        })\n        .then(function(result) {\n          results.result = result;\n        })\n        .caught(Promise.CancellationError, function() {\n          // Let it be. Don't want it to trickle into the results.\n        })\n        .caught(function(err) {\n          results.err = err;\n        })\n        .lastly(function() {\n          this._currentRun = null;\n          this._notifyResults(results);\n          this._scheduleNext();\n        });\n    },\n\n\n    _notifyResults: function(results) {\n      this._schedulerRef.get().runSoon(_.bind(function() {\n\n        if (this._stateGuard.applied(\"disposed\") || !this._stateGuard.applied(\"started\")) {\n          return;\n        }\n\n        if (Log.isTraceEnabled()) {\n          Log.trace(\"Notifying results\", results);\n        }\n\n        this._channel.publish(this, results);\n      }, this));\n    },\n\n\n    _scheduleNext: function(now) {\n      if (this._stateGuard.applied(\"disposed\") || !this._stateGuard.applied(\"started\")) {\n        return;\n      }\n      this._taskId = this._schedulerRef.get().schedule(this._runTask, now ? 0 : this._interval);\n      Log.trace(\"Scheduled task\", this._taskId);\n    },\n\n\n    _cancelPending: function() {\n      Log.trace(\"cancelPending requested, looking for pending task.\");\n      if (this._taskId) {\n        Log.trace(\"Found pending task; cancelling\", this._taskId);\n        this._schedulerRef.get().unschedule(this._taskId);\n        this._taskId = null;\n      }\n    },\n\n    _cancelOutstanding: function() {\n      Log.trace(\"cancelOutstanding requested, looking for outstanding work.\");\n      if (this._currentRun) {\n        Log.trace(\"Outstanding work found; cancelling\");\n        this._currentRun.cancel();\n        this._currentRun = null;\n      }\n    },\n\n    dispose: function(){\n      if (this._stateGuard.applied(\"disposed\")) {\n        return;\n      }\n\n      this._cancelPending();\n      this._cancelOutstanding();\n\n      this._stateGuard.apply(\"disposed\");\n    }\n  });\n\n  return Periodic;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../core/options\"),\n  require(\"../core/state-guard\"),\n  require(\"../core/channel/channel\"),\n  require(\"../core/channel/chained-channel\"),\n  require(\"../core/logging/logger\")\n);\n\n},{\"../core/channel/chained-channel\":55,\"../core/channel/channel\":56,\"../core/logging/logger\":62,\"../core/options\":63,\"../core/state-guard\":74,\"bluebird\":107,\"underscore\":174}],102:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _,\n  Promise,\n  Options,\n  Lang,\n  StateGuard,\n  Logger\n) {\n\n  var Log = Logger.create(\"Retryable\");\n\n  var DEFAULT_BACKOFF_CEILING = 60 * 1000 * 10; // 10 minutes\n\n\n  /**\n   * A device which retries the provided Promisified `task` until it completes without error, or `retries` times\n   * (default is forever). The results of the `task` are accessible via the `result()` promise, which will be fulfilled\n   * or rejected on success or error (such as Retryable.Error.MaxRetriesError or Promise.CancellationError).\n   *\n   * If an error occurs, the `task` is retried after some time, as determined by the `backoff` `strategy`, of which two\n   * are supported: `Retryable.Backoff.Linear` and `Retryable.Backoff.Exponential`. The default strategy is\n   * `Retryable.Backoff.Linear`, with the period determined by:\n   *\n   * `coefficient * attemptNum * factor`\n   *\n   * Default options for Linear backoff are: `factor` = 1, `coefficient` = 250.\n   *\n   * For `Retryable.Backoff.Exponential, the period is determined by:\n   *\n   * `coefficient * Math.pow(base, attemptNum)`\n   *\n   * Default options for Exponential backoff are: `coefficient = 250`, `base = 2`.\n   *\n   * Regardless of backoff strategy, a `backoffCeiling` can be provided. If provided, this is the upper bound of\n   * the period between unsuccessful task runs. This allows, for example, an exponential backoff up to a ceiling (e.g.,\n   * five minutes), after which point the period will simply be the ceiling (e.g., five minutes).\n   *\n   */\n  var Retryable = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Retryable.prototype, {\n    initialize: function(opts) {\n      opts = Options.fromObject(opts);\n      this._scheduler  = opts.getOrError(\"scheduler\");\n      this._task       = opts.getOrError(\"task\");\n      // If not provided, go on forever.\n      this._retries    = opts.getOrElse(\"retries\");\n      this._currentTry = 0;\n      this._deferred   = Lang.deferred();\n\n      var backoff = Options.fromObject(opts.getOrElseFn(\"backoff\", function() {\n        return {\n          strategy: Retryable.Backoff.Linear,\n          factor: 1,\n          coefficient: 250\n        };\n      }));\n\n      var StrategyClass = BackoffStrategy[backoff.getOrError(\"strategy\")];\n\n      this._backoffStrategy = new StrategyClass(backoff.toObject());\n      this._backoffCeiling  = opts.getOrElse(\"backoffCeiling\", DEFAULT_BACKOFF_CEILING);\n      this._disposedGuard   = StateGuard.scoped(\"disposed\");\n\n      _.bindAll(this, \"_attempt\");\n      this._currentRun = null;\n      this._scheduler.get().runSoon(this._attempt);\n    },\n\n    dispose: function() {\n      if (this._disposedGuard.applied()) {\n        return;\n      }\n\n      if (this._currentRun) {\n        this._currentRun.cancel(new Retryable.Error.DisposedError());\n        this._currentRun = null;\n      }\n\n      this._task = null;\n\n      this._disposedGuard.apply();\n    },\n\n    result: function() {\n      return this._deferred.promise;\n    },\n\n    _attempt: function() {\n      if (this._disposedGuard.applied()) {\n        return;\n      }\n\n      this._currentRun = Promise\n        .bind(this)\n        .cancellable()\n        .then(function() {\n          return this._task();\n        })\n        .then(function(result) {\n          if (this._deferred.promise.isPending()) {\n            this._deferred.resolve(result);\n          }\n        })\n        .caught(Retryable.Error.DisposedError, function() {\n          this._deferred.promise.cancel(new Promise.CancellationError());\n        })\n        .caught(function(err) {\n          if (this._disposedGuard.applied()) {\n            Log.warn(\"Caught retryable run error, but retryable is already disposed\");\n            return;\n          }\n\n          Log.debug(\"Received error in attempt\", this._currentTry);\n          var nextTry = this._currentTry + 1;\n\n          if (this._retries >= 0 && nextTry > this._retries) {\n            Log.debug(\"Hit max number of retries:\", this._retries);\n            var e = new Retryable.Error.MaxRetriesError();\n            e.cause = err;\n            throw e;\n          }\n\n          // Schedule us up to try again;\n          this._currentRun = null;\n          this._currentTry = nextTry;\n\n          var time = this._backoffStrategy.time(this._currentTry);\n          this._scheduler.get().schedule(this._attempt, Math.min(time, this._backoffCeiling));\n        })\n        .caught(Retryable.Error.MaxRetriesError, function(err) {\n          if (this._deferred.promise.isPending()) {\n            this._deferred.reject(err.cause);\n          }\n        });\n    }\n  });\n\n  _.extend(Retryable, {\n    Backoff: {\n      Linear:      \"linear\",\n      Exponential: \"exponential\"\n    },\n    Error: {\n      DisposedError: Lang.makeErrorClass(\"DisposedError\", \"Retryable was disposed\"),\n      MaxRetriesError: Lang.makeErrorClass(\"MaxRetriesError\", \"Retryable was retried too many times\")\n    }\n  })\n\n  var BackoffStrategy = (function() {\n    var Linear = function() {\n      this.initialize.apply(this, arguments);\n    };\n\n    _.extend(Linear.prototype, {\n      initialize: function(opts) {\n        opts = Options.fromObject(opts);\n        this._factor        = opts.getOrElse(\"factor\", 1);\n        this._coefficient   = opts.getOrElse(\"coefficient\", 250);\n      },\n\n      time: function(iteration) {\n        return this._factor * this._coefficient * iteration;\n      }\n    });\n\n    var Exponential = function() {\n      this.initialize.apply(this, arguments);\n    };\n\n    _.extend(Exponential.prototype, {\n      initialize: function(opts) {\n        opts = Options.fromObject(opts);\n\n        this._base        = opts.getOrElse(\"base\", 2);\n        this._coefficient = opts.getOrElse(\"coefficient\", 250);\n      },\n\n      time: function(iteration) {\n        return this._coefficient * (Math.pow(this._base, iteration));\n      }\n    })\n\n\n    var backoffs = {};\n\n    backoffs[Retryable.Backoff.Linear]      = Linear;\n    backoffs[Retryable.Backoff.Exponential] = Exponential;\n\n    return backoffs;\n  }());\n\n  return Retryable;\n};\n\nmodule.exports = mod(\n  require(\"underscore\"),\n  require(\"bluebird\"),\n  require(\"../core/options\"),\n  require(\"../core/lang\"),\n  require(\"../core/state-guard\"),\n  require(\"../core/logging/logger\")\n);\n\n},{\"../core/lang\":60,\"../core/logging/logger\":62,\"../core/options\":63,\"../core/state-guard\":74,\"bluebird\":107,\"underscore\":174}],103:[function(require,module,exports){\n/*global require: false, module: false */\n\"use strict\";\n\nvar mod = function(\n  _\n) {\n\n  /**\n   * A simple timer.\n   *\n   * Start it, stop it, get the delta.\n   *\n   * Or, start it, and repeatedly call `lap` for the time between the last `lap` call and now.\n   *\n   */\n  var Timer = function() {\n    this.initialize.apply(this, arguments);\n  };\n\n  _.extend(Timer.prototype, {\n    initialize: function() {\n      this._startTime = null;\n      this._endTime = null;\n      this._lastLap = null;\n    },\n\n\n    start: function() {\n      this._startTime = this._lastLap = +new Date();\n      return this;\n    },\n\n\n    stop: function() {\n      this._endTime = +new Date();\n      return this;\n    },\n\n    lap: function() {\n      if (!this._lastLap) return 0;\n\n      var oldLastLap = this._lastLap;\n      this._lastLap = +new Date();\n      return (this._lastLap - oldLastLap);\n    },\n\n\n    delta: function() {\n      return (this._endTime - this._startTime);\n    }\n  });\n\n  return Timer;\n};\n\nmodule.exports = mod(\n  require(\"underscore\")\n);\n\n},{\"underscore\":174}],104:[function(require,module,exports){\nmodule.exports = function(c) {};\n\n},{}],105:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise) {\nvar SomePromiseArray = Promise._SomePromiseArray;\nfunction Promise$_Any(promises) {\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    if (promise.isRejected()) {\n        return promise;\n    }\n    ret.setHowMany(1);\n    ret.setUnwrap();\n    ret.init();\n    return promise;\n}\n\nPromise.any = function Promise$Any(promises) {\n    return Promise$_Any(promises);\n};\n\nPromise.prototype.any = function Promise$any() {\n    return Promise$_Any(this);\n};\n\n};\n\n},{}],106:[function(require,module,exports){\n(function (process){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar schedule = require(\"./schedule.js\");\nvar Queue = require(\"./queue.js\");\nvar errorObj = require(\"./util.js\").errorObj;\nvar tryCatch1 = require(\"./util.js\").tryCatch1;\nvar _process = typeof process !== \"undefined\" ? process : void 0;\n\nfunction Async() {\n    this._isTickUsed = false;\n    this._schedule = schedule;\n    this._length = 0;\n    this._lateBuffer = new Queue(16);\n    this._functionBuffer = new Queue(65536);\n    var self = this;\n    this.consumeFunctionBuffer = function Async$consumeFunctionBuffer() {\n        self._consumeFunctionBuffer();\n    };\n}\n\nAsync.prototype.haveItemsQueued = function Async$haveItemsQueued() {\n    return this._length > 0;\n};\n\nAsync.prototype.invokeLater = function Async$invokeLater(fn, receiver, arg) {\n    if (_process !== void 0 &&\n        _process.domain != null &&\n        !fn.domain) {\n        fn = _process.domain.bind(fn);\n    }\n    this._lateBuffer.push(fn, receiver, arg);\n    this._queueTick();\n};\n\nAsync.prototype.invoke = function Async$invoke(fn, receiver, arg) {\n    if (_process !== void 0 &&\n        _process.domain != null &&\n        !fn.domain) {\n        fn = _process.domain.bind(fn);\n    }\n    var functionBuffer = this._functionBuffer;\n    functionBuffer.push(fn, receiver, arg);\n    this._length = functionBuffer.length();\n    this._queueTick();\n};\n\nAsync.prototype._consumeFunctionBuffer =\nfunction Async$_consumeFunctionBuffer() {\n    var functionBuffer = this._functionBuffer;\n    while (functionBuffer.length() > 0) {\n        var fn = functionBuffer.shift();\n        var receiver = functionBuffer.shift();\n        var arg = functionBuffer.shift();\n        fn.call(receiver, arg);\n    }\n    this._reset();\n    this._consumeLateBuffer();\n};\n\nAsync.prototype._consumeLateBuffer = function Async$_consumeLateBuffer() {\n    var buffer = this._lateBuffer;\n    while(buffer.length() > 0) {\n        var fn = buffer.shift();\n        var receiver = buffer.shift();\n        var arg = buffer.shift();\n        var res = tryCatch1(fn, receiver, arg);\n        if (res === errorObj) {\n            this._queueTick();\n            if (fn.domain != null) {\n                fn.domain.emit(\"error\", res.e);\n            } else {\n                throw res.e;\n            }\n        }\n    }\n};\n\nAsync.prototype._queueTick = function Async$_queue() {\n    if (!this._isTickUsed) {\n        this._schedule(this.consumeFunctionBuffer);\n        this._isTickUsed = true;\n    }\n};\n\nAsync.prototype._reset = function Async$_reset() {\n    this._isTickUsed = false;\n    this._length = 0;\n};\n\nmodule.exports = new Async();\n\n}).call(this,require('_process'))\n},{\"./queue.js\":129,\"./schedule.js\":132,\"./util.js\":139,\"_process\":11}],107:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar Promise = require(\"./promise.js\")();\nmodule.exports = Promise;\n},{\"./promise.js\":124}],108:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar cr = Object.create;\nif (cr) {\n    var callerCache = cr(null);\n    var getterCache = cr(null);\n    callerCache[\" size\"] = getterCache[\" size\"] = 0;\n}\n\nmodule.exports = function(Promise) {\nvar util = require(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar isIdentifier = util.isIdentifier;\n\nfunction makeMethodCaller (methodName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict'                                                         \\n\\\n        var len = this.length;                                               \\n\\\n        switch(len) {                                                        \\n\\\n            case 1: return obj.methodName(this[0]);                          \\n\\\n            case 2: return obj.methodName(this[0], this[1]);                 \\n\\\n            case 3: return obj.methodName(this[0], this[1], this[2]);        \\n\\\n            case 0: return obj.methodName();                                 \\n\\\n            default: return obj.methodName.apply(obj, this);                 \\n\\\n        }                                                                    \\n\\\n        \".replace(/methodName/g, methodName));\n}\n\nfunction makeGetter (propertyName) {\n    return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n}\n\nfunction getCompiled(name, compiler, cache) {\n    var ret = cache[name];\n    if (typeof ret !== \"function\") {\n        if (!isIdentifier(name)) {\n            return null;\n        }\n        ret = compiler(name);\n        cache[name] = ret;\n        cache[\" size\"]++;\n        if (cache[\" size\"] > 512) {\n            var keys = Object.keys(cache);\n            for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n            cache[\" size\"] = keys.length - 256;\n        }\n    }\n    return ret;\n}\n\nfunction getMethodCaller(name) {\n    return getCompiled(name, makeMethodCaller, callerCache);\n}\n\nfunction getGetter(name) {\n    return getCompiled(name, makeGetter, getterCache);\n}\n\nfunction caller(obj) {\n    return obj[this.pop()].apply(obj, this);\n}\nPromise.prototype.call = function Promise$call(methodName) {\n    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n    if (canEvaluate) {\n        var maybeCaller = getMethodCaller(methodName);\n        if (maybeCaller !== null) {\n            return this._then(maybeCaller, void 0, void 0, args, void 0);\n        }\n    }\n    args.push(methodName);\n    return this._then(caller, void 0, void 0, args, void 0);\n};\n\nfunction namedGetter(obj) {\n    return obj[this];\n}\nfunction indexedGetter(obj) {\n    return obj[this];\n}\nPromise.prototype.get = function Promise$get(propertyName) {\n    var isIndex = (typeof propertyName === \"number\");\n    var getter;\n    if (!isIndex) {\n        if (canEvaluate) {\n            var maybeGetter = getGetter(propertyName);\n            getter = maybeGetter !== null ? maybeGetter : namedGetter;\n        } else {\n            getter = namedGetter;\n        }\n    } else {\n        getter = indexedGetter;\n    }\n    return this._then(getter, void 0, void 0, propertyName, void 0);\n};\n};\n\n},{\"./util.js\":139}],109:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar errors = require(\"./errors.js\");\nvar canAttach = errors.canAttach;\nvar async = require(\"./async.js\");\nvar CancellationError = errors.CancellationError;\n\nPromise.prototype._cancel = function Promise$_cancel(reason) {\n    if (!this.isCancellable()) return this;\n    var parent;\n    var promiseToReject = this;\n    while ((parent = promiseToReject._cancellationParent) !== void 0 &&\n        parent.isCancellable()) {\n        promiseToReject = parent;\n    }\n    promiseToReject._attachExtraTrace(reason);\n    promiseToReject._rejectUnchecked(reason);\n};\n\nPromise.prototype.cancel = function Promise$cancel(reason) {\n    if (!this.isCancellable()) return this;\n    reason = reason !== void 0\n        ? (canAttach(reason) ? reason : new Error(reason + \"\"))\n        : new CancellationError();\n    async.invokeLater(this._cancel, this, reason);\n    return this;\n};\n\nPromise.prototype.cancellable = function Promise$cancellable() {\n    if (this._cancellable()) return this;\n    this._setCancellable();\n    this._cancellationParent = void 0;\n    return this;\n};\n\nPromise.prototype.uncancellable = function Promise$uncancellable() {\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 2 | 4);\n    ret._follow(this);\n    ret._unsetCancellable();\n    return ret;\n};\n\nPromise.prototype.fork =\nfunction Promise$fork(didFulfill, didReject, didProgress) {\n    var ret = this._then(didFulfill, didReject, didProgress,\n                         void 0, void 0);\n\n    ret._setCancellable();\n    ret._cancellationParent = void 0;\n    return ret;\n};\n};\n\n},{\"./async.js\":106,\"./errors.js\":114}],110:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function() {\nvar inherits = require(\"./util.js\").inherits;\nvar defineProperty = require(\"./es5.js\").defineProperty;\n\nvar rignore = new RegExp(\n    \"\\\\b(?:[a-zA-Z0-9.]+\\\\$_\\\\w+|\" +\n    \"tryCatch(?:1|2|3|4|Apply)|new \\\\w*PromiseArray|\" +\n    \"\\\\w*PromiseArray\\\\.\\\\w*PromiseArray|\" +\n    \"setTimeout|CatchFilter\\\\$_\\\\w+|makeNodePromisified|processImmediate|\" +\n    \"process._tickCallback|nextTick|Async\\\\$\\\\w+)\\\\b\"\n);\n\nvar rtraceline = null;\nvar formatStack = null;\n\nfunction formatNonError(obj) {\n    var str;\n    if (typeof obj === \"function\") {\n        str = \"[function \" +\n            (obj.name || \"anonymous\") +\n            \"]\";\n    } else {\n        str = obj.toString();\n        var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n        if (ruselessToString.test(str)) {\n            try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n            }\n            catch(e) {\n\n            }\n        }\n        if (str.length === 0) {\n            str = \"(empty array)\";\n        }\n    }\n    return (\"(<\" + snip(str) + \">, no stack trace)\");\n}\n\nfunction snip(str) {\n    var maxChars = 41;\n    if (str.length < maxChars) {\n        return str;\n    }\n    return str.substr(0, maxChars - 3) + \"...\";\n}\n\nfunction CapturedTrace(ignoreUntil, isTopLevel) {\n    this.captureStackTrace(CapturedTrace, isTopLevel);\n\n}\ninherits(CapturedTrace, Error);\n\nCapturedTrace.prototype.captureStackTrace =\nfunction CapturedTrace$captureStackTrace(ignoreUntil, isTopLevel) {\n    captureStackTrace(this, ignoreUntil, isTopLevel);\n};\n\nCapturedTrace.possiblyUnhandledRejection =\nfunction CapturedTrace$PossiblyUnhandledRejection(reason) {\n    if (typeof console === \"object\") {\n        var message;\n        if (typeof reason === \"object\" || typeof reason === \"function\") {\n            var stack = reason.stack;\n            message = \"Possibly unhandled \" + formatStack(stack, reason);\n        } else {\n            message = \"Possibly unhandled \" + String(reason);\n        }\n        if (typeof console.error === \"function\" ||\n            typeof console.error === \"object\") {\n            console.error(message);\n        } else if (typeof console.log === \"function\" ||\n            typeof console.log === \"object\") {\n            console.log(message);\n        }\n    }\n};\n\nCapturedTrace.combine = function CapturedTrace$Combine(current, prev) {\n    var curLast = current.length - 1;\n    for (var i = prev.length - 1; i >= 0; --i) {\n        var line = prev[i];\n        if (current[curLast] === line) {\n            current.pop();\n            curLast--;\n        } else {\n            break;\n        }\n    }\n\n    current.push(\"From previous event:\");\n    var lines = current.concat(prev);\n\n    var ret = [];\n\n    for (var i = 0, len = lines.length; i < len; ++i) {\n\n        if ((rignore.test(lines[i]) ||\n            (i > 0 && !rtraceline.test(lines[i])) &&\n            lines[i] !== \"From previous event:\")\n       ) {\n            continue;\n        }\n        ret.push(lines[i]);\n    }\n    return ret;\n};\n\nCapturedTrace.protectErrorMessageNewlines = function(stack) {\n    for (var i = 0; i < stack.length; ++i) {\n        if (rtraceline.test(stack[i])) {\n            break;\n        }\n    }\n\n    if (i <= 1) return;\n\n    var errorMessageLines = [];\n    for (var j = 0; j < i; ++j) {\n        errorMessageLines.push(stack.shift());\n    }\n    stack.unshift(errorMessageLines.join(\"\\u0002\\u0000\\u0001\"));\n};\n\nCapturedTrace.isSupported = function CapturedTrace$IsSupported() {\n    return typeof captureStackTrace === \"function\";\n};\n\nvar captureStackTrace = (function stackDetection() {\n    if (typeof Error.stackTraceLimit === \"number\" &&\n        typeof Error.captureStackTrace === \"function\") {\n        rtraceline = /^\\s*at\\s*/;\n        formatStack = function(stack, error) {\n            if (typeof stack === \"string\") return stack;\n\n            if (error.name !== void 0 &&\n                error.message !== void 0) {\n                return error.name + \". \" + error.message;\n            }\n            return formatNonError(error);\n\n\n        };\n        var captureStackTrace = Error.captureStackTrace;\n        return function CapturedTrace$_captureStackTrace(\n            receiver, ignoreUntil) {\n            captureStackTrace(receiver, ignoreUntil);\n        };\n    }\n    var err = new Error();\n\n    if (typeof err.stack === \"string\" &&\n        typeof \"\".startsWith === \"function\" &&\n        (err.stack.startsWith(\"stackDetection@\")) &&\n        stackDetection.name === \"stackDetection\") {\n\n        defineProperty(Error, \"stackTraceLimit\", {\n            writable: true,\n            enumerable: false,\n            configurable: false,\n            value: 25\n        });\n        rtraceline = /@/;\n        var rline = /[@\\n]/;\n\n        formatStack = function(stack, error) {\n            if (typeof stack === \"string\") {\n                return (error.name + \". \" + error.message + \"\\n\" + stack);\n            }\n\n            if (error.name !== void 0 &&\n                error.message !== void 0) {\n                return error.name + \". \" + error.message;\n            }\n            return formatNonError(error);\n        };\n\n        return function captureStackTrace(o) {\n            var stack = new Error().stack;\n            var split = stack.split(rline);\n            var len = split.length;\n            var ret = \"\";\n            for (var i = 0; i < len; i += 2) {\n                ret += split[i];\n                ret += \"@\";\n                ret += split[i + 1];\n                ret += \"\\n\";\n            }\n            o.stack = ret;\n        };\n    } else {\n        formatStack = function(stack, error) {\n            if (typeof stack === \"string\") return stack;\n\n            if ((typeof error === \"object\" ||\n                typeof error === \"function\") &&\n                error.name !== void 0 &&\n                error.message !== void 0) {\n                return error.name + \". \" + error.message;\n            }\n            return formatNonError(error);\n        };\n\n        return null;\n    }\n})();\n\nreturn CapturedTrace;\n};\n\n},{\"./es5.js\":116,\"./util.js\":139}],111:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(NEXT_FILTER) {\nvar util = require(\"./util.js\");\nvar errors = require(\"./errors.js\");\nvar tryCatch1 = util.tryCatch1;\nvar errorObj = util.errorObj;\nvar keys = require(\"./es5.js\").keys;\nvar TypeError = errors.TypeError;\n\nfunction CatchFilter(instances, callback, promise) {\n    this._instances = instances;\n    this._callback = callback;\n    this._promise = promise;\n}\n\nfunction CatchFilter$_safePredicate(predicate, e) {\n    var safeObject = {};\n    var retfilter = tryCatch1(predicate, safeObject, e);\n\n    if (retfilter === errorObj) return retfilter;\n\n    var safeKeys = keys(safeObject);\n    if (safeKeys.length) {\n        errorObj.e = new TypeError(\n            \"Catch filter must inherit from Error \"\n          + \"or be a simple predicate function\");\n        return errorObj;\n    }\n    return retfilter;\n}\n\nCatchFilter.prototype.doFilter = function CatchFilter$_doFilter(e) {\n    var cb = this._callback;\n    var promise = this._promise;\n    var boundTo = promise._boundTo;\n    for (var i = 0, len = this._instances.length; i < len; ++i) {\n        var item = this._instances[i];\n        var itemIsErrorType = item === Error ||\n            (item != null && item.prototype instanceof Error);\n\n        if (itemIsErrorType && e instanceof item) {\n            var ret = tryCatch1(cb, boundTo, e);\n            if (ret === errorObj) {\n                NEXT_FILTER.e = ret.e;\n                return NEXT_FILTER;\n            }\n            return ret;\n        } else if (typeof item === \"function\" && !itemIsErrorType) {\n            var shouldHandle = CatchFilter$_safePredicate(item, e);\n            if (shouldHandle === errorObj) {\n                var trace = errors.canAttach(errorObj.e)\n                    ? errorObj.e\n                    : new Error(errorObj.e + \"\");\n                this._promise._attachExtraTrace(trace);\n                e = errorObj.e;\n                break;\n            } else if (shouldHandle) {\n                var ret = tryCatch1(cb, boundTo, e);\n                if (ret === errorObj) {\n                    NEXT_FILTER.e = ret.e;\n                    return NEXT_FILTER;\n                }\n                return ret;\n            }\n        }\n    }\n    NEXT_FILTER.e = e;\n    return NEXT_FILTER;\n};\n\nreturn CatchFilter;\n};\n\n},{\"./errors.js\":114,\"./es5.js\":116,\"./util.js\":139}],112:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar util = require(\"./util.js\");\nvar isPrimitive = util.isPrimitive;\nvar wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;\n\nmodule.exports = function(Promise) {\nvar returner = function Promise$_returner() {\n    return this;\n};\nvar thrower = function Promise$_thrower() {\n    throw this;\n};\n\nvar wrapper = function Promise$_wrapper(value, action) {\n    if (action === 1) {\n        return function Promise$_thrower() {\n            throw value;\n        };\n    } else if (action === 2) {\n        return function Promise$_returner() {\n            return value;\n        };\n    }\n};\n\n\nPromise.prototype[\"return\"] =\nPromise.prototype.thenReturn =\nfunction Promise$thenReturn(value) {\n    if (wrapsPrimitiveReceiver && isPrimitive(value)) {\n        return this._then(\n            wrapper(value, 2),\n            void 0,\n            void 0,\n            void 0,\n            void 0\n       );\n    }\n    return this._then(returner, void 0, void 0, value, void 0);\n};\n\nPromise.prototype[\"throw\"] =\nPromise.prototype.thenThrow =\nfunction Promise$thenThrow(reason) {\n    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {\n        return this._then(\n            wrapper(reason, 1),\n            void 0,\n            void 0,\n            void 0,\n            void 0\n       );\n    }\n    return this._then(thrower, void 0, void 0, reason, void 0);\n};\n};\n\n},{\"./util.js\":139}],113:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseReduce = Promise.reduce;\n\nPromise.prototype.each = function Promise$each(fn) {\n    return PromiseReduce(this, fn, null, INTERNAL);\n};\n\nPromise.each = function Promise$Each(promises, fn) {\n    return PromiseReduce(promises, fn, null, INTERNAL);\n};\n};\n\n},{}],114:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar Objectfreeze = require(\"./es5.js\").freeze;\nvar util = require(\"./util.js\");\nvar inherits = util.inherits;\nvar notEnumerableProp = util.notEnumerableProp;\n\nfunction markAsOriginatingFromRejection(e) {\n    try {\n        notEnumerableProp(e, \"isOperational\", true);\n    }\n    catch(ignore) {}\n}\n\nfunction originatesFromRejection(e) {\n    if (e == null) return false;\n    return ((e instanceof OperationalError) ||\n        e[\"isOperational\"] === true);\n}\n\nfunction isError(obj) {\n    return obj instanceof Error;\n}\n\nfunction canAttach(obj) {\n    return isError(obj);\n}\n\nfunction subError(nameProperty, defaultMessage) {\n    function SubError(message) {\n        if (!(this instanceof SubError)) return new SubError(message);\n        this.message = typeof message === \"string\" ? message : defaultMessage;\n        this.name = nameProperty;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n    inherits(SubError, Error);\n    return SubError;\n}\n\nvar _TypeError, _RangeError;\nvar CancellationError = subError(\"CancellationError\", \"cancellation error\");\nvar TimeoutError = subError(\"TimeoutError\", \"timeout error\");\nvar AggregateError = subError(\"AggregateError\", \"aggregate error\");\ntry {\n    _TypeError = TypeError;\n    _RangeError = RangeError;\n} catch(e) {\n    _TypeError = subError(\"TypeError\", \"type error\");\n    _RangeError = subError(\"RangeError\", \"range error\");\n}\n\nvar methods = (\"join pop push shift unshift slice filter forEach some \" +\n    \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\nfor (var i = 0; i < methods.length; ++i) {\n    if (typeof Array.prototype[methods[i]] === \"function\") {\n        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n    }\n}\n\nAggregateError.prototype.length = 0;\nAggregateError.prototype[\"isOperational\"] = true;\nvar level = 0;\nAggregateError.prototype.toString = function() {\n    var indent = Array(level * 4 + 1).join(\" \");\n    var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n    level++;\n    indent = Array(level * 4 + 1).join(\" \");\n    for (var i = 0; i < this.length; ++i) {\n        var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n        var lines = str.split(\"\\n\");\n        for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n        }\n        str = lines.join(\"\\n\");\n        ret += str + \"\\n\";\n    }\n    level--;\n    return ret;\n};\n\nfunction OperationalError(message) {\n    this.name = \"OperationalError\";\n    this.message = message;\n    this.cause = message;\n    this[\"isOperational\"] = true;\n\n    if (message instanceof Error) {\n        this.message = message.message;\n        this.stack = message.stack;\n    } else if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n    }\n\n}\ninherits(OperationalError, Error);\n\nvar key = \"__BluebirdErrorTypes__\";\nvar errorTypes = Error[key];\nif (!errorTypes) {\n    errorTypes = Objectfreeze({\n        CancellationError: CancellationError,\n        TimeoutError: TimeoutError,\n        OperationalError: OperationalError,\n        RejectionError: OperationalError,\n        AggregateError: AggregateError\n    });\n    notEnumerableProp(Error, key, errorTypes);\n}\n\nmodule.exports = {\n    Error: Error,\n    TypeError: _TypeError,\n    RangeError: _RangeError,\n    CancellationError: errorTypes.CancellationError,\n    OperationalError: errorTypes.OperationalError,\n    TimeoutError: errorTypes.TimeoutError,\n    AggregateError: errorTypes.AggregateError,\n    originatesFromRejection: originatesFromRejection,\n    markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n    canAttach: canAttach\n};\n\n},{\"./es5.js\":116,\"./util.js\":139}],115:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise) {\nvar TypeError = require('./errors.js').TypeError;\n\nfunction apiRejection(msg) {\n    var error = new TypeError(msg);\n    var ret = Promise.rejected(error);\n    var parent = ret._peekContext();\n    if (parent != null) {\n        parent._attachExtraTrace(error);\n    }\n    return ret;\n}\n\nreturn apiRejection;\n};\n\n},{\"./errors.js\":114}],116:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\nvar isES5 = (function(){\n    \"use strict\";\n    return this === void 0;\n})();\n\nif (isES5) {\n    module.exports = {\n        freeze: Object.freeze,\n        defineProperty: Object.defineProperty,\n        keys: Object.keys,\n        getPrototypeOf: Object.getPrototypeOf,\n        isArray: Array.isArray,\n        isES5: isES5\n    };\n} else {\n    var has = {}.hasOwnProperty;\n    var str = {}.toString;\n    var proto = {}.constructor.prototype;\n\n    var ObjectKeys = function ObjectKeys(o) {\n        var ret = [];\n        for (var key in o) {\n            if (has.call(o, key)) {\n                ret.push(key);\n            }\n        }\n        return ret;\n    }\n\n    var ObjectDefineProperty = function ObjectDefineProperty(o, key, desc) {\n        o[key] = desc.value;\n        return o;\n    }\n\n    var ObjectFreeze = function ObjectFreeze(obj) {\n        return obj;\n    }\n\n    var ObjectGetPrototypeOf = function ObjectGetPrototypeOf(obj) {\n        try {\n            return Object(obj).constructor.prototype;\n        }\n        catch (e) {\n            return proto;\n        }\n    }\n\n    var ArrayIsArray = function ArrayIsArray(obj) {\n        try {\n            return str.call(obj) === \"[object Array]\";\n        }\n        catch(e) {\n            return false;\n        }\n    }\n\n    module.exports = {\n        isArray: ArrayIsArray,\n        keys: ObjectKeys,\n        defineProperty: ObjectDefineProperty,\n        freeze: ObjectFreeze,\n        getPrototypeOf: ObjectGetPrototypeOf,\n        isES5: isES5\n    };\n}\n\n},{}],117:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar PromiseMap = Promise.map;\n\nPromise.prototype.filter = function Promise$filter(fn, options) {\n    return PromiseMap(this, fn, options, INTERNAL);\n};\n\nPromise.filter = function Promise$Filter(promises, fn, options) {\n    return PromiseMap(promises, fn, options, INTERNAL);\n};\n};\n\n},{}],118:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, NEXT_FILTER, cast) {\nvar util = require(\"./util.js\");\nvar wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;\nvar isPrimitive = util.isPrimitive;\nvar thrower = util.thrower;\n\nfunction returnThis() {\n    return this;\n}\nfunction throwThis() {\n    throw this;\n}\nfunction return$(r) {\n    return function Promise$_returner() {\n        return r;\n    };\n}\nfunction throw$(r) {\n    return function Promise$_thrower() {\n        throw r;\n    };\n}\nfunction promisedFinally(ret, reasonOrValue, isFulfilled) {\n    var then;\n    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {\n        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);\n    } else {\n        then = isFulfilled ? returnThis : throwThis;\n    }\n    return ret._then(then, thrower, void 0, reasonOrValue, void 0);\n}\n\nfunction finallyHandler(reasonOrValue) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundTo)\n                    : handler();\n\n    if (ret !== void 0) {\n        var maybePromise = cast(ret, void 0);\n        if (maybePromise instanceof Promise) {\n            return promisedFinally(maybePromise, reasonOrValue,\n                                    promise.isFulfilled());\n        }\n    }\n\n    if (promise.isRejected()) {\n        NEXT_FILTER.e = reasonOrValue;\n        return NEXT_FILTER;\n    } else {\n        return reasonOrValue;\n    }\n}\n\nfunction tapHandler(value) {\n    var promise = this.promise;\n    var handler = this.handler;\n\n    var ret = promise._isBound()\n                    ? handler.call(promise._boundTo, value)\n                    : handler(value);\n\n    if (ret !== void 0) {\n        var maybePromise = cast(ret, void 0);\n        if (maybePromise instanceof Promise) {\n            return promisedFinally(maybePromise, value, true);\n        }\n    }\n    return value;\n}\n\nPromise.prototype._passThroughHandler =\nfunction Promise$_passThroughHandler(handler, isFinally) {\n    if (typeof handler !== \"function\") return this.then();\n\n    var promiseAndHandler = {\n        promise: this,\n        handler: handler\n    };\n\n    return this._then(\n            isFinally ? finallyHandler : tapHandler,\n            isFinally ? finallyHandler : void 0, void 0,\n            promiseAndHandler, void 0);\n};\n\nPromise.prototype.lastly =\nPromise.prototype[\"finally\"] = function Promise$finally(handler) {\n    return this._passThroughHandler(handler, true);\n};\n\nPromise.prototype.tap = function Promise$tap(handler) {\n    return this._passThroughHandler(handler, false);\n};\n};\n\n},{\"./util.js\":139}],119:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, apiRejection, INTERNAL, cast) {\nvar errors = require(\"./errors.js\");\nvar TypeError = errors.TypeError;\nvar deprecated = require(\"./util.js\").deprecated;\nvar util = require(\"./util.js\");\nvar errorObj = util.errorObj;\nvar tryCatch1 = util.tryCatch1;\nvar yieldHandlers = [];\n\nfunction promiseFromYieldHandler(value, yieldHandlers) {\n    var _errorObj = errorObj;\n    var _Promise = Promise;\n    var len = yieldHandlers.length;\n    for (var i = 0; i < len; ++i) {\n        var result = tryCatch1(yieldHandlers[i], void 0, value);\n        if (result === _errorObj) {\n            return _Promise.reject(_errorObj.e);\n        }\n        var maybePromise = cast(result, promiseFromYieldHandler);\n        if (maybePromise instanceof _Promise) return maybePromise;\n    }\n    return null;\n}\n\nfunction PromiseSpawn(generatorFunction, receiver, yieldHandler) {\n    var promise = this._promise = new Promise(INTERNAL);\n    promise._setTrace(void 0);\n    this._generatorFunction = generatorFunction;\n    this._receiver = receiver;\n    this._generator = void 0;\n    this._yieldHandlers = typeof yieldHandler === \"function\"\n        ? [yieldHandler].concat(yieldHandlers)\n        : yieldHandlers;\n}\n\nPromiseSpawn.prototype.promise = function PromiseSpawn$promise() {\n    return this._promise;\n};\n\nPromiseSpawn.prototype._run = function PromiseSpawn$_run() {\n    this._generator = this._generatorFunction.call(this._receiver);\n    this._receiver =\n        this._generatorFunction = void 0;\n    this._next(void 0);\n};\n\nPromiseSpawn.prototype._continue = function PromiseSpawn$_continue(result) {\n    if (result === errorObj) {\n        this._generator = void 0;\n        var trace = errors.canAttach(result.e)\n            ? result.e : new Error(result.e + \"\");\n        this._promise._attachExtraTrace(trace);\n        this._promise._reject(result.e, trace);\n        return;\n    }\n\n    var value = result.value;\n    if (result.done === true) {\n        this._generator = void 0;\n        if (!this._promise._tryFollow(value)) {\n            this._promise._fulfill(value);\n        }\n    } else {\n        var maybePromise = cast(value, void 0);\n        if (!(maybePromise instanceof Promise)) {\n            maybePromise =\n                promiseFromYieldHandler(maybePromise, this._yieldHandlers);\n            if (maybePromise === null) {\n                this._throw(new TypeError(\"A value was yielded that could not be treated as a promise\"));\n                return;\n            }\n        }\n        maybePromise._then(\n            this._next,\n            this._throw,\n            void 0,\n            this,\n            null\n       );\n    }\n};\n\nPromiseSpawn.prototype._throw = function PromiseSpawn$_throw(reason) {\n    if (errors.canAttach(reason))\n        this._promise._attachExtraTrace(reason);\n    this._continue(\n        tryCatch1(this._generator[\"throw\"], this._generator, reason)\n   );\n};\n\nPromiseSpawn.prototype._next = function PromiseSpawn$_next(value) {\n    this._continue(\n        tryCatch1(this._generator.next, this._generator, value)\n   );\n};\n\nPromise.coroutine =\nfunction Promise$Coroutine(generatorFunction, options) {\n    if (typeof generatorFunction !== \"function\") {\n        throw new TypeError(\"generatorFunction must be a function\");\n    }\n    var yieldHandler = Object(options).yieldHandler;\n    var PromiseSpawn$ = PromiseSpawn;\n    return function () {\n        var generator = generatorFunction.apply(this, arguments);\n        var spawn = new PromiseSpawn$(void 0, void 0, yieldHandler);\n        spawn._generator = generator;\n        spawn._next(void 0);\n        return spawn.promise();\n    };\n};\n\nPromise.coroutine.addYieldHandler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\");\n    yieldHandlers.push(fn);\n};\n\nPromise.spawn = function Promise$Spawn(generatorFunction) {\n    deprecated(\"Promise.spawn is deprecated. Use Promise.coroutine instead.\");\n    if (typeof generatorFunction !== \"function\") {\n        return apiRejection(\"generatorFunction must be a function\");\n    }\n    var spawn = new PromiseSpawn(generatorFunction, this);\n    var ret = spawn.promise();\n    spawn._run(Promise.spawn);\n    return ret;\n};\n};\n\n},{\"./errors.js\":114,\"./util.js\":139}],120:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, cast, INTERNAL) {\nvar util = require(\"./util.js\");\nvar canEvaluate = util.canEvaluate;\nvar tryCatch1 = util.tryCatch1;\nvar errorObj = util.errorObj;\n\n\nif (canEvaluate) {\n    var thenCallback = function(i) {\n        return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n    };\n\n    var caller = function(count) {\n        var values = [];\n        for (var i = 1; i <= count; ++i) values.push(\"holder.p\" + i);\n        return new Function(\"holder\", \"                                      \\n\\\n            'use strict';                                                    \\n\\\n            var callback = holder.fn;                                        \\n\\\n            return callback(values);                                         \\n\\\n            \".replace(/values/g, values.join(\", \")));\n    };\n    var thenCallbacks = [];\n    var callers = [void 0];\n    for (var i = 1; i <= 5; ++i) {\n        thenCallbacks.push(thenCallback(i));\n        callers.push(caller(i));\n    }\n\n    var Holder = function(total, fn) {\n        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;\n        this.fn = fn;\n        this.total = total;\n        this.now = 0;\n    };\n\n    Holder.prototype.callers = callers;\n    Holder.prototype.checkFulfillment = function(promise) {\n        var now = this.now;\n        now++;\n        var total = this.total;\n        if (now >= total) {\n            var handler = this.callers[total];\n            var ret = tryCatch1(handler, void 0, this);\n            if (ret === errorObj) {\n                promise._rejectUnchecked(ret.e);\n            } else if (!promise._tryFollow(ret)) {\n                promise._fulfillUnchecked(ret);\n            }\n        } else {\n            this.now = now;\n        }\n    };\n}\n\n\n\n\nPromise.join = function Promise$Join() {\n    var last = arguments.length - 1;\n    var fn;\n    if (last > 0 && typeof arguments[last] === \"function\") {\n        fn = arguments[last];\n        if (last < 6 && canEvaluate) {\n            var ret = new Promise(INTERNAL);\n            ret._setTrace(void 0);\n            var holder = new Holder(last, fn);\n            var reject = ret._reject;\n            var callbacks = thenCallbacks;\n            for (var i = 0; i < last; ++i) {\n                var maybePromise = cast(arguments[i], void 0);\n                if (maybePromise instanceof Promise) {\n                    if (maybePromise.isPending()) {\n                        maybePromise._then(callbacks[i], reject,\n                                           void 0, ret, holder);\n                    } else if (maybePromise.isFulfilled()) {\n                        callbacks[i].call(ret,\n                                          maybePromise._settledValue, holder);\n                    } else {\n                        ret._reject(maybePromise._settledValue);\n                        maybePromise._unsetRejectionIsUnhandled();\n                    }\n                } else {\n                    callbacks[i].call(ret, maybePromise, holder);\n                }\n            }\n            return ret;\n        }\n    }\n    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}\n    var ret = new PromiseArray(args).promise();\n    return fn !== void 0 ? ret.spread(fn) : ret;\n};\n\n};\n\n},{\"./util.js\":139}],121:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, PromiseArray, apiRejection, cast, INTERNAL) {\nvar util = require(\"./util.js\");\nvar tryCatch3 = util.tryCatch3;\nvar errorObj = util.errorObj;\nvar PENDING = {};\nvar EMPTY_ARRAY = [];\n\nfunction MappingPromiseArray(promises, fn, limit, _filter) {\n    this.constructor$(promises);\n    this._callback = fn;\n    this._preservedValues = _filter === INTERNAL\n        ? new Array(this.length())\n        : null;\n    this._limit = limit;\n    this._inFlight = 0;\n    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;\n    this._init$(void 0, -2);\n}\nutil.inherits(MappingPromiseArray, PromiseArray);\n\nMappingPromiseArray.prototype._init = function MappingPromiseArray$_init() {};\n\nMappingPromiseArray.prototype._promiseFulfilled =\nfunction MappingPromiseArray$_promiseFulfilled(value, index) {\n    var values = this._values;\n    if (values === null) return;\n\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var limit = this._limit;\n    if (values[index] === PENDING) {\n        values[index] = value;\n        if (limit >= 1) {\n            this._inFlight--;\n            this._drainQueue();\n            if (this._isResolved()) return;\n        }\n    } else {\n        if (limit >= 1 && this._inFlight >= limit) {\n            values[index] = value;\n            this._queue.push(index);\n            return;\n        }\n        if (preservedValues !== null) preservedValues[index] = value;\n\n        var callback = this._callback;\n        var receiver = this._promise._boundTo;\n        var ret = tryCatch3(callback, receiver, value, index, length);\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = cast(ret, void 0);\n        if (maybePromise instanceof Promise) {\n            if (maybePromise.isPending()) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = PENDING;\n                return maybePromise._proxyPromiseArray(this, index);\n            } else if (maybePromise.isFulfilled()) {\n                ret = maybePromise.value();\n            } else {\n                maybePromise._unsetRejectionIsUnhandled();\n                return this._reject(maybePromise.reason());\n            }\n        }\n        values[index] = ret;\n    }\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= length) {\n        if (preservedValues !== null) {\n            this._filter(values, preservedValues);\n        } else {\n            this._resolve(values);\n        }\n\n    }\n};\n\nMappingPromiseArray.prototype._drainQueue =\nfunction MappingPromiseArray$_drainQueue() {\n    var queue = this._queue;\n    var limit = this._limit;\n    var values = this._values;\n    while (queue.length > 0 && this._inFlight < limit) {\n        var index = queue.pop();\n        this._promiseFulfilled(values[index], index);\n    }\n};\n\nMappingPromiseArray.prototype._filter =\nfunction MappingPromiseArray$_filter(booleans, values) {\n    var len = values.length;\n    var ret = new Array(len);\n    var j = 0;\n    for (var i = 0; i < len; ++i) {\n        if (booleans[i]) ret[j++] = values[i];\n    }\n    ret.length = j;\n    this._resolve(ret);\n};\n\nMappingPromiseArray.prototype.preservedValues =\nfunction MappingPromiseArray$preserveValues() {\n    return this._preservedValues;\n};\n\nfunction map(promises, fn, options, _filter) {\n    var limit = typeof options === \"object\" && options !== null\n        ? options.concurrency\n        : 0;\n    limit = typeof limit === \"number\" &&\n        isFinite(limit) && limit >= 1 ? limit : 0;\n    return new MappingPromiseArray(promises, fn, limit, _filter);\n}\n\nPromise.prototype.map = function Promise$map(fn, options) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\");\n\n    return map(this, fn, options, null).promise();\n};\n\nPromise.map = function Promise$Map(promises, fn, options, _filter) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\");\n    return map(promises, fn, options, _filter).promise();\n};\n\n\n};\n\n},{\"./util.js\":139}],122:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise) {\nvar util = require(\"./util.js\");\nvar async = require(\"./async.js\");\nvar tryCatch2 = util.tryCatch2;\nvar tryCatch1 = util.tryCatch1;\nvar errorObj = util.errorObj;\n\nfunction thrower(r) {\n    throw r;\n}\n\nfunction Promise$_spreadAdapter(val, receiver) {\n    if (!util.isArray(val)) return Promise$_successAdapter(val, receiver);\n    var ret = util.tryCatchApply(this, [null].concat(val), receiver);\n    if (ret === errorObj) {\n        async.invokeLater(thrower, void 0, ret.e);\n    }\n}\n\nfunction Promise$_successAdapter(val, receiver) {\n    var nodeback = this;\n    var ret = val === void 0\n        ? tryCatch1(nodeback, receiver, null)\n        : tryCatch2(nodeback, receiver, null, val);\n    if (ret === errorObj) {\n        async.invokeLater(thrower, void 0, ret.e);\n    }\n}\nfunction Promise$_errorAdapter(reason, receiver) {\n    var nodeback = this;\n    var ret = tryCatch1(nodeback, receiver, reason);\n    if (ret === errorObj) {\n        async.invokeLater(thrower, void 0, ret.e);\n    }\n}\n\nPromise.prototype.nodeify = function Promise$nodeify(nodeback, options) {\n    if (typeof nodeback == \"function\") {\n        var adapter = Promise$_successAdapter;\n        if (options !== void 0 && Object(options).spread) {\n            adapter = Promise$_spreadAdapter;\n        }\n        this._then(\n            adapter,\n            Promise$_errorAdapter,\n            void 0,\n            nodeback,\n            this._boundTo\n        );\n    }\n    return this;\n};\n};\n\n},{\"./async.js\":106,\"./util.js\":139}],123:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, PromiseArray) {\nvar util = require(\"./util.js\");\nvar async = require(\"./async.js\");\nvar errors = require(\"./errors.js\");\nvar tryCatch1 = util.tryCatch1;\nvar errorObj = util.errorObj;\n\nPromise.prototype.progressed = function Promise$progressed(handler) {\n    return this._then(void 0, void 0, handler, void 0, void 0);\n};\n\nPromise.prototype._progress = function Promise$_progress(progressValue) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._progressUnchecked(progressValue);\n\n};\n\nPromise.prototype._progressHandlerAt =\nfunction Promise$_progressHandlerAt(index) {\n    return index === 0\n        ? this._progressHandler0\n        : this[(index << 2) + index - 5 + 2];\n};\n\nPromise.prototype._doProgressWith =\nfunction Promise$_doProgressWith(progression) {\n    var progressValue = progression.value;\n    var handler = progression.handler;\n    var promise = progression.promise;\n    var receiver = progression.receiver;\n\n    var ret = tryCatch1(handler, receiver, progressValue);\n    if (ret === errorObj) {\n        if (ret.e != null &&\n            ret.e.name !== \"StopProgressPropagation\") {\n            var trace = errors.canAttach(ret.e)\n                ? ret.e : new Error(ret.e + \"\");\n            promise._attachExtraTrace(trace);\n            promise._progress(ret.e);\n        }\n    } else if (ret instanceof Promise) {\n        ret._then(promise._progress, null, null, promise, void 0);\n    } else {\n        promise._progress(ret);\n    }\n};\n\n\nPromise.prototype._progressUnchecked =\nfunction Promise$_progressUnchecked(progressValue) {\n    if (!this.isPending()) return;\n    var len = this._length();\n    var progress = this._progress;\n    for (var i = 0; i < len; i++) {\n        var handler = this._progressHandlerAt(i);\n        var promise = this._promiseAt(i);\n        if (!(promise instanceof Promise)) {\n            var receiver = this._receiverAt(i);\n            if (typeof handler === \"function\") {\n                handler.call(receiver, progressValue, promise);\n            } else if (receiver instanceof Promise && receiver._isProxied()) {\n                receiver._progressUnchecked(progressValue);\n            } else if (receiver instanceof PromiseArray) {\n                receiver._promiseProgressed(progressValue, promise);\n            }\n            continue;\n        }\n\n        if (typeof handler === \"function\") {\n            async.invoke(this._doProgressWith, this, {\n                handler: handler,\n                promise: promise,\n                receiver: this._receiverAt(i),\n                value: progressValue\n            });\n        } else {\n            async.invoke(progress, promise, progressValue);\n        }\n    }\n};\n};\n\n},{\"./async.js\":106,\"./errors.js\":114,\"./util.js\":139}],124:[function(require,module,exports){\n(function (process){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar old;\nif (typeof Promise !== \"undefined\") old = Promise;\nfunction noConflict(bluebird) {\n    try { if (Promise === bluebird) Promise = old; }\n    catch (e) {}\n    return bluebird;\n}\nmodule.exports = function() {\nvar util = require(\"./util.js\");\nvar async = require(\"./async.js\");\nvar errors = require(\"./errors.js\");\n\nvar INTERNAL = function(){};\nvar APPLY = {};\nvar NEXT_FILTER = {e: null};\n\nvar cast = require(\"./thenables.js\")(Promise, INTERNAL);\nvar PromiseArray = require(\"./promise_array.js\")(Promise, INTERNAL, cast);\nvar CapturedTrace = require(\"./captured_trace.js\")();\nvar CatchFilter = require(\"./catch_filter.js\")(NEXT_FILTER);\nvar PromiseResolver = require(\"./promise_resolver.js\");\n\nvar isArray = util.isArray;\n\nvar errorObj = util.errorObj;\nvar tryCatch1 = util.tryCatch1;\nvar tryCatch2 = util.tryCatch2;\nvar tryCatchApply = util.tryCatchApply;\nvar RangeError = errors.RangeError;\nvar TypeError = errors.TypeError;\nvar CancellationError = errors.CancellationError;\nvar TimeoutError = errors.TimeoutError;\nvar OperationalError = errors.OperationalError;\nvar originatesFromRejection = errors.originatesFromRejection;\nvar markAsOriginatingFromRejection = errors.markAsOriginatingFromRejection;\nvar canAttach = errors.canAttach;\nvar thrower = util.thrower;\nvar apiRejection = require(\"./errors_api_rejection\")(Promise);\n\n\nvar makeSelfResolutionError = function Promise$_makeSelfResolutionError() {\n    return new TypeError(\"circular promise resolution chain\");\n};\n\nfunction Promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"the promise constructor requires a resolver function\");\n    }\n    if (this.constructor !== Promise) {\n        throw new TypeError(\"the promise constructor cannot be invoked directly\");\n    }\n    this._bitField = 0;\n    this._fulfillmentHandler0 = void 0;\n    this._rejectionHandler0 = void 0;\n    this._promise0 = void 0;\n    this._receiver0 = void 0;\n    this._settledValue = void 0;\n    this._boundTo = void 0;\n    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);\n}\n\nPromise.prototype.bind = function Promise$bind(thisArg) {\n    var ret = new Promise(INTERNAL);\n    ret._follow(this);\n    ret._propagateFrom(this, 2 | 1);\n    ret._setBoundTo(thisArg);\n    return ret;\n};\n\nPromise.prototype.toString = function Promise$toString() {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.caught = Promise.prototype[\"catch\"] =\nfunction Promise$catch(fn) {\n    var len = arguments.length;\n    if (len > 1) {\n        var catchInstances = new Array(len - 1),\n            j = 0, i;\n        for (i = 0; i < len - 1; ++i) {\n            var item = arguments[i];\n            if (typeof item === \"function\") {\n                catchInstances[j++] = item;\n            } else {\n                var catchFilterTypeError =\n                    new TypeError(\n                        \"A catch filter must be an error constructor \"\n                        + \"or a filter function\");\n\n                this._attachExtraTrace(catchFilterTypeError);\n                async.invoke(this._reject, this, catchFilterTypeError);\n                return;\n            }\n        }\n        catchInstances.length = j;\n        fn = arguments[i];\n\n        this._resetTrace();\n        var catchFilter = new CatchFilter(catchInstances, fn, this);\n        return this._then(void 0, catchFilter.doFilter, void 0,\n            catchFilter, void 0);\n    }\n    return this._then(void 0, fn, void 0, void 0, void 0);\n};\n\nPromise.prototype.then =\nfunction Promise$then(didFulfill, didReject, didProgress) {\n    return this._then(didFulfill, didReject, didProgress,\n        void 0, void 0);\n};\n\n\nPromise.prototype.done =\nfunction Promise$done(didFulfill, didReject, didProgress) {\n    var promise = this._then(didFulfill, didReject, didProgress,\n        void 0, void 0);\n    promise._setIsFinal();\n};\n\nPromise.prototype.spread = function Promise$spread(didFulfill, didReject) {\n    return this._then(didFulfill, didReject, void 0,\n        APPLY, void 0);\n};\n\nPromise.prototype.isCancellable = function Promise$isCancellable() {\n    return !this.isResolved() &&\n        this._cancellable();\n};\n\nPromise.prototype.toJSON = function Promise$toJSON() {\n    var ret = {\n        isFulfilled: false,\n        isRejected: false,\n        fulfillmentValue: void 0,\n        rejectionReason: void 0\n    };\n    if (this.isFulfilled()) {\n        ret.fulfillmentValue = this._settledValue;\n        ret.isFulfilled = true;\n    } else if (this.isRejected()) {\n        ret.rejectionReason = this._settledValue;\n        ret.isRejected = true;\n    }\n    return ret;\n};\n\nPromise.prototype.all = function Promise$all() {\n    return new PromiseArray(this).promise();\n};\n\n\nPromise.is = function Promise$Is(val) {\n    return val instanceof Promise;\n};\n\nPromise.all = function Promise$All(promises) {\n    return new PromiseArray(promises).promise();\n};\n\nPromise.prototype.error = function Promise$_error(fn) {\n    return this.caught(originatesFromRejection, fn);\n};\n\nPromise.prototype._resolveFromSyncValue =\nfunction Promise$_resolveFromSyncValue(value) {\n    if (value === errorObj) {\n        this._cleanValues();\n        this._setRejected();\n        this._settledValue = value.e;\n        this._ensurePossibleRejectionHandled();\n    } else {\n        var maybePromise = cast(value, void 0);\n        if (maybePromise instanceof Promise) {\n            this._follow(maybePromise);\n        } else {\n            this._cleanValues();\n            this._setFulfilled();\n            this._settledValue = value;\n        }\n    }\n};\n\nPromise.method = function Promise$_Method(fn) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"fn must be a function\");\n    }\n    return function Promise$_method() {\n        var value;\n        switch(arguments.length) {\n        case 0: value = tryCatch1(fn, this, void 0); break;\n        case 1: value = tryCatch1(fn, this, arguments[0]); break;\n        case 2: value = tryCatch2(fn, this, arguments[0], arguments[1]); break;\n        default:\n            var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}\n            value = tryCatchApply(fn, args, this); break;\n        }\n        var ret = new Promise(INTERNAL);\n        ret._setTrace(void 0);\n        ret._resolveFromSyncValue(value);\n        return ret;\n    };\n};\n\nPromise.attempt = Promise[\"try\"] = function Promise$_Try(fn, args, ctx) {\n    if (typeof fn !== \"function\") {\n        return apiRejection(\"fn must be a function\");\n    }\n    var value = isArray(args)\n        ? tryCatchApply(fn, args, ctx)\n        : tryCatch1(fn, ctx, args);\n\n    var ret = new Promise(INTERNAL);\n    ret._setTrace(void 0);\n    ret._resolveFromSyncValue(value);\n    return ret;\n};\n\nPromise.defer = Promise.pending = function Promise$Defer() {\n    var promise = new Promise(INTERNAL);\n    promise._setTrace(void 0);\n    return new PromiseResolver(promise);\n};\n\nPromise.bind = function Promise$Bind(thisArg) {\n    var ret = new Promise(INTERNAL);\n    ret._setTrace(void 0);\n    ret._setFulfilled();\n    ret._setBoundTo(thisArg);\n    return ret;\n};\n\nPromise.cast = function Promise$_Cast(obj) {\n    var ret = cast(obj, void 0);\n    if (!(ret instanceof Promise)) {\n        var val = ret;\n        ret = new Promise(INTERNAL);\n        ret._setTrace(void 0);\n        ret._setFulfilled();\n        ret._cleanValues();\n        ret._settledValue = val;\n    }\n    return ret;\n};\n\nPromise.resolve = Promise.fulfilled = Promise.cast;\n\nPromise.reject = Promise.rejected = function Promise$Reject(reason) {\n    var ret = new Promise(INTERNAL);\n    ret._setTrace(void 0);\n    markAsOriginatingFromRejection(reason);\n    ret._cleanValues();\n    ret._setRejected();\n    ret._settledValue = reason;\n    if (!canAttach(reason)) {\n        var trace = new Error(reason + \"\");\n        ret._setCarriedStackTrace(trace);\n    }\n    ret._ensurePossibleRejectionHandled();\n    return ret;\n};\n\nPromise.onPossiblyUnhandledRejection =\nfunction Promise$OnPossiblyUnhandledRejection(fn) {\n        CapturedTrace.possiblyUnhandledRejection = typeof fn === \"function\"\n                                                    ? fn : void 0;\n};\n\nvar unhandledRejectionHandled;\nPromise.onUnhandledRejectionHandled =\nfunction Promise$onUnhandledRejectionHandled(fn) {\n    unhandledRejectionHandled = typeof fn === \"function\" ? fn : void 0;\n};\n\nvar debugging = false || !!(\n    typeof process !== \"undefined\" &&\n    typeof process.execPath === \"string\" &&\n    typeof process.env === \"object\" &&\n    (process.env[\"BLUEBIRD_DEBUG\"] ||\n        process.env[\"NODE_ENV\"] === \"development\")\n);\n\n\nPromise.longStackTraces = function Promise$LongStackTraces() {\n    if (async.haveItemsQueued() &&\n        debugging === false\n   ) {\n        throw new Error(\"cannot enable long stack traces after promises have been created\");\n    }\n    debugging = CapturedTrace.isSupported();\n};\n\nPromise.hasLongStackTraces = function Promise$HasLongStackTraces() {\n    return debugging && CapturedTrace.isSupported();\n};\n\nPromise.prototype._then =\nfunction Promise$_then(\n    didFulfill,\n    didReject,\n    didProgress,\n    receiver,\n    internalData\n) {\n    var haveInternalData = internalData !== void 0;\n    var ret = haveInternalData ? internalData : new Promise(INTERNAL);\n\n    if (!haveInternalData) {\n        if (debugging) {\n            var haveSameContext = this._peekContext() === this._traceParent;\n            ret._traceParent = haveSameContext ? this._traceParent : this;\n        }\n        ret._propagateFrom(this, 7);\n    }\n\n    var callbackIndex =\n        this._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);\n\n    if (this.isResolved()) {\n        async.invoke(this._queueSettleAt, this, callbackIndex);\n    }\n\n    return ret;\n};\n\nPromise.prototype._length = function Promise$_length() {\n    return this._bitField & 262143;\n};\n\nPromise.prototype._isFollowingOrFulfilledOrRejected =\nfunction Promise$_isFollowingOrFulfilledOrRejected() {\n    return (this._bitField & 939524096) > 0;\n};\n\nPromise.prototype._isFollowing = function Promise$_isFollowing() {\n    return (this._bitField & 536870912) === 536870912;\n};\n\nPromise.prototype._setLength = function Promise$_setLength(len) {\n    this._bitField = (this._bitField & -262144) |\n        (len & 262143);\n};\n\nPromise.prototype._setFulfilled = function Promise$_setFulfilled() {\n    this._bitField = this._bitField | 268435456;\n};\n\nPromise.prototype._setRejected = function Promise$_setRejected() {\n    this._bitField = this._bitField | 134217728;\n};\n\nPromise.prototype._setFollowing = function Promise$_setFollowing() {\n    this._bitField = this._bitField | 536870912;\n};\n\nPromise.prototype._setIsFinal = function Promise$_setIsFinal() {\n    this._bitField = this._bitField | 33554432;\n};\n\nPromise.prototype._isFinal = function Promise$_isFinal() {\n    return (this._bitField & 33554432) > 0;\n};\n\nPromise.prototype._cancellable = function Promise$_cancellable() {\n    return (this._bitField & 67108864) > 0;\n};\n\nPromise.prototype._setCancellable = function Promise$_setCancellable() {\n    this._bitField = this._bitField | 67108864;\n};\n\nPromise.prototype._unsetCancellable = function Promise$_unsetCancellable() {\n    this._bitField = this._bitField & (~67108864);\n};\n\nPromise.prototype._setRejectionIsUnhandled =\nfunction Promise$_setRejectionIsUnhandled() {\n    this._bitField = this._bitField | 2097152;\n};\n\nPromise.prototype._unsetRejectionIsUnhandled =\nfunction Promise$_unsetRejectionIsUnhandled() {\n    this._bitField = this._bitField & (~2097152);\n    if (this._isUnhandledRejectionNotified()) {\n        this._unsetUnhandledRejectionIsNotified();\n        this._notifyUnhandledRejectionIsHandled();\n    }\n};\n\nPromise.prototype._isRejectionUnhandled =\nfunction Promise$_isRejectionUnhandled() {\n    return (this._bitField & 2097152) > 0;\n};\n\nPromise.prototype._setUnhandledRejectionIsNotified =\nfunction Promise$_setUnhandledRejectionIsNotified() {\n    this._bitField = this._bitField | 524288;\n};\n\nPromise.prototype._unsetUnhandledRejectionIsNotified =\nfunction Promise$_unsetUnhandledRejectionIsNotified() {\n    this._bitField = this._bitField & (~524288);\n};\n\nPromise.prototype._isUnhandledRejectionNotified =\nfunction Promise$_isUnhandledRejectionNotified() {\n    return (this._bitField & 524288) > 0;\n};\n\nPromise.prototype._setCarriedStackTrace =\nfunction Promise$_setCarriedStackTrace(capturedTrace) {\n    this._bitField = this._bitField | 1048576;\n    this._fulfillmentHandler0 = capturedTrace;\n};\n\nPromise.prototype._unsetCarriedStackTrace =\nfunction Promise$_unsetCarriedStackTrace() {\n    this._bitField = this._bitField & (~1048576);\n    this._fulfillmentHandler0 = void 0;\n};\n\nPromise.prototype._isCarryingStackTrace =\nfunction Promise$_isCarryingStackTrace() {\n    return (this._bitField & 1048576) > 0;\n};\n\nPromise.prototype._getCarriedStackTrace =\nfunction Promise$_getCarriedStackTrace() {\n    return this._isCarryingStackTrace()\n        ? this._fulfillmentHandler0\n        : void 0;\n};\n\nPromise.prototype._receiverAt = function Promise$_receiverAt(index) {\n    var ret = index === 0\n        ? this._receiver0\n        : this[(index << 2) + index - 5 + 4];\n    if (this._isBound() && ret === void 0) {\n        return this._boundTo;\n    }\n    return ret;\n};\n\nPromise.prototype._promiseAt = function Promise$_promiseAt(index) {\n    return index === 0\n        ? this._promise0\n        : this[(index << 2) + index - 5 + 3];\n};\n\nPromise.prototype._fulfillmentHandlerAt =\nfunction Promise$_fulfillmentHandlerAt(index) {\n    return index === 0\n        ? this._fulfillmentHandler0\n        : this[(index << 2) + index - 5 + 0];\n};\n\nPromise.prototype._rejectionHandlerAt =\nfunction Promise$_rejectionHandlerAt(index) {\n    return index === 0\n        ? this._rejectionHandler0\n        : this[(index << 2) + index - 5 + 1];\n};\n\nPromise.prototype._addCallbacks = function Promise$_addCallbacks(\n    fulfill,\n    reject,\n    progress,\n    promise,\n    receiver\n) {\n    var index = this._length();\n\n    if (index >= 262143 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n\n    if (index === 0) {\n        this._promise0 = promise;\n        if (receiver !== void 0) this._receiver0 = receiver;\n        if (typeof fulfill === \"function\" && !this._isCarryingStackTrace())\n            this._fulfillmentHandler0 = fulfill;\n        if (typeof reject === \"function\") this._rejectionHandler0 = reject;\n        if (typeof progress === \"function\") this._progressHandler0 = progress;\n    } else {\n        var base = (index << 2) + index - 5;\n        this[base + 3] = promise;\n        this[base + 4] = receiver;\n        this[base + 0] = typeof fulfill === \"function\"\n                                            ? fulfill : void 0;\n        this[base + 1] = typeof reject === \"function\"\n                                            ? reject : void 0;\n        this[base + 2] = typeof progress === \"function\"\n                                            ? progress : void 0;\n    }\n    this._setLength(index + 1);\n    return index;\n};\n\nPromise.prototype._setProxyHandlers =\nfunction Promise$_setProxyHandlers(receiver, promiseSlotValue) {\n    var index = this._length();\n\n    if (index >= 262143 - 5) {\n        index = 0;\n        this._setLength(0);\n    }\n    if (index === 0) {\n        this._promise0 = promiseSlotValue;\n        this._receiver0 = receiver;\n    } else {\n        var base = (index << 2) + index - 5;\n        this[base + 3] = promiseSlotValue;\n        this[base + 4] = receiver;\n        this[base + 0] =\n        this[base + 1] =\n        this[base + 2] = void 0;\n    }\n    this._setLength(index + 1);\n};\n\nPromise.prototype._proxyPromiseArray =\nfunction Promise$_proxyPromiseArray(promiseArray, index) {\n    this._setProxyHandlers(promiseArray, index);\n};\n\nPromise.prototype._proxyPromise = function Promise$_proxyPromise(promise) {\n    promise._setProxied();\n    this._setProxyHandlers(promise, -1);\n};\n\nPromise.prototype._setBoundTo = function Promise$_setBoundTo(obj) {\n    if (obj !== void 0) {\n        this._bitField = this._bitField | 8388608;\n        this._boundTo = obj;\n    } else {\n        this._bitField = this._bitField & (~8388608);\n    }\n};\n\nPromise.prototype._isBound = function Promise$_isBound() {\n    return (this._bitField & 8388608) === 8388608;\n};\n\nPromise.prototype._resolveFromResolver =\nfunction Promise$_resolveFromResolver(resolver) {\n    var promise = this;\n    this._setTrace(void 0);\n    this._pushContext();\n\n    function Promise$_resolver(val) {\n        if (promise._tryFollow(val)) {\n            return;\n        }\n        promise._fulfill(val);\n    }\n    function Promise$_rejecter(val) {\n        var trace = canAttach(val) ? val : new Error(val + \"\");\n        promise._attachExtraTrace(trace);\n        markAsOriginatingFromRejection(val);\n        promise._reject(val, trace === val ? void 0 : trace);\n    }\n    var r = tryCatch2(resolver, void 0, Promise$_resolver, Promise$_rejecter);\n    this._popContext();\n\n    if (r !== void 0 && r === errorObj) {\n        var e = r.e;\n        var trace = canAttach(e) ? e : new Error(e + \"\");\n        promise._reject(e, trace);\n    }\n};\n\nPromise.prototype._spreadSlowCase =\nfunction Promise$_spreadSlowCase(targetFn, promise, values, boundTo) {\n    var promiseForAll = new PromiseArray(values).promise();\n    var promise2 = promiseForAll._then(function() {\n        return targetFn.apply(boundTo, arguments);\n    }, void 0, void 0, APPLY, void 0);\n    promise._follow(promise2);\n};\n\nPromise.prototype._callSpread =\nfunction Promise$_callSpread(handler, promise, value) {\n    var boundTo = this._boundTo;\n    if (isArray(value)) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n            if (cast(value[i], void 0) instanceof Promise) {\n                this._spreadSlowCase(handler, promise, value, boundTo);\n                return;\n            }\n        }\n    }\n    promise._pushContext();\n    return tryCatchApply(handler, value, boundTo);\n};\n\nPromise.prototype._callHandler =\nfunction Promise$_callHandler(\n    handler, receiver, promise, value) {\n    var x;\n    if (receiver === APPLY && !this.isRejected()) {\n        x = this._callSpread(handler, promise, value);\n    } else {\n        promise._pushContext();\n        x = tryCatch1(handler, receiver, value);\n    }\n    promise._popContext();\n    return x;\n};\n\nPromise.prototype._settlePromiseFromHandler =\nfunction Promise$_settlePromiseFromHandler(\n    handler, receiver, value, promise\n) {\n    if (!(promise instanceof Promise)) {\n        handler.call(receiver, value, promise);\n        return;\n    }\n    var x = this._callHandler(handler, receiver, promise, value);\n    if (promise._isFollowing()) return;\n\n    if (x === errorObj || x === promise || x === NEXT_FILTER) {\n        var err = x === promise\n                    ? makeSelfResolutionError()\n                    : x.e;\n        var trace = canAttach(err) ? err : new Error(err + \"\");\n        if (x !== NEXT_FILTER) promise._attachExtraTrace(trace);\n        promise._rejectUnchecked(err, trace);\n    } else {\n        var castValue = cast(x, promise);\n        if (castValue instanceof Promise) {\n            if (castValue.isRejected() &&\n                !castValue._isCarryingStackTrace() &&\n                !canAttach(castValue._settledValue)) {\n                var trace = new Error(castValue._settledValue + \"\");\n                promise._attachExtraTrace(trace);\n                castValue._setCarriedStackTrace(trace);\n            }\n            promise._follow(castValue);\n            promise._propagateFrom(castValue, 1);\n        } else {\n            promise._fulfillUnchecked(x);\n        }\n    }\n};\n\nPromise.prototype._follow =\nfunction Promise$_follow(promise) {\n    this._setFollowing();\n\n    if (promise.isPending()) {\n        this._propagateFrom(promise, 1);\n        promise._proxyPromise(this);\n    } else if (promise.isFulfilled()) {\n        this._fulfillUnchecked(promise._settledValue);\n    } else {\n        this._rejectUnchecked(promise._settledValue,\n            promise._getCarriedStackTrace());\n    }\n\n    if (promise._isRejectionUnhandled()) promise._unsetRejectionIsUnhandled();\n\n    if (debugging &&\n        promise._traceParent == null) {\n        promise._traceParent = this;\n    }\n};\n\nPromise.prototype._tryFollow =\nfunction Promise$_tryFollow(value) {\n    if (this._isFollowingOrFulfilledOrRejected() ||\n        value === this) {\n        return false;\n    }\n    var maybePromise = cast(value, void 0);\n    if (!(maybePromise instanceof Promise)) {\n        return false;\n    }\n    this._follow(maybePromise);\n    return true;\n};\n\nPromise.prototype._resetTrace = function Promise$_resetTrace() {\n    if (debugging) {\n        this._trace = new CapturedTrace(this._peekContext() === void 0);\n    }\n};\n\nPromise.prototype._setTrace = function Promise$_setTrace(parent) {\n    if (debugging) {\n        var context = this._peekContext();\n        this._traceParent = context;\n        var isTopLevel = context === void 0;\n        if (parent !== void 0 &&\n            parent._traceParent === context) {\n            this._trace = parent._trace;\n        } else {\n            this._trace = new CapturedTrace(isTopLevel);\n        }\n    }\n    return this;\n};\n\nPromise.prototype._attachExtraTrace =\nfunction Promise$_attachExtraTrace(error) {\n    if (debugging) {\n        var promise = this;\n        var stack = error.stack;\n        stack = typeof stack === \"string\" ? stack.split(\"\\n\") : [];\n        CapturedTrace.protectErrorMessageNewlines(stack);\n        var headerLineCount = 1;\n        var combinedTraces = 1;\n        while(promise != null &&\n            promise._trace != null) {\n            stack = CapturedTrace.combine(\n                stack,\n                promise._trace.stack.split(\"\\n\")\n            );\n            promise = promise._traceParent;\n            combinedTraces++;\n        }\n\n        var stackTraceLimit = Error.stackTraceLimit || 10;\n        var max = (stackTraceLimit + headerLineCount) * combinedTraces;\n        var len = stack.length;\n        if (len > max) {\n            stack.length = max;\n        }\n\n        if (len > 0)\n            stack[0] = stack[0].split(\"\\u0002\\u0000\\u0001\").join(\"\\n\");\n\n        if (stack.length <= headerLineCount) {\n            error.stack = \"(No stack trace)\";\n        } else {\n            error.stack = stack.join(\"\\n\");\n        }\n    }\n};\n\nPromise.prototype._cleanValues = function Promise$_cleanValues() {\n    if (this._cancellable()) {\n        this._cancellationParent = void 0;\n    }\n};\n\nPromise.prototype._propagateFrom =\nfunction Promise$_propagateFrom(parent, flags) {\n    if ((flags & 1) > 0 && parent._cancellable()) {\n        this._setCancellable();\n        this._cancellationParent = parent;\n    }\n    if ((flags & 4) > 0) {\n        this._setBoundTo(parent._boundTo);\n    }\n    if ((flags & 2) > 0) {\n        this._setTrace(parent);\n    }\n};\n\nPromise.prototype._fulfill = function Promise$_fulfill(value) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._fulfillUnchecked(value);\n};\n\nPromise.prototype._reject =\nfunction Promise$_reject(reason, carriedStackTrace) {\n    if (this._isFollowingOrFulfilledOrRejected()) return;\n    this._rejectUnchecked(reason, carriedStackTrace);\n};\n\nPromise.prototype._settlePromiseAt = function Promise$_settlePromiseAt(index) {\n    var handler = this.isFulfilled()\n        ? this._fulfillmentHandlerAt(index)\n        : this._rejectionHandlerAt(index);\n\n    var value = this._settledValue;\n    var receiver = this._receiverAt(index);\n    var promise = this._promiseAt(index);\n\n    if (typeof handler === \"function\") {\n        this._settlePromiseFromHandler(handler, receiver, value, promise);\n    } else {\n        var done = false;\n        var isFulfilled = this.isFulfilled();\n        if (receiver !== void 0) {\n            if (receiver instanceof Promise &&\n                receiver._isProxied()) {\n                receiver._unsetProxied();\n\n                if (isFulfilled) receiver._fulfillUnchecked(value);\n                else receiver._rejectUnchecked(value,\n                    this._getCarriedStackTrace());\n                done = true;\n            } else if (receiver instanceof PromiseArray) {\n                if (isFulfilled) receiver._promiseFulfilled(value, promise);\n                else receiver._promiseRejected(value, promise);\n                done = true;\n            }\n        }\n\n        if (!done) {\n            if (isFulfilled) promise._fulfill(value);\n            else promise._reject(value, this._getCarriedStackTrace());\n        }\n    }\n\n    if (index >= 256) {\n        this._queueGC();\n    }\n};\n\nPromise.prototype._isProxied = function Promise$_isProxied() {\n    return (this._bitField & 4194304) === 4194304;\n};\n\nPromise.prototype._setProxied = function Promise$_setProxied() {\n    this._bitField = this._bitField | 4194304;\n};\n\nPromise.prototype._unsetProxied = function Promise$_unsetProxied() {\n    this._bitField = this._bitField & (~4194304);\n};\n\nPromise.prototype._isGcQueued = function Promise$_isGcQueued() {\n    return (this._bitField & -1073741824) === -1073741824;\n};\n\nPromise.prototype._setGcQueued = function Promise$_setGcQueued() {\n    this._bitField = this._bitField | -1073741824;\n};\n\nPromise.prototype._unsetGcQueued = function Promise$_unsetGcQueued() {\n    this._bitField = this._bitField & (~-1073741824);\n};\n\nPromise.prototype._queueGC = function Promise$_queueGC() {\n    if (this._isGcQueued()) return;\n    this._setGcQueued();\n    async.invokeLater(this._gc, this, void 0);\n};\n\nPromise.prototype._gc = function Promise$gc() {\n    var len = this._length() * 5;\n    for (var i = 0; i < len; i++) {\n        delete this[i];\n    }\n    this._setLength(0);\n    this._unsetGcQueued();\n};\n\nPromise.prototype._queueSettleAt = function Promise$_queueSettleAt(index) {\n    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();\n    async.invoke(this._settlePromiseAt, this, index);\n};\n\nPromise.prototype._fulfillUnchecked =\nfunction Promise$_fulfillUnchecked(value) {\n    if (!this.isPending()) return;\n    if (value === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err, void 0);\n    }\n    this._cleanValues();\n    this._setFulfilled();\n    this._settledValue = value;\n    var len = this._length();\n\n    if (len > 0) {\n        async.invoke(this._settlePromises, this, len);\n    }\n};\n\nPromise.prototype._rejectUncheckedCheckError =\nfunction Promise$_rejectUncheckedCheckError(reason) {\n    var trace = canAttach(reason) ? reason : new Error(reason + \"\");\n    this._rejectUnchecked(reason, trace === reason ? void 0 : trace);\n};\n\nPromise.prototype._rejectUnchecked =\nfunction Promise$_rejectUnchecked(reason, trace) {\n    if (!this.isPending()) return;\n    if (reason === this) {\n        var err = makeSelfResolutionError();\n        this._attachExtraTrace(err);\n        return this._rejectUnchecked(err);\n    }\n    this._cleanValues();\n    this._setRejected();\n    this._settledValue = reason;\n\n    if (this._isFinal()) {\n        async.invokeLater(thrower, void 0, trace === void 0 ? reason : trace);\n        return;\n    }\n    var len = this._length();\n\n    if (trace !== void 0) this._setCarriedStackTrace(trace);\n\n    if (len > 0) {\n        async.invoke(this._rejectPromises, this, null);\n    } else {\n        this._ensurePossibleRejectionHandled();\n    }\n};\n\nPromise.prototype._rejectPromises = function Promise$_rejectPromises() {\n    this._settlePromises();\n    this._unsetCarriedStackTrace();\n};\n\nPromise.prototype._settlePromises = function Promise$_settlePromises() {\n    var len = this._length();\n    for (var i = 0; i < len; i++) {\n        this._settlePromiseAt(i);\n    }\n};\n\nPromise.prototype._ensurePossibleRejectionHandled =\nfunction Promise$_ensurePossibleRejectionHandled() {\n    this._setRejectionIsUnhandled();\n    if (CapturedTrace.possiblyUnhandledRejection !== void 0) {\n        async.invokeLater(this._notifyUnhandledRejection, this, void 0);\n    }\n};\n\nPromise.prototype._notifyUnhandledRejectionIsHandled =\nfunction Promise$_notifyUnhandledRejectionIsHandled() {\n    if (typeof unhandledRejectionHandled === \"function\") {\n        async.invokeLater(unhandledRejectionHandled, void 0, this);\n    }\n};\n\nPromise.prototype._notifyUnhandledRejection =\nfunction Promise$_notifyUnhandledRejection() {\n    if (this._isRejectionUnhandled()) {\n        var reason = this._settledValue;\n        var trace = this._getCarriedStackTrace();\n\n        this._setUnhandledRejectionIsNotified();\n\n        if (trace !== void 0) {\n            this._unsetCarriedStackTrace();\n            reason = trace;\n        }\n        if (typeof CapturedTrace.possiblyUnhandledRejection === \"function\") {\n            CapturedTrace.possiblyUnhandledRejection(reason, this);\n        }\n    }\n};\n\nvar contextStack = [];\nPromise.prototype._peekContext = function Promise$_peekContext() {\n    var lastIndex = contextStack.length - 1;\n    if (lastIndex >= 0) {\n        return contextStack[lastIndex];\n    }\n    return void 0;\n\n};\n\nPromise.prototype._pushContext = function Promise$_pushContext() {\n    if (!debugging) return;\n    contextStack.push(this);\n};\n\nPromise.prototype._popContext = function Promise$_popContext() {\n    if (!debugging) return;\n    contextStack.pop();\n};\n\nPromise.noConflict = function Promise$NoConflict() {\n    return noConflict(Promise);\n};\n\nPromise.setScheduler = function(fn) {\n    if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\");\n    async._schedule = fn;\n};\n\nif (!CapturedTrace.isSupported()) {\n    Promise.longStackTraces = function(){};\n    debugging = false;\n}\n\nPromise._makeSelfResolutionError = makeSelfResolutionError;\nrequire(\"./finally.js\")(Promise, NEXT_FILTER, cast);\nrequire(\"./direct_resolve.js\")(Promise);\nrequire(\"./synchronous_inspection.js\")(Promise);\nrequire(\"./join.js\")(Promise, PromiseArray, cast, INTERNAL);\nPromise.RangeError = RangeError;\nPromise.CancellationError = CancellationError;\nPromise.TimeoutError = TimeoutError;\nPromise.TypeError = TypeError;\nPromise.OperationalError = OperationalError;\nPromise.RejectionError = OperationalError;\nPromise.AggregateError = errors.AggregateError;\n\nutil.toFastProperties(Promise);\nutil.toFastProperties(Promise.prototype);\nPromise.Promise = Promise;\nrequire('./timers.js')(Promise,INTERNAL,cast);\nrequire('./race.js')(Promise,INTERNAL,cast);\nrequire('./call_get.js')(Promise);\nrequire('./generators.js')(Promise,apiRejection,INTERNAL,cast);\nrequire('./map.js')(Promise,PromiseArray,apiRejection,cast,INTERNAL);\nrequire('./nodeify.js')(Promise);\nrequire('./promisify.js')(Promise,INTERNAL);\nrequire('./props.js')(Promise,PromiseArray,cast);\nrequire('./reduce.js')(Promise,PromiseArray,apiRejection,cast,INTERNAL);\nrequire('./settle.js')(Promise,PromiseArray);\nrequire('./some.js')(Promise,PromiseArray,apiRejection);\nrequire('./progress.js')(Promise,PromiseArray);\nrequire('./cancel.js')(Promise,INTERNAL);\nrequire('./filter.js')(Promise,INTERNAL);\nrequire('./any.js')(Promise,PromiseArray);\nrequire('./each.js')(Promise,INTERNAL);\nrequire('./using.js')(Promise,apiRejection,cast);\n\nPromise.prototype = Promise.prototype;\nreturn Promise;\n\n};\n\n}).call(this,require('_process'))\n},{\"./any.js\":105,\"./async.js\":106,\"./call_get.js\":108,\"./cancel.js\":109,\"./captured_trace.js\":110,\"./catch_filter.js\":111,\"./direct_resolve.js\":112,\"./each.js\":113,\"./errors.js\":114,\"./errors_api_rejection\":115,\"./filter.js\":117,\"./finally.js\":118,\"./generators.js\":119,\"./join.js\":120,\"./map.js\":121,\"./nodeify.js\":122,\"./progress.js\":123,\"./promise_array.js\":125,\"./promise_resolver.js\":126,\"./promisify.js\":127,\"./props.js\":128,\"./race.js\":130,\"./reduce.js\":131,\"./settle.js\":133,\"./some.js\":134,\"./synchronous_inspection.js\":135,\"./thenables.js\":136,\"./timers.js\":137,\"./using.js\":138,\"./util.js\":139,\"_process\":11}],125:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL, cast) {\nvar canAttach = require(\"./errors.js\").canAttach;\nvar util = require(\"./util.js\");\nvar isArray = util.isArray;\n\nfunction toResolutionValue(val) {\n    switch(val) {\n    case -1: return void 0;\n    case -2: return [];\n    case -3: return {};\n    }\n}\n\nfunction PromiseArray(values) {\n    var promise = this._promise = new Promise(INTERNAL);\n    var parent = void 0;\n    if (values instanceof Promise) {\n        parent = values;\n        promise._propagateFrom(parent, 1 | 4);\n    }\n    promise._setTrace(parent);\n    this._values = values;\n    this._length = 0;\n    this._totalResolved = 0;\n    this._init(void 0, -2);\n}\nPromiseArray.prototype.length = function PromiseArray$length() {\n    return this._length;\n};\n\nPromiseArray.prototype.promise = function PromiseArray$promise() {\n    return this._promise;\n};\n\nPromiseArray.prototype._init =\nfunction PromiseArray$_init(_, resolveValueIfEmpty) {\n    var values = cast(this._values, void 0);\n    if (values instanceof Promise) {\n        this._values = values;\n        values._setBoundTo(this._promise._boundTo);\n        if (values.isFulfilled()) {\n            values = values._settledValue;\n            if (!isArray(values)) {\n                var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\");\n                this.__hardReject__(err);\n                return;\n            }\n        } else if (values.isPending()) {\n            values._then(\n                PromiseArray$_init,\n                this._reject,\n                void 0,\n                this,\n                resolveValueIfEmpty\n           );\n            return;\n        } else {\n            values._unsetRejectionIsUnhandled();\n            this._reject(values._settledValue);\n            return;\n        }\n    } else if (!isArray(values)) {\n        var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\");\n        this.__hardReject__(err);\n        return;\n    }\n\n    if (values.length === 0) {\n        if (resolveValueIfEmpty === -5) {\n            this._resolveEmptyArray();\n        }\n        else {\n            this._resolve(toResolutionValue(resolveValueIfEmpty));\n        }\n        return;\n    }\n    var len = this.getActualLength(values.length);\n    var newLen = len;\n    var newValues = this.shouldCopyValues() ? new Array(len) : this._values;\n    var isDirectScanNeeded = false;\n    for (var i = 0; i < len; ++i) {\n        var maybePromise = cast(values[i], void 0);\n        if (maybePromise instanceof Promise) {\n            if (maybePromise.isPending()) {\n                maybePromise._proxyPromiseArray(this, i);\n            } else {\n                maybePromise._unsetRejectionIsUnhandled();\n                isDirectScanNeeded = true;\n            }\n        } else {\n            isDirectScanNeeded = true;\n        }\n        newValues[i] = maybePromise;\n    }\n    this._values = newValues;\n    this._length = newLen;\n    if (isDirectScanNeeded) {\n        this._scanDirectValues(len);\n    }\n};\n\nPromiseArray.prototype._settlePromiseAt =\nfunction PromiseArray$_settlePromiseAt(index) {\n    var value = this._values[index];\n    if (!(value instanceof Promise)) {\n        this._promiseFulfilled(value, index);\n    } else if (value.isFulfilled()) {\n        this._promiseFulfilled(value._settledValue, index);\n    } else if (value.isRejected()) {\n        this._promiseRejected(value._settledValue, index);\n    }\n};\n\nPromiseArray.prototype._scanDirectValues =\nfunction PromiseArray$_scanDirectValues(len) {\n    for (var i = 0; i < len; ++i) {\n        if (this._isResolved()) {\n            break;\n        }\n        this._settlePromiseAt(i);\n    }\n};\n\nPromiseArray.prototype._isResolved = function PromiseArray$_isResolved() {\n    return this._values === null;\n};\n\nPromiseArray.prototype._resolve = function PromiseArray$_resolve(value) {\n    this._values = null;\n    this._promise._fulfill(value);\n};\n\nPromiseArray.prototype.__hardReject__ =\nPromiseArray.prototype._reject = function PromiseArray$_reject(reason) {\n    this._values = null;\n    var trace = canAttach(reason) ? reason : new Error(reason + \"\");\n    this._promise._attachExtraTrace(trace);\n    this._promise._reject(reason, trace);\n};\n\nPromiseArray.prototype._promiseProgressed =\nfunction PromiseArray$_promiseProgressed(progressValue, index) {\n    if (this._isResolved()) return;\n    this._promise._progress({\n        index: index,\n        value: progressValue\n    });\n};\n\n\nPromiseArray.prototype._promiseFulfilled =\nfunction PromiseArray$_promiseFulfilled(value, index) {\n    if (this._isResolved()) return;\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nPromiseArray.prototype._promiseRejected =\nfunction PromiseArray$_promiseRejected(reason, index) {\n    if (this._isResolved()) return;\n    this._totalResolved++;\n    this._reject(reason);\n};\n\nPromiseArray.prototype.shouldCopyValues =\nfunction PromiseArray$_shouldCopyValues() {\n    return true;\n};\n\nPromiseArray.prototype.getActualLength =\nfunction PromiseArray$getActualLength(len) {\n    return len;\n};\n\nreturn PromiseArray;\n};\n\n},{\"./errors.js\":114,\"./util.js\":139}],126:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar util = require(\"./util.js\");\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar errors = require(\"./errors.js\");\nvar TimeoutError = errors.TimeoutError;\nvar OperationalError = errors.OperationalError;\nvar async = require(\"./async.js\");\nvar haveGetters = util.haveGetters;\nvar es5 = require(\"./es5.js\");\n\nfunction isUntypedError(obj) {\n    return obj instanceof Error &&\n        es5.getPrototypeOf(obj) === Error.prototype;\n}\n\nfunction wrapAsOperationalError(obj) {\n    var ret;\n    if (isUntypedError(obj)) {\n        ret = new OperationalError(obj);\n    } else {\n        ret = obj;\n    }\n    errors.markAsOriginatingFromRejection(ret);\n    return ret;\n}\n\nfunction nodebackForPromise(promise) {\n    function PromiseResolver$_callback(err, value) {\n        if (promise === null) return;\n\n        if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        } else if (arguments.length > 2) {\n            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}\n            promise._fulfill(args);\n        } else {\n            promise._fulfill(value);\n        }\n\n        promise = null;\n    }\n    return PromiseResolver$_callback;\n}\n\n\nvar PromiseResolver;\nif (!haveGetters) {\n    PromiseResolver = function PromiseResolver(promise) {\n        this.promise = promise;\n        this.asCallback = nodebackForPromise(promise);\n        this.callback = this.asCallback;\n    };\n}\nelse {\n    PromiseResolver = function PromiseResolver(promise) {\n        this.promise = promise;\n    };\n}\nif (haveGetters) {\n    var prop = {\n        get: function() {\n            return nodebackForPromise(this.promise);\n        }\n    };\n    es5.defineProperty(PromiseResolver.prototype, \"asCallback\", prop);\n    es5.defineProperty(PromiseResolver.prototype, \"callback\", prop);\n}\n\nPromiseResolver._nodebackForPromise = nodebackForPromise;\n\nPromiseResolver.prototype.toString = function PromiseResolver$toString() {\n    return \"[object PromiseResolver]\";\n};\n\nPromiseResolver.prototype.resolve =\nPromiseResolver.prototype.fulfill = function PromiseResolver$resolve(value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\");\n    }\n\n    var promise = this.promise;\n    if (promise._tryFollow(value)) {\n        return;\n    }\n    async.invoke(promise._fulfill, promise, value);\n};\n\nPromiseResolver.prototype.reject = function PromiseResolver$reject(reason) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\");\n    }\n\n    var promise = this.promise;\n    errors.markAsOriginatingFromRejection(reason);\n    var trace = errors.canAttach(reason) ? reason : new Error(reason + \"\");\n    promise._attachExtraTrace(trace);\n    async.invoke(promise._reject, promise, reason);\n    if (trace !== reason) {\n        async.invoke(this._setCarriedStackTrace, this, trace);\n    }\n};\n\nPromiseResolver.prototype.progress =\nfunction PromiseResolver$progress(value) {\n    if (!(this instanceof PromiseResolver)) {\n        throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\");\n    }\n    async.invoke(this.promise._progress, this.promise, value);\n};\n\nPromiseResolver.prototype.cancel = function PromiseResolver$cancel() {\n    async.invoke(this.promise.cancel, this.promise, void 0);\n};\n\nPromiseResolver.prototype.timeout = function PromiseResolver$timeout() {\n    this.reject(new TimeoutError(\"timeout\"));\n};\n\nPromiseResolver.prototype.isResolved = function PromiseResolver$isResolved() {\n    return this.promise.isResolved();\n};\n\nPromiseResolver.prototype.toJSON = function PromiseResolver$toJSON() {\n    return this.promise.toJSON();\n};\n\nPromiseResolver.prototype._setCarriedStackTrace =\nfunction PromiseResolver$_setCarriedStackTrace(trace) {\n    if (this.promise.isRejected()) {\n        this.promise._setCarriedStackTrace(trace);\n    }\n};\n\nmodule.exports = PromiseResolver;\n\n},{\"./async.js\":106,\"./errors.js\":114,\"./es5.js\":116,\"./util.js\":139}],127:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar THIS = {};\nvar util = require(\"./util.js\");\nvar nodebackForPromise = require(\"./promise_resolver.js\")\n    ._nodebackForPromise;\nvar withAppended = util.withAppended;\nvar maybeWrapAsError = util.maybeWrapAsError;\nvar canEvaluate = util.canEvaluate;\nvar TypeError = require(\"./errors\").TypeError;\nvar defaultSuffix = \"Async\";\nvar defaultFilter = function(name, func) {\n    return util.isIdentifier(name) &&\n        name.charAt(0) !== \"_\" &&\n        !util.isClass(func);\n};\nvar defaultPromisified = {__isPromisified__: true};\n\n\nfunction escapeIdentRegex(str) {\n    return str.replace(/([$])/, \"\\\\$\");\n}\n\nfunction isPromisified(fn) {\n    try {\n        return fn.__isPromisified__ === true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n\nfunction hasPromisified(obj, key, suffix) {\n    var val = util.getDataPropertyOrDefault(obj, key + suffix,\n                                            defaultPromisified);\n    return val ? isPromisified(val) : false;\n}\nfunction checkValid(ret, suffix, suffixRegexp) {\n    for (var i = 0; i < ret.length; i += 2) {\n        var key = ret[i];\n        if (suffixRegexp.test(key)) {\n            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n            for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                    throw new TypeError(\"Cannot promisify an API \" +\n                        \"that has normal methods with '\"+suffix+\"'-suffix\");\n                }\n            }\n        }\n    }\n}\n\nfunction promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n    var keys = util.inheritedDataKeys(obj);\n    var ret = [];\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var value = obj[key];\n        if (typeof value === \"function\" &&\n            !isPromisified(value) &&\n            !hasPromisified(obj, key, suffix) &&\n            filter(key, value, obj)) {\n            ret.push(key, value);\n        }\n    }\n    checkValid(ret, suffix, suffixRegexp);\n    return ret;\n}\n\nfunction switchCaseArgumentOrder(likelyArgumentCount) {\n    var ret = [likelyArgumentCount];\n    var min = Math.max(0, likelyArgumentCount - 1 - 5);\n    for(var i = likelyArgumentCount - 1; i >= min; --i) {\n        if (i === likelyArgumentCount) continue;\n        ret.push(i);\n    }\n    for(var i = likelyArgumentCount + 1; i <= 5; ++i) {\n        ret.push(i);\n    }\n    return ret;\n}\n\nfunction argumentSequence(argumentCount) {\n    return util.filledRange(argumentCount, \"arguments[\", \"]\");\n}\n\nfunction parameterDeclaration(parameterCount) {\n    return util.filledRange(parameterCount, \"_arg\", \"\");\n}\n\nfunction parameterCount(fn) {\n    if (typeof fn.length === \"number\") {\n        return Math.max(Math.min(fn.length, 1023 + 1), 0);\n    }\n    return 0;\n}\n\nfunction generatePropertyAccess(key) {\n    if (util.isIdentifier(key)) {\n        return \".\" + key;\n    }\n    else return \"['\" + key.replace(/(['\\\\])/g, \"\\\\$1\") + \"']\";\n}\n\nfunction makeNodePromisifiedEval(callback, receiver, originalName, fn, suffix) {\n    var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n    var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n    var callbackName =\n        (typeof originalName === \"string\" && util.isIdentifier(originalName)\n            ? originalName + suffix\n            : \"promisified\");\n\n    function generateCallForArgumentCount(count) {\n        var args = argumentSequence(count).join(\", \");\n        var comma = count > 0 ? \", \" : \"\";\n        var ret;\n        if (typeof callback === \"string\") {\n            ret = \"                                                          \\n\\\n                this.method(args, fn);                                       \\n\\\n                break;                                                       \\n\\\n            \".replace(\".method\", generatePropertyAccess(callback));\n        } else if (receiver === THIS) {\n            ret =  \"                                                         \\n\\\n                callback.call(this, args, fn);                               \\n\\\n                break;                                                       \\n\\\n            \";\n        } else if (receiver !== void 0) {\n            ret =  \"                                                         \\n\\\n                callback.call(receiver, args, fn);                           \\n\\\n                break;                                                       \\n\\\n            \";\n        } else {\n            ret =  \"                                                         \\n\\\n                callback(args, fn);                                          \\n\\\n                break;                                                       \\n\\\n            \";\n        }\n        return ret.replace(\"args\", args).replace(\", \", comma);\n    }\n\n    function generateArgumentSwitchCase() {\n        var ret = \"\";\n        for(var i = 0; i < argumentOrder.length; ++i) {\n            ret += \"case \" + argumentOrder[i] +\":\" +\n                generateCallForArgumentCount(argumentOrder[i]);\n        }\n        var codeForCall;\n        if (typeof callback === \"string\") {\n            codeForCall = \"                                                  \\n\\\n                this.property.apply(this, args);                             \\n\\\n            \"\n                .replace(\".property\", generatePropertyAccess(callback));\n        } else if (receiver === THIS) {\n            codeForCall = \"                                                  \\n\\\n                callback.apply(this, args);                                  \\n\\\n            \";\n        } else {\n            codeForCall = \"                                                  \\n\\\n                callback.apply(receiver, args);                              \\n\\\n            \";\n        }\n\n        ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = fn;                                                    \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", codeForCall);\n        return ret;\n    }\n\n    return new Function(\"Promise\",\n                        \"callback\",\n                        \"receiver\",\n                        \"withAppended\",\n                        \"maybeWrapAsError\",\n                        \"nodebackForPromise\",\n                        \"INTERNAL\",\"                                         \\n\\\n        var ret = function FunctionName(Parameters) {                        \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._setTrace(void 0);                                       \\n\\\n            var fn = nodebackForPromise(promise);                            \\n\\\n            try {                                                            \\n\\\n                switch(len) {                                                \\n\\\n                    [CodeForSwitchCase]                                      \\n\\\n                }                                                            \\n\\\n            } catch (e) {                                                    \\n\\\n                var wrapped = maybeWrapAsError(e);                           \\n\\\n                promise._attachExtraTrace(wrapped);                          \\n\\\n                promise._reject(wrapped);                                    \\n\\\n            }                                                                \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        ret.__isPromisified__ = true;                                        \\n\\\n        return ret;                                                          \\n\\\n        \"\n        .replace(\"FunctionName\", callbackName)\n        .replace(\"Parameters\", parameterDeclaration(newParameterCount))\n        .replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase()))(\n            Promise,\n            callback,\n            receiver,\n            withAppended,\n            maybeWrapAsError,\n            nodebackForPromise,\n            INTERNAL\n        );\n}\n\nfunction makeNodePromisifiedClosure(callback, receiver) {\n    function promisified() {\n        var _receiver = receiver;\n        if (receiver === THIS) _receiver = this;\n        if (typeof callback === \"string\") {\n            callback = _receiver[callback];\n        }\n        var promise = new Promise(INTERNAL);\n        promise._setTrace(void 0);\n        var fn = nodebackForPromise(promise);\n        try {\n            callback.apply(_receiver, withAppended(arguments, fn));\n        } catch(e) {\n            var wrapped = maybeWrapAsError(e);\n            promise._attachExtraTrace(wrapped);\n            promise._reject(wrapped);\n        }\n        return promise;\n    }\n    promisified.__isPromisified__ = true;\n    return promisified;\n}\n\nvar makeNodePromisified = canEvaluate\n    ? makeNodePromisifiedEval\n    : makeNodePromisifiedClosure;\n\nfunction promisifyAll(obj, suffix, filter, promisifier) {\n    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n    var methods =\n        promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n    for (var i = 0, len = methods.length; i < len; i+= 2) {\n        var key = methods[i];\n        var fn = methods[i+1];\n        var promisifiedKey = key + suffix;\n        obj[promisifiedKey] = promisifier === makeNodePromisified\n                ? makeNodePromisified(key, THIS, key, fn, suffix)\n                : promisifier(fn);\n    }\n    util.toFastProperties(obj);\n    return obj;\n}\n\nfunction promisify(callback, receiver) {\n    return makeNodePromisified(callback, receiver, void 0, callback);\n}\n\nPromise.promisify = function Promise$Promisify(fn, receiver) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"fn must be a function\");\n    }\n    if (isPromisified(fn)) {\n        return fn;\n    }\n    return promisify(fn, arguments.length < 2 ? THIS : receiver);\n};\n\nPromise.promisifyAll = function Promise$PromisifyAll(target, options) {\n    if (typeof target !== \"function\" && typeof target !== \"object\") {\n        throw new TypeError(\"the target of promisifyAll must be an object or a function\");\n    }\n    options = Object(options);\n    var suffix = options.suffix;\n    if (typeof suffix !== \"string\") suffix = defaultSuffix;\n    var filter = options.filter;\n    if (typeof filter !== \"function\") filter = defaultFilter;\n    var promisifier = options.promisifier;\n    if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n    if (!util.isIdentifier(suffix)) {\n        throw new RangeError(\"suffix must be a valid identifier\");\n    }\n\n    var keys = util.inheritedDataKeys(target, {includeHidden: true});\n    for (var i = 0; i < keys.length; ++i) {\n        var value = target[keys[i]];\n        if (keys[i] !== \"constructor\" &&\n            util.isClass(value)) {\n            promisifyAll(value.prototype, suffix, filter, promisifier);\n            promisifyAll(value, suffix, filter, promisifier);\n        }\n    }\n\n    return promisifyAll(target, suffix, filter, promisifier);\n};\n};\n\n\n},{\"./errors\":114,\"./promise_resolver.js\":126,\"./util.js\":139}],128:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, PromiseArray, cast) {\nvar util = require(\"./util.js\");\nvar apiRejection = require(\"./errors_api_rejection\")(Promise);\nvar isObject = util.isObject;\nvar es5 = require(\"./es5.js\");\n\nfunction PropertiesPromiseArray(obj) {\n    var keys = es5.keys(obj);\n    var len = keys.length;\n    var values = new Array(len * 2);\n    for (var i = 0; i < len; ++i) {\n        var key = keys[i];\n        values[i] = obj[key];\n        values[i + len] = key;\n    }\n    this.constructor$(values);\n}\nutil.inherits(PropertiesPromiseArray, PromiseArray);\n\nPropertiesPromiseArray.prototype._init =\nfunction PropertiesPromiseArray$_init() {\n    this._init$(void 0, -3) ;\n};\n\nPropertiesPromiseArray.prototype._promiseFulfilled =\nfunction PropertiesPromiseArray$_promiseFulfilled(value, index) {\n    if (this._isResolved()) return;\n    this._values[index] = value;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        var val = {};\n        var keyOffset = this.length();\n        for (var i = 0, len = this.length(); i < len; ++i) {\n            val[this._values[i + keyOffset]] = this._values[i];\n        }\n        this._resolve(val);\n    }\n};\n\nPropertiesPromiseArray.prototype._promiseProgressed =\nfunction PropertiesPromiseArray$_promiseProgressed(value, index) {\n    if (this._isResolved()) return;\n\n    this._promise._progress({\n        key: this._values[index + this.length()],\n        value: value\n    });\n};\n\nPropertiesPromiseArray.prototype.shouldCopyValues =\nfunction PropertiesPromiseArray$_shouldCopyValues() {\n    return false;\n};\n\nPropertiesPromiseArray.prototype.getActualLength =\nfunction PropertiesPromiseArray$getActualLength(len) {\n    return len >> 1;\n};\n\nfunction Promise$_Props(promises) {\n    var ret;\n    var castValue = cast(promises, void 0);\n\n    if (!isObject(castValue)) {\n        return apiRejection(\"cannot await properties of a non-object\");\n    } else if (castValue instanceof Promise) {\n        ret = castValue._then(Promise.props, void 0, void 0, void 0, void 0);\n    } else {\n        ret = new PropertiesPromiseArray(castValue).promise();\n    }\n\n    if (castValue instanceof Promise) {\n        ret._propagateFrom(castValue, 4);\n    }\n    return ret;\n}\n\nPromise.prototype.props = function Promise$props() {\n    return Promise$_Props(this);\n};\n\nPromise.props = function Promise$Props(promises) {\n    return Promise$_Props(promises);\n};\n};\n\n},{\"./errors_api_rejection\":115,\"./es5.js\":116,\"./util.js\":139}],129:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nfunction arrayCopy(src, srcIndex, dst, dstIndex, len) {\n    for (var j = 0; j < len; ++j) {\n        dst[j + dstIndex] = src[j + srcIndex];\n    }\n}\n\nfunction Queue(capacity) {\n    this._capacity = capacity;\n    this._length = 0;\n    this._front = 0;\n    this._makeCapacity();\n}\n\nQueue.prototype._willBeOverCapacity =\nfunction Queue$_willBeOverCapacity(size) {\n    return this._capacity < size;\n};\n\nQueue.prototype._pushOne = function Queue$_pushOne(arg) {\n    var length = this.length();\n    this._checkCapacity(length + 1);\n    var i = (this._front + length) & (this._capacity - 1);\n    this[i] = arg;\n    this._length = length + 1;\n};\n\nQueue.prototype.push = function Queue$push(fn, receiver, arg) {\n    var length = this.length() + 3;\n    if (this._willBeOverCapacity(length)) {\n        this._pushOne(fn);\n        this._pushOne(receiver);\n        this._pushOne(arg);\n        return;\n    }\n    var j = this._front + length - 3;\n    this._checkCapacity(length);\n    var wrapMask = this._capacity - 1;\n    this[(j + 0) & wrapMask] = fn;\n    this[(j + 1) & wrapMask] = receiver;\n    this[(j + 2) & wrapMask] = arg;\n    this._length = length;\n};\n\nQueue.prototype.shift = function Queue$shift() {\n    var front = this._front,\n        ret = this[front];\n\n    this[front] = void 0;\n    this._front = (front + 1) & (this._capacity - 1);\n    this._length--;\n    return ret;\n};\n\nQueue.prototype.length = function Queue$length() {\n    return this._length;\n};\n\nQueue.prototype._makeCapacity = function Queue$_makeCapacity() {\n    var len = this._capacity;\n    for (var i = 0; i < len; ++i) {\n        this[i] = void 0;\n    }\n};\n\nQueue.prototype._checkCapacity = function Queue$_checkCapacity(size) {\n    if (this._capacity < size) {\n        this._resizeTo(this._capacity << 3);\n    }\n};\n\nQueue.prototype._resizeTo = function Queue$_resizeTo(capacity) {\n    var oldFront = this._front;\n    var oldCapacity = this._capacity;\n    var oldQueue = new Array(oldCapacity);\n    var length = this.length();\n\n    arrayCopy(this, 0, oldQueue, 0, oldCapacity);\n    this._capacity = capacity;\n    this._makeCapacity();\n    this._front = 0;\n    if (oldFront + length <= oldCapacity) {\n        arrayCopy(oldQueue, oldFront, this, 0, length);\n    } else {        var lengthBeforeWrapping =\n            length - ((oldFront + length) & (oldCapacity - 1));\n\n        arrayCopy(oldQueue, oldFront, this, 0, lengthBeforeWrapping);\n        arrayCopy(oldQueue, 0, this, lengthBeforeWrapping,\n                    length - lengthBeforeWrapping);\n    }\n};\n\nmodule.exports = Queue;\n\n},{}],130:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL, cast) {\nvar apiRejection = require(\"./errors_api_rejection.js\")(Promise);\nvar isArray = require(\"./util.js\").isArray;\n\nvar raceLater = function Promise$_raceLater(promise) {\n    return promise.then(function(array) {\n        return Promise$_Race(array, promise);\n    });\n};\n\nvar hasOwn = {}.hasOwnProperty;\nfunction Promise$_Race(promises, parent) {\n    var maybePromise = cast(promises, void 0);\n\n    if (maybePromise instanceof Promise) {\n        return raceLater(maybePromise);\n    } else if (!isArray(promises)) {\n        return apiRejection(\"expecting an array, a promise or a thenable\");\n    }\n\n    var ret = new Promise(INTERNAL);\n    if (parent !== void 0) {\n        ret._propagateFrom(parent, 7);\n    } else {\n        ret._setTrace(void 0);\n    }\n    var fulfill = ret._fulfill;\n    var reject = ret._reject;\n    for (var i = 0, len = promises.length; i < len; ++i) {\n        var val = promises[i];\n\n        if (val === void 0 && !(hasOwn.call(promises, i))) {\n            continue;\n        }\n\n        Promise.cast(val)._then(fulfill, reject, void 0, ret, null);\n    }\n    return ret;\n}\n\nPromise.race = function Promise$Race(promises) {\n    return Promise$_Race(promises, void 0);\n};\n\nPromise.prototype.race = function Promise$race() {\n    return Promise$_Race(this, void 0);\n};\n\n};\n\n},{\"./errors_api_rejection.js\":115,\"./util.js\":139}],131:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, PromiseArray, apiRejection, cast, INTERNAL) {\nvar util = require(\"./util.js\");\nvar tryCatch4 = util.tryCatch4;\nvar tryCatch3 = util.tryCatch3;\nvar errorObj = util.errorObj;\nfunction ReductionPromiseArray(promises, fn, accum, _each) {\n    this.constructor$(promises);\n    this._preservedValues = _each === INTERNAL ? [] : null;\n    this._zerothIsAccum = (accum === void 0);\n    this._gotAccum = false;\n    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);\n    this._valuesPhase = undefined;\n\n    var maybePromise = cast(accum, void 0);\n    var rejected = false;\n    var isPromise = maybePromise instanceof Promise;\n    if (isPromise) {\n        if (maybePromise.isPending()) {\n            maybePromise._proxyPromiseArray(this, -1);\n        } else if (maybePromise.isFulfilled()) {\n            accum = maybePromise.value();\n            this._gotAccum = true;\n        } else {\n            maybePromise._unsetRejectionIsUnhandled();\n            this._reject(maybePromise.reason());\n            rejected = true;\n        }\n    }\n    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;\n    this._callback = fn;\n    this._accum = accum;\n    if (!rejected) this._init$(void 0, -5);\n}\nutil.inherits(ReductionPromiseArray, PromiseArray);\n\nReductionPromiseArray.prototype._init =\nfunction ReductionPromiseArray$_init() {};\n\nReductionPromiseArray.prototype._resolveEmptyArray =\nfunction ReductionPromiseArray$_resolveEmptyArray() {\n    if (this._gotAccum || this._zerothIsAccum) {\n        this._resolve(this._preservedValues !== null\n                        ? [] : this._accum);\n    }\n};\n\nReductionPromiseArray.prototype._promiseFulfilled =\nfunction ReductionPromiseArray$_promiseFulfilled(value, index) {\n    var values = this._values;\n    if (values === null) return;\n    var length = this.length();\n    var preservedValues = this._preservedValues;\n    var isEach = preservedValues !== null;\n    var gotAccum = this._gotAccum;\n    var valuesPhase = this._valuesPhase;\n    var valuesPhaseIndex;\n    if (!valuesPhase) {\n        valuesPhase = this._valuesPhase = Array(length);\n        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {\n            valuesPhase[valuesPhaseIndex] = 0;\n        }\n    }\n    valuesPhaseIndex = valuesPhase[index];\n\n    if (index === 0 && this._zerothIsAccum) {\n        if (!gotAccum) {\n            this._accum = value;\n            this._gotAccum = gotAccum = true;\n        }\n        valuesPhase[index] = ((valuesPhaseIndex === 0)\n            ? 1 : 2);\n    } else if (index === -1) {\n        if (!gotAccum) {\n            this._accum = value;\n            this._gotAccum = gotAccum = true;\n        }\n    } else {\n        if (valuesPhaseIndex === 0) {\n            valuesPhase[index] = 1;\n        }\n        else {\n            valuesPhase[index] = 2;\n            if (gotAccum) {\n                this._accum = value;\n            }\n        }\n    }\n    if (!gotAccum) return;\n\n    var callback = this._callback;\n    var receiver = this._promise._boundTo;\n    var ret;\n\n    for (var i = this._reducingIndex; i < length; ++i) {\n        valuesPhaseIndex = valuesPhase[i];\n        if (valuesPhaseIndex === 2) {\n            this._reducingIndex = i + 1;\n            continue;\n        }\n        if (valuesPhaseIndex !== 1) return;\n\n        value = values[i];\n        if (value instanceof Promise) {\n            if (value.isFulfilled()) {\n                value = value._settledValue;\n            } else if (value.isPending()) {\n                return;\n            } else {\n                value._unsetRejectionIsUnhandled();\n                return this._reject(value.reason());\n            }\n        }\n\n        if (isEach) {\n            preservedValues.push(value);\n            ret = tryCatch3(callback, receiver, value, i, length);\n        }\n        else {\n            ret = tryCatch4(callback, receiver, this._accum, value, i, length);\n        }\n\n        if (ret === errorObj) return this._reject(ret.e);\n\n        var maybePromise = cast(ret, void 0);\n        if (maybePromise instanceof Promise) {\n            if (maybePromise.isPending()) {\n                valuesPhase[i] = 4;\n                return maybePromise._proxyPromiseArray(this, i);\n            } else if (maybePromise.isFulfilled()) {\n                ret = maybePromise.value();\n            } else {\n                maybePromise._unsetRejectionIsUnhandled();\n                return this._reject(maybePromise.reason());\n            }\n        }\n\n        this._reducingIndex = i + 1;\n        this._accum = ret;\n    }\n\n    if (this._reducingIndex < length) return;\n    this._resolve(isEach ? preservedValues : this._accum);\n};\n\nfunction reduce(promises, fn, initialValue, _each) {\n    if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\");\n    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n    return array.promise();\n}\n\nPromise.prototype.reduce = function Promise$reduce(fn, initialValue) {\n    return reduce(this, fn, initialValue, null);\n};\n\nPromise.reduce = function Promise$Reduce(promises, fn, initialValue, _each) {\n    return reduce(promises, fn, initialValue, _each);\n};\n};\n\n},{\"./util.js\":139}],132:[function(require,module,exports){\n(function (process){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar schedule;\nvar _MutationObserver;\nif (typeof process === \"object\" && typeof process.version === \"string\") {\n    schedule = function Promise$_Scheduler(fn) {\n        process.nextTick(fn);\n    };\n}\nelse if ((typeof MutationObserver !== \"undefined\" &&\n         (_MutationObserver = MutationObserver)) ||\n         (typeof WebKitMutationObserver !== \"undefined\" &&\n         (_MutationObserver = WebKitMutationObserver))) {\n    schedule = (function() {\n        var div = document.createElement(\"div\");\n        var queuedFn = void 0;\n        var observer = new _MutationObserver(\n            function Promise$_Scheduler() {\n                var fn = queuedFn;\n                queuedFn = void 0;\n                fn();\n            }\n       );\n        observer.observe(div, {\n            attributes: true\n        });\n        return function Promise$_Scheduler(fn) {\n            queuedFn = fn;\n            div.setAttribute(\"class\", \"foo\");\n        };\n\n    })();\n}\nelse if (typeof setTimeout !== \"undefined\") {\n    schedule = function Promise$_Scheduler(fn) {\n        setTimeout(fn, 0);\n    };\n}\nelse throw new Error(\"no async scheduler available\");\nmodule.exports = schedule;\n\n}).call(this,require('_process'))\n},{\"_process\":11}],133:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports =\n    function(Promise, PromiseArray) {\nvar PromiseInspection = Promise.PromiseInspection;\nvar util = require(\"./util.js\");\n\nfunction SettledPromiseArray(values) {\n    this.constructor$(values);\n}\nutil.inherits(SettledPromiseArray, PromiseArray);\n\nSettledPromiseArray.prototype._promiseResolved =\nfunction SettledPromiseArray$_promiseResolved(index, inspection) {\n    this._values[index] = inspection;\n    var totalResolved = ++this._totalResolved;\n    if (totalResolved >= this._length) {\n        this._resolve(this._values);\n    }\n};\n\nSettledPromiseArray.prototype._promiseFulfilled =\nfunction SettledPromiseArray$_promiseFulfilled(value, index) {\n    if (this._isResolved()) return;\n    var ret = new PromiseInspection();\n    ret._bitField = 268435456;\n    ret._settledValue = value;\n    this._promiseResolved(index, ret);\n};\nSettledPromiseArray.prototype._promiseRejected =\nfunction SettledPromiseArray$_promiseRejected(reason, index) {\n    if (this._isResolved()) return;\n    var ret = new PromiseInspection();\n    ret._bitField = 134217728;\n    ret._settledValue = reason;\n    this._promiseResolved(index, ret);\n};\n\nPromise.settle = function Promise$Settle(promises) {\n    return new SettledPromiseArray(promises).promise();\n};\n\nPromise.prototype.settle = function Promise$settle() {\n    return new SettledPromiseArray(this).promise();\n};\n};\n\n},{\"./util.js\":139}],134:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports =\nfunction(Promise, PromiseArray, apiRejection) {\nvar util = require(\"./util.js\");\nvar RangeError = require(\"./errors.js\").RangeError;\nvar AggregateError = require(\"./errors.js\").AggregateError;\nvar isArray = util.isArray;\n\n\nfunction SomePromiseArray(values) {\n    this.constructor$(values);\n    this._howMany = 0;\n    this._unwrap = false;\n    this._initialized = false;\n}\nutil.inherits(SomePromiseArray, PromiseArray);\n\nSomePromiseArray.prototype._init = function SomePromiseArray$_init() {\n    if (!this._initialized) {\n        return;\n    }\n    if (this._howMany === 0) {\n        this._resolve([]);\n        return;\n    }\n    this._init$(void 0, -5);\n    var isArrayResolved = isArray(this._values);\n    if (!this._isResolved() &&\n        isArrayResolved &&\n        this._howMany > this._canPossiblyFulfill()) {\n        this._reject(this._getRangeError(this.length()));\n    }\n};\n\nSomePromiseArray.prototype.init = function SomePromiseArray$init() {\n    this._initialized = true;\n    this._init();\n};\n\nSomePromiseArray.prototype.setUnwrap = function SomePromiseArray$setUnwrap() {\n    this._unwrap = true;\n};\n\nSomePromiseArray.prototype.howMany = function SomePromiseArray$howMany() {\n    return this._howMany;\n};\n\nSomePromiseArray.prototype.setHowMany =\nfunction SomePromiseArray$setHowMany(count) {\n    if (this._isResolved()) return;\n    this._howMany = count;\n};\n\nSomePromiseArray.prototype._promiseFulfilled =\nfunction SomePromiseArray$_promiseFulfilled(value) {\n    if (this._isResolved()) return;\n    this._addFulfilled(value);\n    if (this._fulfilled() === this.howMany()) {\n        this._values.length = this.howMany();\n        if (this.howMany() === 1 && this._unwrap) {\n            this._resolve(this._values[0]);\n        } else {\n            this._resolve(this._values);\n        }\n    }\n\n};\nSomePromiseArray.prototype._promiseRejected =\nfunction SomePromiseArray$_promiseRejected(reason) {\n    if (this._isResolved()) return;\n    this._addRejected(reason);\n    if (this.howMany() > this._canPossiblyFulfill()) {\n        var e = new AggregateError();\n        for (var i = this.length(); i < this._values.length; ++i) {\n            e.push(this._values[i]);\n        }\n        this._reject(e);\n    }\n};\n\nSomePromiseArray.prototype._fulfilled = function SomePromiseArray$_fulfilled() {\n    return this._totalResolved;\n};\n\nSomePromiseArray.prototype._rejected = function SomePromiseArray$_rejected() {\n    return this._values.length - this.length();\n};\n\nSomePromiseArray.prototype._addRejected =\nfunction SomePromiseArray$_addRejected(reason) {\n    this._values.push(reason);\n};\n\nSomePromiseArray.prototype._addFulfilled =\nfunction SomePromiseArray$_addFulfilled(value) {\n    this._values[this._totalResolved++] = value;\n};\n\nSomePromiseArray.prototype._canPossiblyFulfill =\nfunction SomePromiseArray$_canPossiblyFulfill() {\n    return this.length() - this._rejected();\n};\n\nSomePromiseArray.prototype._getRangeError =\nfunction SomePromiseArray$_getRangeError(count) {\n    var message = \"Input array must contain at least \" +\n            this._howMany + \" items but contains only \" + count + \" items\";\n    return new RangeError(message);\n};\n\nSomePromiseArray.prototype._resolveEmptyArray =\nfunction SomePromiseArray$_resolveEmptyArray() {\n    this._reject(this._getRangeError(0));\n};\n\nfunction Promise$_Some(promises, howMany) {\n    if ((howMany | 0) !== howMany || howMany < 0) {\n        return apiRejection(\"expecting a positive integer\");\n    }\n    var ret = new SomePromiseArray(promises);\n    var promise = ret.promise();\n    if (promise.isRejected()) {\n        return promise;\n    }\n    ret.setHowMany(howMany);\n    ret.init();\n    return promise;\n}\n\nPromise.some = function Promise$Some(promises, howMany) {\n    return Promise$_Some(promises, howMany);\n};\n\nPromise.prototype.some = function Promise$some(howMany) {\n    return Promise$_Some(this, howMany);\n};\n\nPromise._SomePromiseArray = SomePromiseArray;\n};\n\n},{\"./errors.js\":114,\"./util.js\":139}],135:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise) {\nfunction PromiseInspection(promise) {\n    if (promise !== void 0) {\n        this._bitField = promise._bitField;\n        this._settledValue = promise.isResolved()\n            ? promise._settledValue\n            : void 0;\n    }\n    else {\n        this._bitField = 0;\n        this._settledValue = void 0;\n    }\n}\n\nPromiseInspection.prototype.isFulfilled =\nPromise.prototype.isFulfilled = function Promise$isFulfilled() {\n    return (this._bitField & 268435456) > 0;\n};\n\nPromiseInspection.prototype.isRejected =\nPromise.prototype.isRejected = function Promise$isRejected() {\n    return (this._bitField & 134217728) > 0;\n};\n\nPromiseInspection.prototype.isPending =\nPromise.prototype.isPending = function Promise$isPending() {\n    return (this._bitField & 402653184) === 0;\n};\n\nPromiseInspection.prototype.value =\nPromise.prototype.value = function Promise$value() {\n    if (!this.isFulfilled()) {\n        throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.error =\nPromiseInspection.prototype.reason =\nPromise.prototype.reason = function Promise$reason() {\n    if (!this.isRejected()) {\n        throw new TypeError(\"cannot get rejection reason of a non-rejected promise\");\n    }\n    return this._settledValue;\n};\n\nPromiseInspection.prototype.isResolved =\nPromise.prototype.isResolved = function Promise$isResolved() {\n    return (this._bitField & 402653184) > 0;\n};\n\nPromise.PromiseInspection = PromiseInspection;\n};\n\n},{}],136:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function(Promise, INTERNAL) {\nvar util = require(\"./util.js\");\nvar canAttach = require(\"./errors.js\").canAttach;\nvar errorObj = util.errorObj;\nvar isObject = util.isObject;\n\nfunction getThen(obj) {\n    try {\n        return obj.then;\n    }\n    catch(e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nfunction Promise$_Cast(obj, originalPromise) {\n    if (isObject(obj)) {\n        if (obj instanceof Promise) {\n            return obj;\n        }\n        else if (isAnyBluebirdPromise(obj)) {\n            var ret = new Promise(INTERNAL);\n            ret._setTrace(void 0);\n            obj._then(\n                ret._fulfillUnchecked,\n                ret._rejectUncheckedCheckError,\n                ret._progressUnchecked,\n                ret,\n                null\n            );\n            ret._setFollowing();\n            return ret;\n        }\n        var then = getThen(obj);\n        if (then === errorObj) {\n            if (originalPromise !== void 0 && canAttach(then.e)) {\n                originalPromise._attachExtraTrace(then.e);\n            }\n            return Promise.reject(then.e);\n        } else if (typeof then === \"function\") {\n            return Promise$_doThenable(obj, then, originalPromise);\n        }\n    }\n    return obj;\n}\n\nvar hasProp = {}.hasOwnProperty;\nfunction isAnyBluebirdPromise(obj) {\n    return hasProp.call(obj, \"_promise0\");\n}\n\nfunction Promise$_doThenable(x, then, originalPromise) {\n    var resolver = Promise.defer();\n    var called = false;\n    try {\n        then.call(\n            x,\n            Promise$_resolveFromThenable,\n            Promise$_rejectFromThenable,\n            Promise$_progressFromThenable\n        );\n    } catch(e) {\n        if (!called) {\n            called = true;\n            var trace = canAttach(e) ? e : new Error(e + \"\");\n            if (originalPromise !== void 0) {\n                originalPromise._attachExtraTrace(trace);\n            }\n            resolver.promise._reject(e, trace);\n        }\n    }\n    return resolver.promise;\n\n    function Promise$_resolveFromThenable(y) {\n        if (called) return;\n        called = true;\n\n        if (x === y) {\n            var e = Promise._makeSelfResolutionError();\n            if (originalPromise !== void 0) {\n                originalPromise._attachExtraTrace(e);\n            }\n            resolver.promise._reject(e, void 0);\n            return;\n        }\n        resolver.resolve(y);\n    }\n\n    function Promise$_rejectFromThenable(r) {\n        if (called) return;\n        called = true;\n        var trace = canAttach(r) ? r : new Error(r + \"\");\n        if (originalPromise !== void 0) {\n            originalPromise._attachExtraTrace(trace);\n        }\n        resolver.promise._reject(r, trace);\n    }\n\n    function Promise$_progressFromThenable(v) {\n        if (called) return;\n        var promise = resolver.promise;\n        if (typeof promise._progress === \"function\") {\n            promise._progress(v);\n        }\n    }\n}\n\nreturn Promise$_Cast;\n};\n\n},{\"./errors.js\":114,\"./util.js\":139}],137:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar _setTimeout = function(fn, ms) {\n    var len = arguments.length;\n    var arg0 = arguments[2];\n    var arg1 = arguments[3];\n    var arg2 = len >= 5 ? arguments[4] : void 0;\n    setTimeout(function() {\n        fn(arg0, arg1, arg2);\n    }, ms);\n};\n\nmodule.exports = function(Promise, INTERNAL, cast) {\nvar util = require(\"./util.js\");\nvar errors = require(\"./errors.js\");\nvar apiRejection = require(\"./errors_api_rejection\")(Promise);\nvar TimeoutError = Promise.TimeoutError;\n\nvar afterTimeout = function Promise$_afterTimeout(promise, message, ms) {\n    if (!promise.isPending()) return;\n    if (typeof message !== \"string\") {\n        message = \"operation timed out after\" + \" \" + ms + \" ms\"\n    }\n    var err = new TimeoutError(message);\n    errors.markAsOriginatingFromRejection(err);\n    promise._attachExtraTrace(err);\n    promise._cancel(err);\n};\n\nvar afterDelay = function Promise$_afterDelay(value, promise) {\n    promise._fulfill(value);\n};\n\nvar delay = Promise.delay = function Promise$Delay(value, ms) {\n    if (ms === void 0) {\n        ms = value;\n        value = void 0;\n    }\n    ms = +ms;\n    var maybePromise = cast(value, void 0);\n    var promise = new Promise(INTERNAL);\n\n    if (maybePromise instanceof Promise) {\n        promise._propagateFrom(maybePromise, 7);\n        promise._follow(maybePromise);\n        return promise.then(function(value) {\n            return Promise.delay(value, ms);\n        });\n    } else {\n        promise._setTrace(void 0);\n        _setTimeout(afterDelay, ms, value, promise);\n    }\n    return promise;\n};\n\nPromise.prototype.delay = function Promise$delay(ms) {\n    return delay(this, ms);\n};\n\nPromise.prototype.timeout = function Promise$timeout(ms, message) {\n    ms = +ms;\n\n    var ret = new Promise(INTERNAL);\n    ret._propagateFrom(this, 7);\n    ret._follow(this);\n    _setTimeout(afterTimeout, ms, ret, message, ms);\n    return ret.cancellable();\n};\n\n};\n\n},{\"./errors.js\":114,\"./errors_api_rejection\":115,\"./util.js\":139}],138:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nmodule.exports = function (Promise, apiRejection, cast) {\n    var TypeError = require(\"./errors.js\").TypeError;\n    var inherits = require(\"./util.js\").inherits;\n    var PromiseInspection = Promise.PromiseInspection;\n\n    function inspectionMapper(inspections) {\n        var len = inspections.length;\n        for (var i = 0; i < len; ++i) {\n            var inspection = inspections[i];\n            if (inspection.isRejected()) {\n                return Promise.reject(inspection.error());\n            }\n            inspections[i] = inspection.value();\n        }\n        return inspections;\n    }\n\n    function thrower(e) {\n        setTimeout(function(){throw e;}, 0);\n    }\n\n    function dispose(resources, inspection) {\n        var i = 0;\n        var len = resources.length;\n        var ret = Promise.defer();\n        function iterator() {\n            if (i >= len) return ret.resolve();\n            var maybePromise = cast(resources[i++], void 0);\n            if (maybePromise instanceof Promise &&\n                maybePromise._isDisposable()) {\n                try {\n                    maybePromise = cast(maybePromise._getDisposer()\n                                        .tryDispose(inspection), void 0);\n                } catch (e) {\n                    return thrower(e);\n                }\n                if (maybePromise instanceof Promise) {\n                    return maybePromise._then(iterator, thrower,\n                                              null, null, null);\n                }\n            }\n            iterator();\n        }\n        iterator();\n        return ret.promise;\n    }\n\n    function disposerSuccess(value) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = value;\n        inspection._bitField = 268435456;\n        return dispose(this, inspection).thenReturn(value);\n    }\n\n    function disposerFail(reason) {\n        var inspection = new PromiseInspection();\n        inspection._settledValue = reason;\n        inspection._bitField = 134217728;\n        return dispose(this, inspection).thenThrow(reason);\n    }\n\n    function Disposer(data, promise) {\n        this._data = data;\n        this._promise = promise;\n    }\n\n    Disposer.prototype.data = function Disposer$data() {\n        return this._data;\n    };\n\n    Disposer.prototype.promise = function Disposer$promise() {\n        return this._promise;\n    };\n\n    Disposer.prototype.resource = function Disposer$resource() {\n        if (this.promise().isFulfilled()) {\n            return this.promise().value();\n        }\n        return null;\n    };\n\n    Disposer.prototype.tryDispose = function(inspection) {\n        var resource = this.resource();\n        var ret = resource !== null\n            ? this.doDispose(resource, inspection) : null;\n        this._promise._unsetDisposable();\n        this._data = this._promise = null;\n        return ret;\n    };\n\n    function FunctionDisposer(fn, promise) {\n        this.constructor$(fn, promise);\n    }\n    inherits(FunctionDisposer, Disposer);\n\n    FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n        var fn = this.data();\n        return fn.call(resource, resource, inspection);\n    };\n\n    Promise.using = function Promise$using() {\n        var len = arguments.length;\n        if (len < 2) return apiRejection(\n                        \"you must pass at least 2 arguments to Promise.using\");\n        var fn = arguments[len - 1];\n        if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\");\n        len--;\n        var resources = new Array(len);\n        for (var i = 0; i < len; ++i) {\n            var resource = arguments[i];\n            if (resource instanceof Disposer) {\n                var disposer = resource;\n                resource = resource.promise();\n                resource._setDisposable(disposer);\n            }\n            resources[i] = resource;\n        }\n\n        return Promise.settle(resources)\n            .then(inspectionMapper)\n            .spread(fn)\n            ._then(disposerSuccess, disposerFail, void 0, resources, void 0);\n    };\n\n    Promise.prototype._setDisposable =\n    function Promise$_setDisposable(disposer) {\n        this._bitField = this._bitField | 262144;\n        this._disposer = disposer;\n    };\n\n    Promise.prototype._isDisposable = function Promise$_isDisposable() {\n        return (this._bitField & 262144) > 0;\n    };\n\n    Promise.prototype._getDisposer = function Promise$_getDisposer() {\n        return this._disposer;\n    };\n\n    Promise.prototype._unsetDisposable = function Promise$_unsetDisposable() {\n        this._bitField = this._bitField & (~262144);\n        this._disposer = void 0;\n    };\n\n    Promise.prototype.disposer = function Promise$disposer(fn) {\n        if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this);\n        }\n        throw new TypeError();\n    };\n\n};\n\n},{\"./errors.js\":114,\"./util.js\":139}],139:[function(require,module,exports){\n/**\n * Copyright (c) 2014 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:</p>\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\"use strict\";\nvar es5 = require(\"./es5.js\");\nvar haveGetters = (function(){\n    try {\n        var o = {};\n        es5.defineProperty(o, \"f\", {\n            get: function () {\n                return 3;\n            }\n        });\n        return o.f === 3;\n    }\n    catch (e) {\n        return false;\n    }\n\n})();\nvar canEvaluate = typeof navigator == \"undefined\";\nvar errorObj = {e: {}};\nfunction tryCatch1(fn, receiver, arg) {\n    try { return fn.call(receiver, arg); }\n    catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nfunction tryCatch2(fn, receiver, arg, arg2) {\n    try { return fn.call(receiver, arg, arg2); }\n    catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nfunction tryCatch3(fn, receiver, arg, arg2, arg3) {\n    try { return fn.call(receiver, arg, arg2, arg3); }\n    catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nfunction tryCatch4(fn, receiver, arg, arg2, arg3, arg4) {\n    try { return fn.call(receiver, arg, arg2, arg3, arg4); }\n    catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nfunction tryCatchApply(fn, args, receiver) {\n    try { return fn.apply(receiver, args); }\n    catch (e) {\n        errorObj.e = e;\n        return errorObj;\n    }\n}\n\nvar inherits = function(Child, Parent) {\n    var hasProp = {}.hasOwnProperty;\n\n    function T() {\n        this.constructor = Child;\n        this.constructor$ = Parent;\n        for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) &&\n                propertyName.charAt(propertyName.length-1) !== \"$\"\n           ) {\n                this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n        }\n    }\n    T.prototype = Parent.prototype;\n    Child.prototype = new T();\n    return Child.prototype;\n};\n\nfunction asString(val) {\n    return typeof val === \"string\" ? val : (\"\" + val);\n}\n\nfunction isPrimitive(val) {\n    return val == null || val === true || val === false ||\n        typeof val === \"string\" || typeof val === \"number\";\n\n}\n\nfunction isObject(value) {\n    return !isPrimitive(value);\n}\n\nfunction maybeWrapAsError(maybeError) {\n    if (!isPrimitive(maybeError)) return maybeError;\n\n    return new Error(asString(maybeError));\n}\n\nfunction withAppended(target, appendee) {\n    var len = target.length;\n    var ret = new Array(len + 1);\n    var i;\n    for (i = 0; i < len; ++i) {\n        ret[i] = target[i];\n    }\n    ret[i] = appendee;\n    return ret;\n}\n\nfunction getDataPropertyOrDefault(obj, key, defaultValue) {\n    if (es5.isES5) {\n        var desc = Object.getOwnPropertyDescriptor(obj, key);\n        if (desc != null) {\n            return desc.get == null && desc.set == null\n                    ? desc.value\n                    : defaultValue;\n        }\n    } else {\n        return {}.hasOwnProperty.call(obj, key) ? obj[key] : void 0;\n    }\n}\n\nfunction notEnumerableProp(obj, name, value) {\n    if (isPrimitive(obj)) return obj;\n    var descriptor = {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    };\n    es5.defineProperty(obj, name, descriptor);\n    return obj;\n}\n\n\nvar wrapsPrimitiveReceiver = (function() {\n    return this !== \"string\";\n}).call(\"string\");\n\nfunction thrower(r) {\n    throw r;\n}\n\nvar inheritedDataKeys = (function() {\n    if (es5.isES5) {\n        return function(obj, opts) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n            var getKeys = Object(opts).includeHidden\n                ? Object.getOwnPropertyNames\n                : Object.keys;\n            while (obj != null) {\n                var keys;\n                try {\n                    keys = getKeys(obj);\n                } catch (e) {\n                    return ret;\n                }\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    if (visitedKeys[key]) continue;\n                    visitedKeys[key] = true;\n                    var desc = Object.getOwnPropertyDescriptor(obj, key);\n                    if (desc != null && desc.get == null && desc.set == null) {\n                        ret.push(key);\n                    }\n                }\n                obj = es5.getPrototypeOf(obj);\n            }\n            return ret;\n        };\n    } else {\n        return function(obj) {\n            var ret = [];\n            /*jshint forin:false */\n            for (var key in obj) {\n                ret.push(key);\n            }\n            return ret;\n        };\n    }\n\n})();\n\nfunction isClass(fn) {\n    try {\n        if (typeof fn === \"function\") {\n            var keys = es5.keys(fn.prototype);\n            return keys.length > 0 &&\n                   !(keys.length === 1 && keys[0] === \"constructor\");\n        }\n        return false;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction toFastProperties(obj) {\n    /*jshint -W027*/\n    function f() {}\n    f.prototype = obj;\n    return f;\n    eval(obj);\n}\n\nvar rident = /^[a-z$_][a-z$_0-9]*$/i;\nfunction isIdentifier(str) {\n    return rident.test(str);\n}\n\nfunction filledRange(count, prefix, suffix) {\n    var ret = new Array(count);\n    for(var i = 0; i < count; ++i) {\n        ret[i] = prefix + i + suffix;\n    }\n    return ret;\n}\n\nvar ret = {\n    isClass: isClass,\n    isIdentifier: isIdentifier,\n    inheritedDataKeys: inheritedDataKeys,\n    getDataPropertyOrDefault: getDataPropertyOrDefault,\n    thrower: thrower,\n    isArray: es5.isArray,\n    haveGetters: haveGetters,\n    notEnumerableProp: notEnumerableProp,\n    isPrimitive: isPrimitive,\n    isObject: isObject,\n    canEvaluate: canEvaluate,\n    errorObj: errorObj,\n    tryCatch1: tryCatch1,\n    tryCatch2: tryCatch2,\n    tryCatch3: tryCatch3,\n    tryCatch4: tryCatch4,\n    tryCatchApply: tryCatchApply,\n    inherits: inherits,\n    withAppended: withAppended,\n    asString: asString,\n    maybeWrapAsError: maybeWrapAsError,\n    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,\n    toFastProperties: toFastProperties,\n    filledRange: filledRange\n};\n\nmodule.exports = ret;\n\n},{\"./es5.js\":116}],140:[function(require,module,exports){\n'use strict';\n\n\nvar yaml = require('./lib/js-yaml.js');\n\n\nmodule.exports = yaml;\n\n},{\"./lib/js-yaml.js\":141}],141:[function(require,module,exports){\n'use strict';\n\n\nvar loader = require('./js-yaml/loader');\nvar dumper = require('./js-yaml/dumper');\n\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\n\nmodule.exports.Type                = require('./js-yaml/type');\nmodule.exports.Schema              = require('./js-yaml/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');\nmodule.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.safeLoad            = loader.safeLoad;\nmodule.exports.safeLoadAll         = loader.safeLoadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.safeDump            = dumper.safeDump;\nmodule.exports.YAMLException       = require('./js-yaml/exception');\n\n// Deprecared schema names from JS-YAML 2.0.x\nmodule.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\nmodule.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n// Deprecated functions from JS-YAML 1.x.x\nmodule.exports.scan           = deprecated('scan');\nmodule.exports.parse          = deprecated('parse');\nmodule.exports.compose        = deprecated('compose');\nmodule.exports.addConstructor = deprecated('addConstructor');\n\n},{\"./js-yaml/dumper\":143,\"./js-yaml/exception\":144,\"./js-yaml/loader\":145,\"./js-yaml/schema\":147,\"./js-yaml/schema/core\":148,\"./js-yaml/schema/default_full\":149,\"./js-yaml/schema/default_safe\":150,\"./js-yaml/schema/failsafe\":151,\"./js-yaml/schema/json\":152,\"./js-yaml/type\":153}],142:[function(require,module,exports){\n'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (null === subject);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (null !== subject);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) {\n    return sequence;\n  } else if (isNothing(sequence)) {\n    return [];\n  }\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n\n},{}],143:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (null === map) {\n    return {};\n  }\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if ('!!' === tag.slice(0, 2)) {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap[tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent      = Math.max(1, (options['indent'] || 2));\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys    = options['sortKeys'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n    if (line.length && line !== '\\n') {\n      result += ind;\n    }\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction StringBuilder(source) {\n  this.source = source;\n  this.result = '';\n  this.checkpoint = 0;\n}\n\nStringBuilder.prototype.takeUpTo = function (position) {\n  var er;\n\n  if (position < this.checkpoint) {\n    er = new Error('position should be > checkpoint');\n    er.position = position;\n    er.checkpoint = this.checkpoint;\n    throw er;\n  }\n\n  this.result += this.source.slice(this.checkpoint, position);\n  this.checkpoint = position;\n  return this;\n};\n\nStringBuilder.prototype.escapeChar = function () {\n  var character, esc;\n\n  character = this.source.charCodeAt(this.checkpoint);\n  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);\n  this.result += esc;\n  this.checkpoint += 1;\n\n  return this;\n};\n\nStringBuilder.prototype.finish = function () {\n  if (this.source.length > this.checkpoint) {\n    this.takeUpTo(this.source.length);\n  }\n};\n\nfunction writeScalar(state, object, level) {\n  var simple, first, spaceWrap, folded, literal, single, double,\n      sawLineFeed, linePosition, longestLine, indent, max, character,\n      position, escapeSeq, hexEsc, previous, lineLength, modifier,\n      trailingLineBreaks, result;\n\n  if (0 === object.length) {\n    state.dump = \"''\";\n    return;\n  }\n\n  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {\n    state.dump = \"'\" + object + \"'\";\n    return;\n  }\n\n  simple = true;\n  first = object.length ? object.charCodeAt(0) : 0;\n  spaceWrap = (CHAR_SPACE === first ||\n               CHAR_SPACE === object.charCodeAt(object.length - 1));\n\n  // Simplified check for restricted first characters\n  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29\n  if (CHAR_MINUS         === first ||\n      CHAR_QUESTION      === first ||\n      CHAR_COMMERCIAL_AT === first ||\n      CHAR_GRAVE_ACCENT  === first) {\n    simple = false;\n  }\n\n  // can only use > and | if not wrapped in spaces.\n  if (spaceWrap) {\n    simple = false;\n    folded = false;\n    literal = false;\n  } else {\n    folded = true;\n    literal = true;\n  }\n\n  single = true;\n  double = new StringBuilder(object);\n\n  sawLineFeed = false;\n  linePosition = 0;\n  longestLine = 0;\n\n  indent = state.indent * level;\n  max = 80;\n  if (indent < 40) {\n    max -= indent;\n  } else {\n    max = 40;\n  }\n\n  for (position = 0; position < object.length; position++) {\n    character = object.charCodeAt(position);\n    if (simple) {\n      // Characters that can never appear in the simple scalar\n      if (!simpleChar(character)) {\n        simple = false;\n      } else {\n        // Still simple.  If we make it all the way through like\n        // this, then we can just dump the string as-is.\n        continue;\n      }\n    }\n\n    if (single && character === CHAR_SINGLE_QUOTE) {\n      single = false;\n    }\n\n    escapeSeq = ESCAPE_SEQUENCES[character];\n    hexEsc = needsHexEscape(character);\n\n    if (!escapeSeq && !hexEsc) {\n      continue;\n    }\n\n    if (character !== CHAR_LINE_FEED &&\n        character !== CHAR_DOUBLE_QUOTE &&\n        character !== CHAR_SINGLE_QUOTE) {\n      folded = false;\n      literal = false;\n    } else if (character === CHAR_LINE_FEED) {\n      sawLineFeed = true;\n      single = false;\n      if (position > 0) {\n        previous = object.charCodeAt(position - 1);\n        if (previous === CHAR_SPACE) {\n          literal = false;\n          folded = false;\n        }\n      }\n      if (folded) {\n        lineLength = position - linePosition;\n        linePosition = position;\n        if (lineLength > longestLine) {\n          longestLine = lineLength;\n        }\n      }\n    }\n\n    if (character !== CHAR_DOUBLE_QUOTE) {\n      single = false;\n    }\n\n    double.takeUpTo(position);\n    double.escapeChar();\n  }\n\n  if (simple && testImplicitResolving(state, object)) {\n    simple = false;\n  }\n\n  modifier = '';\n  if (folded || literal) {\n    trailingLineBreaks = 0;\n    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {\n      trailingLineBreaks += 1;\n      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {\n        trailingLineBreaks += 1;\n      }\n    }\n\n    if (trailingLineBreaks === 0) {\n      modifier = '-';\n    } else if (trailingLineBreaks === 2) {\n      modifier = '+';\n    }\n  }\n\n  if (literal && longestLine < max) {\n    folded = false;\n  }\n\n  // If it's literally one line, then don't bother with the literal.\n  // We may still want to do a fold, though, if it's a super long line.\n  if (!sawLineFeed) {\n    literal = false;\n  }\n\n  if (simple) {\n    state.dump = object;\n  } else if (single) {\n    state.dump = '\\'' + object + '\\'';\n  } else if (folded) {\n    result = fold(object, max);\n    state.dump = '>' + modifier + '\\n' + indentString(result, indent);\n  } else if (literal) {\n    if (!modifier) {\n      object = object.replace(/\\n$/, '');\n    }\n    state.dump = '|' + modifier + '\\n' + indentString(object, indent);\n  } else if (double) {\n    double.finish();\n    state.dump = '\"' + double.result + '\"';\n  } else {\n    throw new Error('Failed to dump scalar value');\n  }\n\n  return;\n}\n\n// The `trailing` var is a regexp match of any trailing `\\n` characters.\n//\n// There are three cases we care about:\n//\n// 1. One trailing `\\n` on the string.  Just use `|` or `>`.\n//    This is the assumed default. (trailing = null)\n// 2. No trailing `\\n` on the string.  Use `|-` or `>-` to \"chomp\" the end.\n// 3. More than one trailing `\\n` on the string.  Use `|+` or `>+`.\n//\n// In the case of `>+`, these line breaks are *not* doubled (like the line\n// breaks within the string), so it's important to only end with the exact\n// same number as we started.\nfunction fold(object, max) {\n  var result = '',\n      position = 0,\n      length = object.length,\n      trailing = /\\n+$/.exec(object),\n      newLine;\n\n  if (trailing) {\n    length = trailing.index + 1;\n  }\n\n  while (position < length) {\n    newLine = object.indexOf('\\n', position);\n    if (newLine > length || newLine === -1) {\n      if (result) {\n        result += '\\n\\n';\n      }\n      result += foldLine(object.slice(position, length), max);\n      position = length;\n    } else {\n      if (result) {\n        result += '\\n\\n';\n      }\n      result += foldLine(object.slice(position, newLine), max);\n      position = newLine + 1;\n    }\n  }\n  if (trailing && trailing[0] !== '\\n') {\n    result += trailing[0];\n  }\n\n  return result;\n}\n\nfunction foldLine(line, max) {\n  if (line === '') {\n    return line;\n  }\n\n  var foldRe = /[^\\s] [^\\s]/g,\n      result = '',\n      prevMatch = 0,\n      foldStart = 0,\n      match = foldRe.exec(line),\n      index,\n      foldEnd,\n      folded;\n\n  while (match) {\n    index = match.index;\n\n    // when we cross the max len, if the previous match would've\n    // been ok, use that one, and carry on.  If there was no previous\n    // match on this fold section, then just have a long line.\n    if (index - foldStart > max) {\n      if (prevMatch !== foldStart) {\n        foldEnd = prevMatch;\n      } else {\n        foldEnd = index;\n      }\n\n      if (result) {\n        result += '\\n';\n      }\n      folded = line.slice(foldStart, foldEnd);\n      result += folded;\n      foldStart = foldEnd + 1;\n    }\n    prevMatch = index + 1;\n    match = foldRe.exec(line);\n  }\n\n  if (result) {\n    result += '\\n';\n  }\n\n  // if we end up with one last word at the end, then the last bit might\n  // be slightly bigger than we wanted, because we exited out of the loop.\n  if (foldStart !== prevMatch && line.length - foldStart > max) {\n    result += line.slice(foldStart, prevMatch) + '\\n' +\n              line.slice(prevMatch + 1);\n  } else {\n    result += line.slice(foldStart);\n  }\n\n  return result;\n}\n\n// Returns true if character can be found in a simple scalar\nfunction simpleChar(character) {\n  return CHAR_TAB                  !== character &&\n         CHAR_LINE_FEED            !== character &&\n         CHAR_CARRIAGE_RETURN      !== character &&\n         CHAR_COMMA                !== character &&\n         CHAR_LEFT_SQUARE_BRACKET  !== character &&\n         CHAR_RIGHT_SQUARE_BRACKET !== character &&\n         CHAR_LEFT_CURLY_BRACKET   !== character &&\n         CHAR_RIGHT_CURLY_BRACKET  !== character &&\n         CHAR_SHARP                !== character &&\n         CHAR_AMPERSAND            !== character &&\n         CHAR_ASTERISK             !== character &&\n         CHAR_EXCLAMATION          !== character &&\n         CHAR_VERTICAL_LINE        !== character &&\n         CHAR_GREATER_THAN         !== character &&\n         CHAR_SINGLE_QUOTE         !== character &&\n         CHAR_DOUBLE_QUOTE         !== character &&\n         CHAR_PERCENT              !== character &&\n         CHAR_COLON                !== character &&\n         !ESCAPE_SEQUENCES[character]            &&\n         !needsHexEscape(character);\n}\n\n// Returns true if the character code needs to be escaped.\nfunction needsHexEscape(character) {\n  return !((0x00020 <= character && character <= 0x00007E) ||\n           (0x00085 === character)                         ||\n           (0x000A0 <= character && character <= 0x00D7FF) ||\n           (0x0E000 <= character && character <= 0x00FFFD) ||\n           (0x10000 <= character && character <= 0x10FFFF));\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (0 !== index) {\n        _result += ', ';\n      }\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || 0 !== index) {\n        _result += generateNextLine(state, level);\n      }\n      _result += '- ' + state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (0 !== index) {\n      pairBuffer += ', ';\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) {\n      pairBuffer += '? ';\n    }\n\n    pairBuffer += state.dump + ': ';\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || 0 !== index) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (null !== state.tag && '?' !== state.tag) ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if ('[object Function]' === _toString.call(type.represent)) {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (0 > state.flowLevel || state.flowLevel > level);\n  }\n\n  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {\n    compact = false;\n  }\n\n  var objectOrArray = '[object Object]' === type || '[object Array]' === type,\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if ('[object Object]' === type) {\n      if (block && (0 !== Object.keys(state.dump).length)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\\n' : '') + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if ('[object Array]' === type) {\n      if (block && (0 !== state.dump.length)) {\n        writeBlockSequence(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\\n' : '') + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if ('[object String]' === type) {\n      if ('?' !== state.tag) {\n        writeScalar(state, state.dump, level);\n      }\n    } else {\n      if (state.skipInvalid) {\n        return false;\n      }\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (null !== state.tag && '?' !== state.tag) {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var type = _toString.call(object),\n      objectKeyList,\n      index,\n      length;\n\n  if (null !== object && 'object' === typeof object) {\n    index = objects.indexOf(object);\n    if (-1 !== index) {\n      if (-1 === duplicatesIndexes.indexOf(index)) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) {\n    return state.dump + '\\n';\n  }\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n\n},{\"./common\":142,\"./exception\":144,\"./schema/default_full\":149,\"./schema/default_safe\":150}],144:[function(require,module,exports){\n'use strict';\n\n\nfunction YAMLException(reason, mark) {\n  this.name    = 'YAMLException';\n  this.reason  = reason;\n  this.mark    = mark;\n  this.message = this.toString(false);\n}\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result;\n\n  result = 'JS-YAML: ' + (this.reason || '(unknown reason)');\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\n\nmodule.exports = YAMLException;\n\n},{}],145:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar Mark                = require('./mark');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return 0x2C/* , */ === c ||\n         0x5B/* [ */ === c ||\n         0x5D/* ] */ === c ||\n         0x7B/* { */ === c ||\n         0x7D/* } */ === c;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,\n                             ((c - 0x010000) & 0x03FF) + 0xDC00);\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy    = options['legacy']    || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  return new YAMLException(\n    message,\n    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  var error = generateError(state, message);\n\n  if (state.onWarning) {\n    state.onWarning.call(null, error);\n  } else {\n    throw error;\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n      var match, major, minor;\n\n      if (null !== state.version) {\n        throwError(state, 'duplication of %YAML directive');\n      }\n\n      if (1 !== args.length) {\n        throwError(state, 'YAML directive accepts exactly one argument');\n      }\n\n      match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n      if (null === match) {\n        throwError(state, 'ill-formed argument of the YAML directive');\n      }\n\n      major = parseInt(match[1], 10);\n      minor = parseInt(match[2], 10);\n\n      if (1 !== major) {\n        throwError(state, 'unacceptable YAML version of the document');\n      }\n\n      state.version = args[0];\n      state.checkLineBreaks = (minor < 2);\n\n      if (1 !== minor && 2 !== minor) {\n        throwWarning(state, 'unsupported YAML version of the document');\n      }\n    },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n      var handle, prefix;\n\n      if (2 !== args.length) {\n        throwError(state, 'TAG directive accepts exactly two arguments');\n      }\n\n      handle = args[0];\n      prefix = args[1];\n\n      if (!PATTERN_TAG_HANDLE.test(handle)) {\n        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n      }\n\n      if (_hasOwnProperty.call(state.tagMap, handle)) {\n        throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n      }\n\n      if (!PATTERN_TAG_URI.test(prefix)) {\n        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n      }\n\n      state.tagMap[handle] = prefix;\n    }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length;\n           _position < _length;\n           _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(0x09 === _character ||\n              0x20 <= _character && _character <= 0x10FFFF)) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, keyTag, keyNode, valueNode) {\n  var index, quantity;\n\n  keyNode = String(keyNode);\n\n  if (null === _result) {\n    _result = {};\n  }\n\n  if ('tag:yaml.org,2002:merge' === keyTag) {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index]);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode);\n    }\n  } else {\n    _result[keyNode] = valueNode;\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (0x0A/* LF */ === ch) {\n    state.position++;\n  } else if (0x0D/* CR */ === ch) {\n    state.position++;\n    if (0x0A/* LF */ === state.input.charCodeAt(state.position)) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (0 !== ch) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && 0x23/* # */ === ch) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && 0 !== ch);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (0x20/* Space */ === ch) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((0x2D/* - */ === ch || 0x2E/* . */ === ch) &&\n      state.input.charCodeAt(_position + 1) === ch &&\n      state.input.charCodeAt(_position + 2) === ch) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (1 === count) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)             ||\n      is_FLOW_INDICATOR(ch)        ||\n      0x23/* # */           === ch ||\n      0x26/* & */           === ch ||\n      0x2A/* * */           === ch ||\n      0x21/* ! */           === ch ||\n      0x7C/* | */           === ch ||\n      0x3E/* > */           === ch ||\n      0x27/* ' */           === ch ||\n      0x22/* \" */           === ch ||\n      0x25/* % */           === ch ||\n      0x40/* @ */           === ch ||\n      0x60/* ` */           === ch) {\n    return false;\n  }\n\n  if (0x3F/* ? */ === ch || 0x2D/* - */ === ch) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (0 !== ch) {\n    if (0x3A/* : */ === ch) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (0x23/* # */ === ch) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (0x27/* ' */ !== ch) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while (0 !== (ch = state.input.charCodeAt(state.position))) {\n    if (0x27/* ' */ === ch) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (0x27/* ' */ === ch) {\n        captureStart = captureEnd = state.position;\n        state.position++;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp, tmpEsc,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (0x22/* \" */ !== ch) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while (0 !== (ch = state.input.charCodeAt(state.position))) {\n    if (0x22/* \" */ === ch) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (0x5C/* \\ */ === ch) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (null !== state.anchor) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (0 !== ch) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (0x3F/* ? */ === ch) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && 0x3A/* : */ === ch) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (0x2C/* , */ === ch) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (0 !== ch) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (0x2B/* + */ === ch || 0x2D/* - */ === ch) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (0x2B/* + */ === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (0x23/* # */ === ch) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (0 !== ch));\n    }\n  }\n\n  while (0 !== ch) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (0x20/* Space */ === ch)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (detectedIndent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (0 === emptyLines) {\n        if (detectedIndent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else if (detectedIndent) {\n      // If current line isn't the first one - count line break from the last content line.\n      state.result += common.repeat('\\n', emptyLines + 1);\n    } else {\n      // In case of the first content line - count only empty lines.\n    }\n\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (0 !== ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  if (null !== state.anchor) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (0 !== ch) {\n\n    if (0x2D/* - */ !== ch) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  if (null !== state.anchor) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (0 !== ch) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((0x3F/* ? */ === ch || 0x3A/* : */  === ch) && is_WS_OR_EOL(following)) {\n\n      if (0x3F/* ? */ === ch) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, keyTag, keyNode, null);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (0x3A/* : */ === ch) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n\n    } else {\n      break; // Reading is done. Go to the epilogue.\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, keyTag, keyNode, valueNode);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && (0 !== ch)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, keyTag, keyNode, null);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (0x21/* ! */ !== ch) {\n    return false;\n  }\n\n  if (null !== state.tag) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (0x3C/* < */ === ch) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (0x21/* ! */ === ch) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (0 !== ch && 0x3E/* > */ !== ch);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (0 !== ch && !is_WS_OR_EOL(ch)) {\n\n      if (0x21/* ! */ === ch) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if ('!' === tagHandle) {\n    state.tag = '!' + tagName;\n\n  } else if ('!!' === tagHandle) {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (0x26/* & */ !== ch) {\n    return false;\n  }\n\n  if (null !== state.anchor) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      len = state.length,\n      input = state.input,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (0x2A/* * */ !== ch) {\n    return false;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!state.anchorMap.hasOwnProperty(alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent,\n      _result;\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (1 === indentStatus) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (1 === indentStatus) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (null !== state.tag || null !== state.anchor) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (null === state.tag) {\n            state.tag = '?';\n          }\n        }\n\n        if (null !== state.anchor) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (0 === indentStatus) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (null !== state.tag && '!' !== state.tag) {\n    if ('?' === state.tag) {\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;\n           typeIndex < typeQuantity;\n           typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        // Implicit resolving is not allowed for non-scalar types, and '?'\n        // non-specific tag is only assigned to plain scalars. So, it isn't\n        // needed to check for 'kind' conformity.\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (null !== state.anchor) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {\n      type = state.typeMap[state.tag];\n\n      if (null !== state.result && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n        if (null !== state.anchor) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwWarning(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  return null !== state.tag || null !== state.anchor || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while (0 !== (ch = state.input.charCodeAt(state.position))) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || 0x25/* % */ !== ch) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (0 !== ch && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (0 !== ch) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (0x23/* # */ === ch) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (0 !== ch && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) {\n        break;\n      }\n\n      _position = state.position;\n\n      while (0 !== ch && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (0 !== ch) {\n      readLineBreak(state);\n    }\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (0 === state.lineIndent &&\n      0x2D/* - */ === state.input.charCodeAt(state.position) &&\n      0x2D/* - */ === state.input.charCodeAt(state.position + 1) &&\n      0x2D/* - */ === state.input.charCodeAt(state.position + 2)) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (0x2E/* . */ === state.input.charCodeAt(state.position)) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (0x0A/* LF */ !== input.charCodeAt(input.length - 1) &&\n        0x0D/* CR */ !== input.charCodeAt(input.length - 1)) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  if (PATTERN_NON_PRINTABLE.test(state.input)) {\n    throwError(state, 'the stream contains non-printable characters');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (0x20/* Space */ === state.input.charCodeAt(state.position)) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  var documents = loadDocuments(input, options), index, length;\n\n  for (index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options), index, length;\n\n  if (0 === documents.length) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (1 === documents.length) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nfunction safeLoadAll(input, output, options) {\n  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nmodule.exports.loadAll     = loadAll;\nmodule.exports.load        = load;\nmodule.exports.safeLoadAll = safeLoadAll;\nmodule.exports.safeLoad    = safeLoad;\n\n},{\"./common\":142,\"./exception\":144,\"./mark\":146,\"./schema/default_full\":149,\"./schema/default_safe\":150}],146:[function(require,module,exports){\n'use strict';\n\n\nvar common = require('./common');\n\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name     = name;\n  this.buffer   = buffer;\n  this.position = position;\n  this.line     = line;\n  this.column   = column;\n}\n\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n\n  if (!this.buffer) {\n    return null;\n  }\n\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n\n  head = '';\n  start = this.position;\n\n  while (start > 0 && -1 === '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1))) {\n    start -= 1;\n    if (this.position - start > (maxLength / 2 - 1)) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && -1 === '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end))) {\n    end += 1;\n    if (end - this.position > (maxLength / 2 - 1)) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n         common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\n\nMark.prototype.toString = function toString(compact) {\n  var snippet, where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\n\nmodule.exports = Mark;\n\n},{\"./common\":142}],147:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return -1 === exclude.indexOf(index);\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {}, index, length;\n\n  function collectType(type) {\n    result[type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && 'scalar' !== type.loadKind) {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n  case 1:\n    schemas = Schema.DEFAULT;\n    types = arguments[0];\n    break;\n\n  case 2:\n    schemas = arguments[0];\n    types = arguments[1];\n    break;\n\n  default:\n    throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n\n},{\"./common\":142,\"./exception\":144,\"./type\":153}],148:[function(require,module,exports){\n// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./json')\n  ]\n});\n\n},{\"../schema\":147,\"./json\":152}],149:[function(require,module,exports){\n// JS-YAML's default schema for `load` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on JS-YAML's default safe schema and includes\n// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n//\n// Also this schema is used as default base schema at `Schema.create` function.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = Schema.DEFAULT = new Schema({\n  include: [\n    require('./default_safe')\n  ],\n  explicit: [\n    require('../type/js/undefined'),\n    require('../type/js/regexp'),\n    require('../type/js/function')\n  ]\n});\n\n},{\"../schema\":147,\"../type/js/function\":158,\"../type/js/regexp\":159,\"../type/js/undefined\":160,\"./default_safe\":150}],150:[function(require,module,exports){\n// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./core')\n  ],\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n\n},{\"../schema\":147,\"../type/binary\":154,\"../type/merge\":162,\"../type/omap\":164,\"../type/pairs\":165,\"../type/set\":167,\"../type/timestamp\":169,\"./core\":148}],151:[function(require,module,exports){\n// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n\n},{\"../schema\":147,\"../type/map\":161,\"../type/seq\":166,\"../type/str\":168}],152:[function(require,module,exports){\n// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./failsafe')\n  ],\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n\n},{\"../schema\":147,\"../type/bool\":155,\"../type/float\":156,\"../type/int\":157,\"../type/null\":163,\"./failsafe\":151}],153:[function(require,module,exports){\n'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (null !== map) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag          = tag;\n  this.kind         = options['kind']         || null;\n  this.resolve      = options['resolve']      || function () { return true; };\n  this.construct    = options['construct']    || function (data) { return data; };\n  this.instanceOf   = options['instanceOf']   || null;\n  this.predicate    = options['predicate']    || null;\n  this.represent    = options['represent']    || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n\n},{\"./exception\":144}],154:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable no-bitwise*/\n\n// A trick for browserified version.\n// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined\nvar NodeBuffer = require('buffer').Buffer;\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (null === data) {\n    return false;\n  }\n\n  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) { continue; }\n\n    // Fail on illegal characters\n    if (code < 0) { return false; }\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var code, idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    return new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\n},{\"../type\":153,\"buffer\":2}],155:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (null === data) {\n    return false;\n  }\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return '[object Boolean]' === Object.prototype.toString.call(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\n},{\"../type\":153}],156:[function(require,module,exports){\n'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  '^(?:[-+]?(?:[0-9][0-9_]*)\\\\.[0-9_]*(?:[eE][-+][0-9]+)?' +\n  '|\\\\.[0-9_]+(?:[eE][-+][0-9]+)?' +\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (null === data) {\n    return false;\n  }\n\n  var value, sign, base, digits;\n\n  if (!YAML_FLOAT_PATTERN.test(data)) {\n    return false;\n  }\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = '-' === value[0] ? -1 : 1;\n  digits = [];\n\n  if (0 <= '+-'.indexOf(value[0])) {\n    value = value.slice(1);\n  }\n\n  if ('.inf' === value) {\n    return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if ('.nan' === value) {\n    return NaN;\n\n  } else if (0 <= value.indexOf(':')) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\nfunction representYamlFloat(object, style) {\n  if (isNaN(object)) {\n    switch (style) {\n    case 'lowercase':\n      return '.nan';\n    case 'uppercase':\n      return '.NAN';\n    case 'camelcase':\n      return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n    case 'lowercase':\n      return '.inf';\n    case 'uppercase':\n      return '.INF';\n    case 'camelcase':\n      return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n    case 'lowercase':\n      return '-.inf';\n    case 'uppercase':\n      return '-.INF';\n    case 'camelcase':\n      return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n  return object.toString(10);\n}\n\nfunction isFloat(object) {\n  return ('[object Number]' === Object.prototype.toString.call(object)) &&\n         (0 !== object % 1 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\n},{\"../common\":142,\"../type\":153}],157:[function(require,module,exports){\n'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (null === data) {\n    return false;\n  }\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) { return false; }\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) { return true; }\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') { continue; }\n        if (ch !== '0' && ch !== '1') {\n          return false;\n        }\n        hasDigits = true;\n      }\n      return hasDigits;\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') { continue; }\n        if (!isHexCode(data.charCodeAt(index))) {\n          return false;\n        }\n        hasDigits = true;\n      }\n      return hasDigits;\n    }\n\n    // base 8\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') { continue; }\n      if (!isOctCode(data.charCodeAt(index))) {\n        return false;\n      }\n      hasDigits = true;\n    }\n    return hasDigits;\n  }\n\n  // base 10 (except 0) or base 60\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') { continue; }\n    if (ch === ':') { break; }\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  if (!hasDigits) { return false; }\n\n  // if !base60 - done;\n  if (ch !== ':') { return true; }\n\n  // base60 almost not used, no needs to optimize\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch, base, digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') { sign = -1; }\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if ('0' === value) {\n    return 0;\n  }\n\n  if (ch === '0') {\n    if (value[1] === 'b') {\n      return sign * parseInt(value.slice(2), 2);\n    }\n    if (value[1] === 'x') {\n      return sign * parseInt(value, 16);\n    }\n    return sign * parseInt(value, 8);\n\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n\n    value = 0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += (d * base);\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return ('[object Number]' === Object.prototype.toString.call(object)) &&\n         (0 === object % 1 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (object) { return '0b' + object.toString(2); },\n    octal:       function (object) { return '0'  + object.toString(8); },\n    decimal:     function (object) { return        object.toString(10); },\n    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\n},{\"../common\":142,\"../type\":153}],158:[function(require,module,exports){\n'use strict';\n\nvar esprima;\n\n// Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\ntry {\n  esprima = require('esprima');\n} catch (_) {\n  /*global window */\n  if (typeof window !== 'undefined') { esprima = window.esprima; }\n}\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptFunction(data) {\n  if (null === data) {\n    return false;\n  }\n\n  try {\n    var source = '(' + data + ')',\n        ast    = esprima.parse(source, { range: true }),\n        params = [],\n        body;\n\n    if ('Program'             !== ast.type         ||\n        1                     !== ast.body.length  ||\n        'ExpressionStatement' !== ast.body[0].type ||\n        'FunctionExpression'  !== ast.body[0].expression.type) {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n\n  var source = '(' + data + ')',\n      ast    = esprima.parse(source, { range: true }),\n      params = [],\n      body;\n\n  if ('Program'             !== ast.type         ||\n      1                     !== ast.body.length  ||\n      'ExpressionStatement' !== ast.body[0].type ||\n      'FunctionExpression'  !== ast.body[0].expression.type) {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n\n  body = ast.body[0].expression.body.range;\n\n  // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n  /*eslint-disable no-new-func*/\n  return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n}\n\nfunction representJavascriptFunction(object /*, style*/) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return '[object Function]' === Object.prototype.toString.call(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n\n},{\"../../type\":153,\"esprima\":170}],159:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptRegExp(data) {\n  if (null === data) {\n    return false;\n  }\n\n  if (0 === data.length) {\n    return false;\n  }\n\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n  if ('/' === regexp[0]) {\n    if (tail) {\n      modifiers = tail[1];\n    }\n\n    if (modifiers.length > 3) { return false; }\n    // if expression starts with /, is should be properly terminated\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') { return false; }\n\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  try {\n    var dummy = new RegExp(regexp, modifiers);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // `/foo/gim` - tail can be maximum 4 chars\n  if ('/' === regexp[0]) {\n    if (tail) {\n      modifiers = tail[1];\n    }\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object /*, style*/) {\n  var result = '/' + object.source + '/';\n\n  if (object.global) {\n    result += 'g';\n  }\n\n  if (object.multiline) {\n    result += 'm';\n  }\n\n  if (object.ignoreCase) {\n    result += 'i';\n  }\n\n  return result;\n}\n\nfunction isRegExp(object) {\n  return '[object RegExp]' === Object.prototype.toString.call(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n\n},{\"../../type\":153}],160:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return 'undefined' === typeof object;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n\n},{\"../../type\":153}],161:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return null !== data ? data : {}; }\n});\n\n},{\"../type\":153}],162:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return '<<' === data || null === data;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n},{\"../type\":153}],163:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (null === data) {\n    return true;\n  }\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return null === object;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\n},{\"../type\":153}],164:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (null === data) {\n    return true;\n  }\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if ('[object Object]' !== _toString.call(pair)) {\n      return false;\n    }\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) {\n          pairHasKey = true;\n        } else {\n          return false;\n        }\n      }\n    }\n\n    if (!pairHasKey) {\n      return false;\n    }\n\n    if (-1 === objectKeys.indexOf(pairKey)) {\n      objectKeys.push(pairKey);\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return null !== data ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\n},{\"../type\":153}],165:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (null === data) {\n    return true;\n  }\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if ('[object Object]' !== _toString.call(pair)) {\n      return false;\n    }\n\n    keys = Object.keys(pair);\n\n    if (1 !== keys.length) {\n      return false;\n    }\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (null === data) {\n    return [];\n  }\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\n},{\"../type\":153}],166:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return null !== data ? data : []; }\n});\n\n},{\"../type\":153}],167:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (null === data) {\n    return true;\n  }\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (null !== object[key]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return null !== data ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\n},{\"../type\":153}],168:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return null !== data ? data : ''; }\n});\n\n},{\"../type\":153}],169:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:(?:[Tt]|[ \\\\t]+)'              + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?)?$');         // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (null === data) {\n    return false;\n  }\n\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (null === match) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (null === match) {\n    throw new Error('Date resolve error');\n  }\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if ('-' === match[9]) {\n      delta = -delta;\n    }\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) {\n    date.setTime(date.getTime() - delta);\n  }\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\n},{\"../type\":153}],170:[function(require,module,exports){\n/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PlaceHolders,\n        Messages,\n        Regex,\n        source,\n        strict,\n        sourceType,\n        index,\n        lineNumber,\n        lineStart,\n        hasLineTerminator,\n        lastIndex,\n        lastLineNumber,\n        lastLineStart,\n        startIndex,\n        startLineNumber,\n        startLineStart,\n        scanning,\n        length,\n        lookahead,\n        state,\n        extra,\n        isBindingElement,\n        isAssignmentTarget,\n        firstCoverInitializedNameError;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Template] = 'Template';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PlaceHolders = {\n        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n        DefaultRestParameter: 'Unexpected token =',\n        ObjectPatternAsRestParameter: 'Unexpected token {',\n        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n        ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n        DuplicateConstructor: 'A class may only have one constructor',\n        StaticPrototype: 'Classes may not have static property named prototype',\n        MissingFromClause: 'Unexpected token',\n        NoAsAfterImportNamespace: 'Unexpected token',\n        InvalidModuleSpecifier: 'Unexpected token',\n        IllegalImportDeclaration: 'Unexpected token',\n        IllegalExportDeclaration: 'Unexpected token'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 0x30 && ch <= 0x39);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n    function octalToDecimal(ch) {\n        // \\0 is not octal escape sequence\n        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);\n\n        if (index < length && isOctalDigit(source[index])) {\n            octal = true;\n            code = code * 8 + '01234567'.indexOf(source[index++]);\n\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if ('0123'.indexOf(ch) >= 0 &&\n                    index < length &&\n                    isOctalDigit(source[index])) {\n                code = code * 8 + '01234567'.indexOf(source[index++]);\n            }\n        }\n\n        return {\n            code: code,\n            octal: octal\n        };\n    }\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'enum':\n        case 'export':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    // 11.6.2.2 Future Reserved Words\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                hasLineTerminator = true;\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        // Ran off the end of the file - the whole thing is a comment\n        if (extra.comments) {\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            comment = source.slice(start + 2, index);\n            addComment('Block', comment, start, index, loc);\n        }\n        tolerateUnexpectedToken();\n    }\n\n    function skipComment() {\n        var ch, start;\n        hasLineTerminator = false;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwUnexpectedToken();\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwUnexpectedToken();\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwUnexpectedToken();\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwUnexpectedToken();\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwUnexpectedToken();\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwUnexpectedToken();\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var token, str;\n\n        token = {\n            type: Token.Punctuator,\n            value: '',\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: index,\n            end: index\n        };\n\n        // Check for most common single-character punctuators.\n        str = source[index];\n        switch (str) {\n\n        case '(':\n            if (extra.tokenize) {\n                extra.openParenToken = extra.tokens.length;\n            }\n            ++index;\n            break;\n\n        case '{':\n            if (extra.tokenize) {\n                extra.openCurlyToken = extra.tokens.length;\n            }\n            state.curlyStack.push('{');\n            ++index;\n            break;\n\n        case '.':\n            ++index;\n            if (source[index] === '.' && source[index + 1] === '.') {\n                // Spread operator: ...\n                index += 2;\n                str = '...';\n            }\n            break;\n\n        case '}':\n            ++index;\n            state.curlyStack.pop();\n            break;\n        case ')':\n        case ';':\n        case ',':\n        case '[':\n        case ']':\n        case ':':\n        case '?':\n        case '~':\n            ++index;\n            break;\n\n        default:\n            // 4-character punctuator.\n            str = source.substr(index, 4);\n            if (str === '>>>=') {\n                index += 4;\n            } else {\n\n                // 3-character punctuators.\n                str = str.substr(0, 3);\n                if (str === '===' || str === '!==' || str === '>>>' ||\n                    str === '<<=' || str === '>>=') {\n                    index += 3;\n                } else {\n\n                    // 2-character punctuators.\n                    str = str.substr(0, 2);\n                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||\n                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||\n                        str === '++' || str === '--' || str === '<<' || str === '>>' ||\n                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||\n                        str === '<=' || str === '>=' || str === '=>') {\n                        index += 2;\n                    } else {\n\n                        // 1-character punctuators.\n                        str = source[index];\n                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                            ++index;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (index === token.start) {\n            throwUnexpectedToken();\n        }\n\n        token.end = index;\n        token.value = str;\n        return token;\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwUnexpectedToken();\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwUnexpectedToken();\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return scanOctalLiteral(ch, start);\n                }\n\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwUnexpectedToken();\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, unescaped, octToDec, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            unescaped = scanHexEscape(ch);\n                            if (!unescaped) {\n                                throw throwUnexpectedToken();\n                            }\n                            str += unescaped;\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n                    case '8':\n                    case '9':\n                        throw throwUnexpectedToken();\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            octToDec = octalToDecimal(ch);\n\n                            octal = octToDec.octal || octal;\n                            str += String.fromCharCode(octToDec.code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: startLineNumber,\n            lineStart: startLineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanTemplate() {\n        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;\n\n        terminated = false;\n        tail = false;\n        start = index;\n        head = (source[index] === '`');\n        rawOffset = 2;\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                rawOffset = 1;\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    state.curlyStack.push('${');\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (ch === '0') {\n                            if (isDecimalDigit(source.charCodeAt(index))) {\n                                // Illegal: \\01 \\02 and so on\n                                throwError(Messages.TemplateOctalLiteral);\n                            }\n                            cooked += '\\0';\n                        } else if (isOctalDigit(ch)) {\n                            // Illegal: \\1 \\2\n                            throwError(Messages.TemplateOctalLiteral);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken();\n        }\n\n        if (!head) {\n            state.curlyStack.pop();\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - rawOffset)\n            },\n            head: head,\n            tail: tail,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var tmp = pattern;\n\n        if (flags.indexOf('u') >= 0) {\n            // Replace each astral symbol and every Unicode escape sequence\n            // that possibly represents an astral symbol or a paired surrogate\n            // with a single ASCII symbol to avoid throwing on regular\n            // expressions that are only valid in combination with the `/u`\n            // flag.\n            // Note: replacing with the ASCII symbol `x` might cause false\n            // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n            // perfectly valid pattern that is equivalent to `[a-b]`, but it\n            // would be replaced by `[x-b]` which throws an error.\n            tmp = tmp\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                    if (parseInt($1, 16) <= 0x10FFFF) {\n                        return 'x';\n                    }\n                    throwUnexpectedToken(null, Messages.InvalidRegExp);\n                })\n                .replace(\n                    /\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n                    'x'\n                );\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            RegExp(tmp);\n        } catch (e) {\n            throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    tolerateUnexpectedToken();\n                } else {\n                    str += '\\\\';\n                    tolerateUnexpectedToken();\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        scanning = true;\n        var start, body, flags, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n        scanning = false;\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ']') {\n                return scanPunctuator();\n            }\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch, token;\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        if (isIdentifierStart(ch)) {\n            token = scanIdentifier();\n            if (strict && isStrictModeReservedWord(token.value)) {\n                token.type = Token.Keyword;\n            }\n            return token;\n        }\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        // Template literals start with ` (U+0060) for template head\n        // or } (U+007D) for template middle or template tail.\n        if (ch === 0x60 || (ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {\n            return scanTemplate();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, value, entry;\n\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n        scanning = true;\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        skipComment();\n\n        token = lookahead;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n        return token;\n    }\n\n    function peek() {\n        scanning = true;\n\n        skipComment();\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n    }\n\n    function Position() {\n        this.line = startLineNumber;\n        this.column = startIndex - startLineStart;\n    }\n\n    function SourceLocation() {\n        this.start = new Position();\n        this.end = null;\n    }\n\n    function WrappingSourceLocation(startToken) {\n        this.start = {\n            line: startToken.lineNumber,\n            column: startToken.start - startToken.lineStart\n        };\n        this.end = null;\n    }\n\n    function Node() {\n        if (extra.range) {\n            this.range = [startIndex, 0];\n        }\n        if (extra.loc) {\n            this.loc = new SourceLocation();\n        }\n    }\n\n    function WrappingNode(startToken) {\n        if (extra.range) {\n            this.range = [startToken.start, 0];\n        }\n        if (extra.loc) {\n            this.loc = new WrappingSourceLocation(startToken);\n        }\n    }\n\n    WrappingNode.prototype = Node.prototype = {\n\n        processComment: function () {\n            var lastChild,\n                leadingComments,\n                trailingComments,\n                bottomRight = extra.bottomRightStack,\n                i,\n                comment,\n                last = bottomRight[bottomRight.length - 1];\n\n            if (this.type === Syntax.Program) {\n                if (this.body.length > 0) {\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                trailingComments = [];\n                for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n                    comment = extra.trailingComments[i];\n                    if (comment.range[0] >= this.range[1]) {\n                        trailingComments.unshift(comment);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                extra.trailingComments = [];\n            } else {\n                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n                    trailingComments = last.trailingComments;\n                    delete last.trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            if (last) {\n                while (last && last.range[0] >= this.range[0]) {\n                    lastChild = last;\n                    last = bottomRight.pop();\n                }\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {\n                    this.leadingComments = lastChild.leadingComments;\n                    lastChild.leadingComments = undefined;\n                }\n            } else if (extra.leadingComments.length > 0) {\n                leadingComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (comment.range[1] <= this.range[0]) {\n                        leadingComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                    }\n                }\n            }\n\n\n            if (leadingComments && leadingComments.length > 0) {\n                this.leadingComments = leadingComments;\n            }\n            if (trailingComments && trailingComments.length > 0) {\n                this.trailingComments = trailingComments;\n            }\n\n            bottomRight.push(this);\n        },\n\n        finish: function () {\n            if (extra.range) {\n                this.range[1] = lastIndex;\n            }\n            if (extra.loc) {\n                this.loc.end = {\n                    line: lastLineNumber,\n                    column: lastIndex - lastLineStart\n                };\n                if (extra.source) {\n                    this.loc.source = extra.source;\n                }\n            }\n\n            if (extra.attachComment) {\n                this.processComment();\n            }\n        },\n\n        finishArrayExpression: function (elements) {\n            this.type = Syntax.ArrayExpression;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrayPattern: function (elements) {\n            this.type = Syntax.ArrayPattern;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrowFunctionExpression: function (params, defaults, body, expression) {\n            this.type = Syntax.ArrowFunctionExpression;\n            this.id = null;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentExpression: function (operator, left, right) {\n            this.type = Syntax.AssignmentExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentPattern: function (left, right) {\n            this.type = Syntax.AssignmentPattern;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBinaryExpression: function (operator, left, right) {\n            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBlockStatement: function (body) {\n            this.type = Syntax.BlockStatement;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishBreakStatement: function (label) {\n            this.type = Syntax.BreakStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishCallExpression: function (callee, args) {\n            this.type = Syntax.CallExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishCatchClause: function (param, body) {\n            this.type = Syntax.CatchClause;\n            this.param = param;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassBody: function (body) {\n            this.type = Syntax.ClassBody;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassDeclaration: function (id, superClass, body) {\n            this.type = Syntax.ClassDeclaration;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassExpression: function (id, superClass, body) {\n            this.type = Syntax.ClassExpression;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishConditionalExpression: function (test, consequent, alternate) {\n            this.type = Syntax.ConditionalExpression;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishContinueStatement: function (label) {\n            this.type = Syntax.ContinueStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishDebuggerStatement: function () {\n            this.type = Syntax.DebuggerStatement;\n            this.finish();\n            return this;\n        },\n\n        finishDoWhileStatement: function (body, test) {\n            this.type = Syntax.DoWhileStatement;\n            this.body = body;\n            this.test = test;\n            this.finish();\n            return this;\n        },\n\n        finishEmptyStatement: function () {\n            this.type = Syntax.EmptyStatement;\n            this.finish();\n            return this;\n        },\n\n        finishExpressionStatement: function (expression) {\n            this.type = Syntax.ExpressionStatement;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishForStatement: function (init, test, update, body) {\n            this.type = Syntax.ForStatement;\n            this.init = init;\n            this.test = test;\n            this.update = update;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForInStatement: function (left, right, body) {\n            this.type = Syntax.ForInStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.each = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionDeclaration: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionDeclaration;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionExpression: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionExpression;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishIdentifier: function (name) {\n            this.type = Syntax.Identifier;\n            this.name = name;\n            this.finish();\n            return this;\n        },\n\n        finishIfStatement: function (test, consequent, alternate) {\n            this.type = Syntax.IfStatement;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishLabeledStatement: function (label, body) {\n            this.type = Syntax.LabeledStatement;\n            this.label = label;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishLiteral: function (token) {\n            this.type = Syntax.Literal;\n            this.value = token.value;\n            this.raw = source.slice(token.start, token.end);\n            if (token.regex) {\n                this.regex = token.regex;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishMemberExpression: function (accessor, object, property) {\n            this.type = Syntax.MemberExpression;\n            this.computed = accessor === '[';\n            this.object = object;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishNewExpression: function (callee, args) {\n            this.type = Syntax.NewExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishObjectExpression: function (properties) {\n            this.type = Syntax.ObjectExpression;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishObjectPattern: function (properties) {\n            this.type = Syntax.ObjectPattern;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishPostfixExpression: function (operator, argument) {\n            this.type = Syntax.UpdateExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = false;\n            this.finish();\n            return this;\n        },\n\n        finishProgram: function (body) {\n            this.type = Syntax.Program;\n            this.body = body;\n            if (sourceType === 'module') {\n                // very restrictive for now\n                this.sourceType = sourceType;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishProperty: function (kind, key, computed, value, method, shorthand) {\n            this.type = Syntax.Property;\n            this.key = key;\n            this.computed = computed;\n            this.value = value;\n            this.kind = kind;\n            this.method = method;\n            this.shorthand = shorthand;\n            this.finish();\n            return this;\n        },\n\n        finishRestElement: function (argument) {\n            this.type = Syntax.RestElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishReturnStatement: function (argument) {\n            this.type = Syntax.ReturnStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSequenceExpression: function (expressions) {\n            this.type = Syntax.SequenceExpression;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishSpreadElement: function (argument) {\n            this.type = Syntax.SpreadElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchCase: function (test, consequent) {\n            this.type = Syntax.SwitchCase;\n            this.test = test;\n            this.consequent = consequent;\n            this.finish();\n            return this;\n        },\n\n        finishSuper: function () {\n            this.type = Syntax.Super;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchStatement: function (discriminant, cases) {\n            this.type = Syntax.SwitchStatement;\n            this.discriminant = discriminant;\n            this.cases = cases;\n            this.finish();\n            return this;\n        },\n\n        finishTaggedTemplateExpression: function (tag, quasi) {\n            this.type = Syntax.TaggedTemplateExpression;\n            this.tag = tag;\n            this.quasi = quasi;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateElement: function (value, tail) {\n            this.type = Syntax.TemplateElement;\n            this.value = value;\n            this.tail = tail;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateLiteral: function (quasis, expressions) {\n            this.type = Syntax.TemplateLiteral;\n            this.quasis = quasis;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishThisExpression: function () {\n            this.type = Syntax.ThisExpression;\n            this.finish();\n            return this;\n        },\n\n        finishThrowStatement: function (argument) {\n            this.type = Syntax.ThrowStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishTryStatement: function (block, handler, finalizer) {\n            this.type = Syntax.TryStatement;\n            this.block = block;\n            this.guardedHandlers = [];\n            this.handlers = handler ? [ handler ] : [];\n            this.handler = handler;\n            this.finalizer = finalizer;\n            this.finish();\n            return this;\n        },\n\n        finishUnaryExpression: function (operator, argument) {\n            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = true;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclaration: function (declarations) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = 'var';\n            this.finish();\n            return this;\n        },\n\n        finishLexicalDeclaration: function (declarations, kind) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = kind;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclarator: function (id, init) {\n            this.type = Syntax.VariableDeclarator;\n            this.id = id;\n            this.init = init;\n            this.finish();\n            return this;\n        },\n\n        finishWhileStatement: function (test, body) {\n            this.type = Syntax.WhileStatement;\n            this.test = test;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishWithStatement: function (object, body) {\n            this.type = Syntax.WithStatement;\n            this.object = object;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishExportSpecifier: function (local, exported) {\n            this.type = Syntax.ExportSpecifier;\n            this.exported = exported || local;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportDefaultSpecifier: function (local) {\n            this.type = Syntax.ImportDefaultSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportNamespaceSpecifier: function (local) {\n            this.type = Syntax.ImportNamespaceSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishExportNamedDeclaration: function (declaration, specifiers, src) {\n            this.type = Syntax.ExportNamedDeclaration;\n            this.declaration = declaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishExportDefaultDeclaration: function (declaration) {\n            this.type = Syntax.ExportDefaultDeclaration;\n            this.declaration = declaration;\n            this.finish();\n            return this;\n        },\n\n        finishExportAllDeclaration: function (src) {\n            this.type = Syntax.ExportAllDeclaration;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishImportSpecifier: function (local, imported) {\n            this.type = Syntax.ImportSpecifier;\n            this.local = local || imported;\n            this.imported = imported;\n            this.finish();\n            return this;\n        },\n\n        finishImportDeclaration: function (specifiers, src) {\n            this.type = Syntax.ImportDeclaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        }\n    };\n\n\n    function recordError(error) {\n        var e, existing;\n\n        for (e = 0; e < extra.errors.length; e++) {\n            existing = extra.errors[e];\n            // Prevent duplicated error.\n            /* istanbul ignore next */\n            if (existing.index === error.index && existing.message === error.message) {\n                return;\n            }\n        }\n\n        extra.errors.push(error);\n    }\n\n    function createError(line, pos, description) {\n        var error = new Error('Line ' + line + ': ' + description);\n        error.index = pos;\n        error.lineNumber = line;\n        error.column = pos - (scanning ? lineStart : lastLineStart) + 1;\n        error.description = description;\n        return error;\n    }\n\n    // Throw an exception\n\n    function throwError(messageFormat) {\n        var args, msg;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        throw createError(lastLineNumber, lastIndex, msg);\n    }\n\n    function tolerateError(messageFormat) {\n        var args, msg, error;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        /* istanbul ignore next */\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        error = createError(lineNumber, lastIndex, msg);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Throw an exception because of the token.\n\n    function unexpectedTokenError(token, message) {\n        var value, msg = message || Messages.UnexpectedToken;\n\n        if (token) {\n            if (!message) {\n                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :\n                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :\n                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :\n                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :\n                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :\n                    Messages.UnexpectedToken;\n\n                if (token.type === Token.Keyword) {\n                    if (isFutureReservedWord(token.value)) {\n                        msg = Messages.UnexpectedReserved;\n                    } else if (strict && isStrictModeReservedWord(token.value)) {\n                        msg = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            value = (token.type === Token.Template) ? token.value.raw : token.value;\n        } else {\n            value = 'ILLEGAL';\n        }\n\n        msg = msg.replace('%0', value);\n\n        return (token && typeof token.lineNumber === 'number') ?\n            createError(token.lineNumber, token.start, msg) :\n            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n    }\n\n    function throwUnexpectedToken(token, message) {\n        throw unexpectedTokenError(token, message);\n    }\n\n    function tolerateUnexpectedToken(token, message) {\n        var error = unexpectedTokenError(token, message);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    /**\n     * @name expectCommaSeparator\n     * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n     * to <code>expect(value)</code>\n     * @since 2.0\n     */\n    function expectCommaSeparator() {\n        var token;\n\n        if (extra.errors) {\n            token = lookahead;\n            if (token.type === Token.Punctuator && token.value === ',') {\n                lex();\n            } else if (token.type === Token.Punctuator && token.value === ';') {\n                lex();\n                tolerateUnexpectedToken(token);\n            } else {\n                tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n            }\n        } else {\n            expect(',');\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n    // (where an identifier is sometimes a keyword depending on the context)\n\n    function matchContextualKeyword(keyword) {\n        return lookahead.type === Token.Identifier && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        if (hasLineTerminator) {\n            return;\n        }\n\n        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n        lastIndex = startIndex;\n        lastLineNumber = startLineNumber;\n        lastLineStart = startLineStart;\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpectedToken(lookahead);\n        }\n    }\n\n    // Cover grammar support.\n    //\n    // When an assignment expression position starts with an left parenthesis, the determination of the type\n    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n    //\n    // There are three productions that can be parsed in a parentheses pair that needs to be determined\n    // after the outermost pair is closed. They are:\n    //\n    //   1. AssignmentExpression\n    //   2. BindingElements\n    //   3. AssignmentTargets\n    //\n    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n    // binding element or assignment target.\n    //\n    // The three productions have the relationship:\n    //\n    //   BindingElements  AssignmentTargets  AssignmentExpression\n    //\n    // with a single exception that CoverInitializedName when used directly in an Expression, generates\n    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n    //\n    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n    // the CoverInitializedName check is conducted.\n    //\n    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n    // pattern. The CoverInitializedName check is deferred.\n    function isolateCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        if (firstCoverInitializedNameError !== null) {\n            throwUnexpectedToken(firstCoverInitializedNameError);\n        }\n        isBindingElement = oldIsBindingElement;\n        isAssignmentTarget = oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n        return result;\n    }\n\n    function inheritCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        isBindingElement = isBindingElement && oldIsBindingElement;\n        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n        return result;\n    }\n\n    function parseArrayPattern() {\n        var node = new Node(), elements = [], rest, restNode;\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                if (match('...')) {\n                    restNode = new Node();\n                    lex();\n                    rest = parseVariableIdentifier();\n                    elements.push(restNode.finishRestElement(rest));\n                    break;\n                } else {\n                    elements.push(parsePatternWithDefault());\n                }\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n\n        }\n\n        expect(']');\n\n        return node.finishArrayPattern(elements);\n    }\n\n    function parsePropertyPattern() {\n        var node = new Node(), key, computed = match('['), init;\n        if (lookahead.type === Token.Identifier) {\n            key = parseVariableIdentifier();\n            if (match('=')) {\n                lex();\n                init = parseAssignmentExpression();\n                return node.finishProperty(\n                    'init', key, false,\n                    new WrappingNode(key).finishAssignmentPattern(key, init), false, false);\n            } else if (!match(':')) {\n                return node.finishProperty('init', key, false, key, false, true);\n            }\n        } else {\n            key = parseObjectPropertyKey();\n        }\n        expect(':');\n        init = parsePatternWithDefault();\n        return node.finishProperty('init', key, computed, init, false, false);\n    }\n\n    function parseObjectPattern() {\n        var node = new Node(), properties = [];\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parsePropertyPattern());\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        lex();\n\n        return node.finishObjectPattern(properties);\n    }\n\n    function parsePattern() {\n        if (lookahead.type === Token.Identifier) {\n            return parseVariableIdentifier();\n        } else if (match('[')) {\n            return parseArrayPattern();\n        } else if (match('{')) {\n            return parseObjectPattern();\n        }\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parsePatternWithDefault() {\n        var startToken = lookahead, pattern, right;\n        pattern = parsePattern();\n        if (match('=')) {\n            lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n        }\n        return pattern;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], node = new Node(), restSpread;\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else if (match('...')) {\n                restSpread = new Node();\n                lex();\n                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    isAssignmentTarget = isBindingElement = false;\n                    expect(',');\n                }\n                elements.push(restSpread);\n            } else {\n                elements.push(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return node.finishArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(node, paramInfo) {\n        var previousStrict, body;\n\n        isAssignmentTarget = isBindingElement = false;\n\n        previousStrict = strict;\n        body = isolateCoverGrammar(parseFunctionSourceElements);\n\n        if (strict && paramInfo.firstRestricted) {\n            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n        }\n        if (strict && paramInfo.stricted) {\n            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n        }\n\n        strict = previousStrict;\n        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body);\n    }\n\n    function parsePropertyMethodFunction() {\n        var params, method, node = new Node();\n\n        params = parseParams();\n        method = parsePropertyFunction(node, params);\n\n        return method;\n    }\n\n    function parseObjectPropertyKey() {\n        var token, node = new Node(), expr;\n\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        switch (token.type) {\n        case Token.StringLiteral:\n        case Token.NumericLiteral:\n            if (strict && token.octal) {\n                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n            }\n            return node.finishLiteral(token);\n        case Token.Identifier:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.Keyword:\n            return node.finishIdentifier(token.value);\n        case Token.Punctuator:\n            if (token.value === '[') {\n                expr = isolateCoverGrammar(parseAssignmentExpression);\n                expect(']');\n                return expr;\n            }\n            break;\n        }\n        throwUnexpectedToken(token);\n    }\n\n    function lookaheadPropertyName() {\n        switch (lookahead.type) {\n        case Token.Identifier:\n        case Token.StringLiteral:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.NumericLiteral:\n        case Token.Keyword:\n            return true;\n        case Token.Punctuator:\n            return lookahead.value === '[';\n        }\n        return false;\n    }\n\n    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n    // This can only be determined after we consumed up to the left parentheses.\n    //\n    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n    // is responsible to visit other options.\n    function tryParseMethodDefinition(token, key, computed, node) {\n        var value, options, methodNode;\n\n        if (token.type === Token.Identifier) {\n            // check for `get` and `set`;\n\n            if (token.value === 'get' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction(methodNode, {\n                    params: [],\n                    defaults: [],\n                    stricted: null,\n                    firstRestricted: null,\n                    message: null\n                });\n                return node.finishProperty('get', key, computed, value, false, false);\n            } else if (token.value === 'set' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n\n                options = {\n                    params: [],\n                    defaultCount: 0,\n                    defaults: [],\n                    firstRestricted: null,\n                    paramSet: {}\n                };\n                if (match(')')) {\n                    tolerateUnexpectedToken(lookahead);\n                } else {\n                    parseParam(options);\n                    if (options.defaultCount === 0) {\n                        options.defaults = [];\n                    }\n                }\n                expect(')');\n\n                value = parsePropertyFunction(methodNode, options);\n                return node.finishProperty('set', key, computed, value, false, false);\n            }\n        }\n\n        if (match('(')) {\n            value = parsePropertyMethodFunction();\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        // Not a MethodDefinition.\n        return null;\n    }\n\n    function checkProto(key, computed, hasProto) {\n        if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' ||\n            key.type === Syntax.Literal && key.value === '__proto__')) {\n            if (hasProto.value) {\n                tolerateError(Messages.DuplicateProtoProperty);\n            } else {\n                hasProto.value = true;\n            }\n        }\n    }\n\n    function parseObjectProperty(hasProto) {\n        var token = lookahead, node = new Node(), computed, key, maybeMethod, value;\n\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n\n        if (maybeMethod) {\n            checkProto(maybeMethod.key, maybeMethod.computed, hasProto);\n            // finished\n            return maybeMethod;\n        }\n\n        // init property or short hand property.\n        checkProto(key, computed, hasProto);\n\n        if (match(':')) {\n            lex();\n            value = inheritCoverGrammar(parseAssignmentExpression);\n            return node.finishProperty('init', key, computed, value, false, false);\n        }\n\n        if (token.type === Token.Identifier) {\n            if (match('=')) {\n                firstCoverInitializedNameError = lookahead;\n                lex();\n                value = isolateCoverGrammar(parseAssignmentExpression);\n                return node.finishProperty('init', key, computed,\n                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n            }\n            return node.finishProperty('init', key, computed, key, false, true);\n        }\n\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], hasProto = {value: false}, node = new Node();\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parseObjectProperty(hasProto));\n\n            if (!match('}')) {\n                expectCommaSeparator();\n            }\n        }\n\n        expect('}');\n\n        return node.finishObjectExpression(properties);\n    }\n\n    function reinterpretExpressionAsPattern(expr) {\n        var i;\n        switch (expr.type) {\n        case Syntax.Identifier:\n        case Syntax.MemberExpression:\n        case Syntax.RestElement:\n        case Syntax.AssignmentPattern:\n            break;\n        case Syntax.SpreadElement:\n            expr.type = Syntax.RestElement;\n            reinterpretExpressionAsPattern(expr.argument);\n            break;\n        case Syntax.ArrayExpression:\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0; i < expr.elements.length; i++) {\n                if (expr.elements[i] !== null) {\n                    reinterpretExpressionAsPattern(expr.elements[i]);\n                }\n            }\n            break;\n        case Syntax.ObjectExpression:\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0; i < expr.properties.length; i++) {\n                reinterpretExpressionAsPattern(expr.properties[i].value);\n            }\n            break;\n        case Syntax.AssignmentExpression:\n            expr.type = Syntax.AssignmentPattern;\n            reinterpretExpressionAsPattern(expr.left);\n            break;\n        default:\n            // Allow other node type for tolerant parsing.\n            break;\n        }\n    }\n\n    function parseTemplateElement(option) {\n        var node, token;\n\n        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {\n            throwUnexpectedToken();\n        }\n\n        node = new Node();\n        token = lex();\n\n        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, node = new Node();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [ quasi ];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return node.finishTemplateLiteral(quasis, expressions);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr, expressions, startToken, i;\n\n        expect('(');\n\n        if (match(')')) {\n            lex();\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: []\n            };\n        }\n\n        startToken = lookahead;\n        if (match('...')) {\n            expr = parseRestElement();\n            expect(')');\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [expr]\n            };\n        }\n\n        isBindingElement = true;\n        expr = inheritCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            isAssignmentTarget = false;\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n\n                if (match('...')) {\n                    if (!isBindingElement) {\n                        throwUnexpectedToken(lookahead);\n                    }\n                    expressions.push(parseRestElement());\n                    expect(')');\n                    if (!match('=>')) {\n                        expect('=>');\n                    }\n                    isBindingElement = false;\n                    for (i = 0; i < expressions.length; i++) {\n                        reinterpretExpressionAsPattern(expressions[i]);\n                    }\n                    return {\n                        type: PlaceHolders.ArrowParameterPlaceHolder,\n                        params: expressions\n                    };\n                }\n\n                expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n\n        expect(')');\n\n        if (match('=>')) {\n            if (!isBindingElement) {\n                throwUnexpectedToken(lookahead);\n            }\n\n            if (expr.type === Syntax.SequenceExpression) {\n                for (i = 0; i < expr.expressions.length; i++) {\n                    reinterpretExpressionAsPattern(expr.expressions[i]);\n                }\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            expr = {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n            };\n        }\n        isBindingElement = false;\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, node;\n\n        if (match('(')) {\n            isBindingElement = false;\n            return inheritCoverGrammar(parseGroupExpression);\n        }\n\n        if (match('[')) {\n            return inheritCoverGrammar(parseArrayInitialiser);\n        }\n\n        if (match('{')) {\n            return inheritCoverGrammar(parseObjectInitialiser);\n        }\n\n        type = lookahead.type;\n        node = new Node();\n\n        if (type === Token.Identifier) {\n            expr = node.finishIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            if (strict && lookahead.octal) {\n                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = node.finishLiteral(lex());\n        } else if (type === Token.Keyword) {\n            isAssignmentTarget = isBindingElement = false;\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                return node.finishThisExpression();\n            }\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n            throwUnexpectedToken(lex());\n        } else if (type === Token.BooleanLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = node.finishLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = null;\n            expr = node.finishLiteral(token);\n        } else if (match('/') || match('/=')) {\n            isAssignmentTarget = isBindingElement = false;\n            index = startIndex;\n\n            if (typeof extra.tokens !== 'undefined') {\n                token = collectRegex();\n            } else {\n                token = scanRegExp();\n            }\n            lex();\n            expr = node.finishLiteral(token);\n        } else if (type === Token.Template) {\n            expr = parseTemplateLiteral();\n        } else {\n            throwUnexpectedToken(lex());\n        }\n\n        return expr;\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (startIndex < length) {\n                args.push(isolateCoverGrammar(parseAssignmentExpression));\n                if (match(')')) {\n                    break;\n                }\n                expectCommaSeparator();\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = isolateCoverGrammar(parseExpression);\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, node = new Node();\n\n        expectKeyword('new');\n        callee = isolateCoverGrammar(parseLeftHandSideExpression);\n        args = match('(') ? parseArguments() : [];\n\n        isAssignmentTarget = isBindingElement = false;\n\n        return node.finishNewExpression(callee, args);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('(') && !match('.') && !match('[')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                isBindingElement = false;\n                isAssignmentTarget = false;\n                args = parseArguments();\n                expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n            } else if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var quasi, expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('[') && !match('.')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n\n        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n            if (match('++') || match('--')) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    tolerateError(Messages.StrictLHSPostfix);\n                }\n\n                if (!isAssignmentTarget) {\n                    tolerateError(Messages.InvalidLHSInAssignment);\n                }\n\n                isAssignmentTarget = isBindingElement = false;\n\n                token = lex();\n                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateError(Messages.StrictLHSPrefix);\n            }\n\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                tolerateError(Messages.StrictDelete);\n            }\n            isAssignmentTarget = isBindingElement = false;\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = inheritCoverGrammar(parseUnaryExpression);\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        isAssignmentTarget = isBindingElement = false;\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = isolateCoverGrammar(parseUnaryExpression);\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                markers.pop();\n                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = isolateCoverGrammar(parseUnaryExpression);\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseBinaryExpression);\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = isolateCoverGrammar(parseAssignmentExpression);\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = isolateCoverGrammar(parseAssignmentExpression);\n\n            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n            isAssignmentTarget = isBindingElement = false;\n        }\n\n        return expr;\n    }\n\n    // [ES6] 14.2 Arrow Function\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return isolateCoverGrammar(parseAssignmentExpression);\n    }\n\n    function checkPatternParam(options, param) {\n        var i;\n        switch (param.type) {\n        case Syntax.Identifier:\n            validateParam(options, param, param.name);\n            break;\n        case Syntax.RestElement:\n            checkPatternParam(options, param.argument);\n            break;\n        case Syntax.AssignmentPattern:\n            checkPatternParam(options, param.left);\n            break;\n        case Syntax.ArrayPattern:\n            for (i = 0; i < param.elements.length; i++) {\n                if (param.elements[i] !== null) {\n                    checkPatternParam(options, param.elements[i]);\n                }\n            }\n            break;\n        default:\n            assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n            for (i = 0; i < param.properties.length; i++) {\n                checkPatternParam(options, param.properties[i].value);\n            }\n            break;\n        }\n    }\n    function reinterpretAsCoverFormalsList(expr) {\n        var i, len, param, params, defaults, defaultCount, options, token;\n\n        defaults = [];\n        defaultCount = 0;\n        params = [expr];\n\n        switch (expr.type) {\n        case Syntax.Identifier:\n            break;\n        case PlaceHolders.ArrowParameterPlaceHolder:\n            params = expr.params;\n            break;\n        default:\n            return null;\n        }\n\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = params.length; i < len; i += 1) {\n            param = params[i];\n            switch (param.type) {\n            case Syntax.AssignmentPattern:\n                params[i] = param.left;\n                defaults.push(param.right);\n                ++defaultCount;\n                checkPatternParam(options, param.left);\n                break;\n            default:\n                checkPatternParam(options, param);\n                params[i] = param;\n                defaults.push(null);\n                break;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            token = strict ? options.stricted : options.firstRestricted;\n            throwUnexpectedToken(token, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, node) {\n        var previousStrict, body;\n\n        if (hasLineTerminator) {\n            tolerateUnexpectedToken(lookahead);\n        }\n        expect('=>');\n        previousStrict = strict;\n\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwUnexpectedToken(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            tolerateUnexpectedToken(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n\n        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr, right, list, startToken;\n\n        startToken = lookahead;\n        token = lookahead;\n\n        expr = parseConditionalExpression();\n\n        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n            isAssignmentTarget = isBindingElement = false;\n            list = reinterpretAsCoverFormalsList(expr);\n\n            if (list) {\n                firstCoverInitializedNameError = null;\n                return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n            }\n\n            return expr;\n        }\n\n        if (matchAssign()) {\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n            }\n\n            if (!match('=')) {\n                isAssignmentTarget = isBindingElement = false;\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            token = lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n            firstCoverInitializedNameError = null;\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead, expressions;\n\n        expr = isolateCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementListItem() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                if (sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n                }\n                return parseExportDeclaration();\n            case 'import':\n                if (sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n                }\n                return parseImportDeclaration();\n            case 'const':\n            case 'let':\n                return parseLexicalDeclaration({inFor: false});\n            case 'function':\n                return parseFunctionDeclaration(new Node());\n            case 'class':\n                return parseClassDeclaration();\n            }\n        }\n\n        return parseStatement();\n    }\n\n    function parseStatementList() {\n        var list = [];\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            list.push(parseStatementListItem());\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, node = new Node();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return node.finishBlockStatement(block);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } else {\n                throwUnexpectedToken(token);\n            }\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration() {\n        var init = null, id, node = new Node();\n\n        id = parsePattern();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (match('=')) {\n            lex();\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        } else if (id.type !== Syntax.Identifier) {\n            expect('=');\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList() {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration());\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (startIndex < length);\n\n        return list;\n    }\n\n    function parseVariableStatement(node) {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations);\n    }\n\n    function parseLexicalBinding(kind, options) {\n        var init = null, id, node = new Node();\n\n        id = parsePattern();\n\n        // 12.2.1\n        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            if (!matchKeyword('in')) {\n                expect('=');\n                init = isolateCoverGrammar(parseAssignmentExpression);\n            }\n        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {\n            expect('=');\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseBindingList(kind, options) {\n        var list = [];\n\n        do {\n            list.push(parseLexicalBinding(kind, options));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (startIndex < length);\n\n        return list;\n    }\n\n    function parseLexicalDeclaration(options) {\n        var kind, declarations, node = new Node();\n\n        kind = lex().value;\n        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n\n        declarations = parseBindingList(kind, options);\n\n        consumeSemicolon();\n\n        return node.finishLexicalDeclaration(declarations, kind);\n    }\n\n    function parseRestElement() {\n        var param, node = new Node();\n\n        lex();\n\n        if (match('{')) {\n            throwError(Messages.ObjectPatternAsRestParameter);\n        }\n\n        param = parseVariableIdentifier();\n\n        if (match('=')) {\n            throwError(Messages.DefaultRestParameter);\n        }\n\n        if (!match(')')) {\n            throwError(Messages.ParameterAfterRestParameter);\n        }\n\n        return node.finishRestElement(param);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement(node) {\n        expect(';');\n        return node.finishEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement(node) {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement(node) {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return node.finishIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement(node) {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return node.finishDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement(node) {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return node.finishWhileStatement(test, body);\n    }\n\n    function parseForStatement(node) {\n        var init, initSeq, initStartToken, test, update, left, right, kind, declarations,\n            body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var')) {\n                init = new Node();\n                lex();\n\n                state.allowIn = false;\n                init = init.finishVariableDeclaration(parseVariableDeclarationList());\n                state.allowIn = previousAllowIn;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    expect(';');\n                }\n            } else if (matchKeyword('const') || matchKeyword('let')) {\n                init = new Node();\n                kind = lex().value;\n\n                state.allowIn = false;\n                declarations = parseBindingList(kind, {inFor: true});\n                state.allowIn = previousAllowIn;\n\n                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n                    init = init.finishLexicalDeclaration(declarations, kind);\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    consumeSemicolon();\n                    init = init.finishLexicalDeclaration(declarations, kind);\n                }\n            } else {\n                initStartToken = lookahead;\n                state.allowIn = false;\n                init = inheritCoverGrammar(parseAssignmentExpression);\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    if (match(',')) {\n                        initSeq = [init];\n                        while (match(',')) {\n                            lex();\n                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n                        }\n                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n                    }\n                    expect(';');\n                }\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = isolateCoverGrammar(parseStatement);\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                node.finishForStatement(init, test, update, body) :\n                node.finishForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement(node) {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(startIndex) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError(Messages.IllegalContinue);\n        }\n\n        return node.finishContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement(node) {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(lastIndex) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError(Messages.IllegalBreak);\n        }\n\n        return node.finishBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement(node) {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            tolerateError(Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(lastIndex) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return node.finishReturnStatement(argument);\n            }\n        }\n\n        if (hasLineTerminator) {\n            // HACK\n            return node.finishReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return node.finishReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement(node) {\n        var object, body;\n\n        if (strict) {\n            tolerateError(Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return node.finishWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, node = new Node();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (startIndex < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatementListItem();\n            consequent.push(statement);\n        }\n\n        return node.finishSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement(node) {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return node.finishSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError(Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement(node) {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (hasLineTerminator) {\n            throwError(Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return node.finishThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, node = new Node();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        param = parsePattern();\n\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            tolerateError(Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return node.finishCatchClause(param, body);\n    }\n\n    function parseTryStatement(node) {\n        var block, handler = null, finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handler = parseCatchClause();\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (!handler && !finalizer) {\n            throwError(Messages.NoCatchOrFinally);\n        }\n\n        return node.finishTryStatement(block, handler, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement(node) {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return node.finishDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            node;\n\n        if (type === Token.EOF) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n        isAssignmentTarget = isBindingElement = true;\n        node = new Node();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement(node);\n            case '(':\n                return parseExpressionStatement(node);\n            default:\n                break;\n            }\n        } else if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement(node);\n            case 'continue':\n                return parseContinueStatement(node);\n            case 'debugger':\n                return parseDebuggerStatement(node);\n            case 'do':\n                return parseDoWhileStatement(node);\n            case 'for':\n                return parseForStatement(node);\n            case 'function':\n                return parseFunctionDeclaration(node);\n            case 'if':\n                return parseIfStatement(node);\n            case 'return':\n                return parseReturnStatement(node);\n            case 'switch':\n                return parseSwitchStatement(node);\n            case 'throw':\n                return parseThrowStatement(node);\n            case 'try':\n                return parseTryStatement(node);\n            case 'var':\n                return parseVariableStatement(node);\n            case 'while':\n                return parseWhileStatement(node);\n            case 'with':\n                return parseWithStatement(node);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return node.finishLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var statement, body = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,\n            node = new Node();\n\n        expect('{');\n\n        while (startIndex < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesisCount = state.parenthesizedCount;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            body.push(parseStatementListItem());\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesisCount;\n\n        return node.finishBlockStatement(body);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, param, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            param = parseRestElement();\n            validateParam(options, param.argument, param.argument.name);\n            options.params.push(param);\n            options.defaults.push(null);\n            return false;\n        }\n\n        param = parsePatternWithDefault();\n        validateParam(options, token, token.value);\n\n        if (param.type === Syntax.AssignmentPattern) {\n            def = param.right;\n            param = param.left;\n            ++options.defaultCount;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (startIndex < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return {\n            params: options.params,\n            defaults: options.defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseFunctionDeclaration(node, identifierIsOptional) {\n        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;\n\n        expectKeyword('function');\n        if (!identifierIsOptional || !match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionDeclaration(id, params, defaults, body);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp,\n            params = [], defaults = [], body, previousStrict, node = new Node();\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionExpression(id, params, defaults, body);\n    }\n\n\n    function parseClassBody() {\n        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;\n\n        classBody = new Node();\n\n        expect('{');\n        body = [];\n        while (!match('}')) {\n            if (match(';')) {\n                lex();\n            } else {\n                method = new Node();\n                token = lookahead;\n                isStatic = false;\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                if (key.name === 'static' && lookaheadPropertyName()) {\n                    token = lookahead;\n                    isStatic = true;\n                    computed = match('[');\n                    key = parseObjectPropertyKey();\n                }\n                method = tryParseMethodDefinition(token, key, computed, method);\n                if (method) {\n                    method['static'] = isStatic;\n                    if (method.kind === 'init') {\n                        method.kind = 'method';\n                    }\n                    if (!isStatic) {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n                            if (method.kind !== 'method' || !method.method || method.value.generator) {\n                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n                            }\n                            if (hasConstructor) {\n                                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n                            } else {\n                                hasConstructor = true;\n                            }\n                            method.kind = 'constructor';\n                        }\n                    } else {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n                            throwUnexpectedToken(token, Messages.StaticPrototype);\n                        }\n                    }\n                    method.type = Syntax.MethodDefinition;\n                    delete method.method;\n                    delete method.shorthand;\n                    body.push(method);\n                } else {\n                    throwUnexpectedToken(lookahead);\n                }\n            }\n        }\n        lex();\n        return classBody.finishClassBody(body);\n    }\n\n    function parseClassDeclaration(identifierIsOptional) {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassDeclaration(id, superClass, classBody);\n    }\n\n    function parseClassExpression() {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassExpression(id, superClass, classBody);\n    }\n\n    // Modules grammar from:\n    // people.mozilla.org/~jorendorff/es6-draft.html\n\n    function parseModuleSpecifier() {\n        var node = new Node();\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError(Messages.InvalidModuleSpecifier);\n        }\n        return node.finishLiteral(lex());\n    }\n\n    function parseExportSpecifier() {\n        var exported, local, node = new Node(), def;\n        if (matchKeyword('default')) {\n            // export {default} from 'something';\n            def = new Node();\n            lex();\n            local = def.finishIdentifier('default');\n        } else {\n            local = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            exported = parseNonComputedProperty();\n        }\n        return node.finishExportSpecifier(local, exported);\n    }\n\n    function parseExportNamedDeclaration(node) {\n        var declaration = null,\n            isExportFromIdentifier,\n            src = null, specifiers = [];\n\n        // non-default export\n        if (lookahead.type === Token.Keyword) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n                case 'let':\n                case 'const':\n                case 'var':\n                case 'class':\n                case 'function':\n                    declaration = parseStatementListItem();\n                    return node.finishExportNamedDeclaration(declaration, specifiers, null);\n            }\n        }\n\n        expect('{');\n        if (!match('}')) {\n            do {\n                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n                specifiers.push(parseExportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from 'foo';\n            // export {foo} from 'foo';\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return node.finishExportNamedDeclaration(declaration, specifiers, src);\n    }\n\n    function parseExportDefaultDeclaration(node) {\n        var declaration = null,\n            expression = null;\n\n        // covers:\n        // export default ...\n        expectKeyword('default');\n\n        if (matchKeyword('function')) {\n            // covers:\n            // export default function foo () {}\n            // export default function () {}\n            declaration = parseFunctionDeclaration(new Node(), true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n        if (matchKeyword('class')) {\n            declaration = parseClassDeclaration(true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n\n        if (matchContextualKeyword('from')) {\n            throwError(Messages.UnexpectedToken, lookahead.value);\n        }\n\n        // covers:\n        // export default {};\n        // export default [];\n        // export default (1 + 2);\n        if (match('{')) {\n            expression = parseObjectInitialiser();\n        } else if (match('[')) {\n            expression = parseArrayInitialiser();\n        } else {\n            expression = parseAssignmentExpression();\n        }\n        consumeSemicolon();\n        return node.finishExportDefaultDeclaration(expression);\n    }\n\n    function parseExportAllDeclaration(node) {\n        var src;\n\n        // covers:\n        // export * from 'foo';\n        expect('*');\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishExportAllDeclaration(src);\n    }\n\n    function parseExportDeclaration() {\n        var node = new Node();\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalExportDeclaration);\n        }\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            return parseExportDefaultDeclaration(node);\n        }\n        if (match('*')) {\n            return parseExportAllDeclaration(node);\n        }\n        return parseExportNamedDeclaration(node);\n    }\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var local, imported, node = new Node();\n\n        imported = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            local = parseVariableIdentifier();\n        }\n\n        return node.finishImportSpecifier(local, imported);\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        if (!match('}')) {\n            do {\n                specifiers.push(parseImportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var local, node = new Node();\n\n        local = parseNonComputedProperty();\n\n        return node.finishImportDefaultSpecifier(local);\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var local, node = new Node();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError(Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        local = parseNonComputedProperty();\n\n        return node.finishImportNamespaceSpecifier(local);\n    }\n\n    function parseImportDeclaration() {\n        var specifiers, src, node = new Node();\n\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalImportDeclaration);\n        }\n\n        expectKeyword('import');\n        specifiers = [];\n\n        if (lookahead.type === Token.StringLiteral) {\n            // covers:\n            // import 'foo';\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n            return node.finishImportDeclaration(specifiers, src);\n        }\n\n        if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n            // covers:\n            // import foo\n            // import foo, ...\n            specifiers.push(parseImportDefaultSpecifier());\n            if (match(',')) {\n                lex();\n            }\n        }\n        if (match('*')) {\n            // covers:\n            // import foo, * as foo\n            // import * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n        } else if (match('{')) {\n            // covers:\n            // import foo, {bar}\n            // import {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n        }\n\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishImportDeclaration(specifiers, src);\n    }\n\n    // 14 Program\n\n    function parseScriptBody() {\n        var statement, body = [], token, directive, firstRestricted;\n\n        while (startIndex < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (startIndex < length) {\n            statement = parseStatementListItem();\n            /* istanbul ignore if */\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            body.push(statement);\n        }\n        return body;\n    }\n\n    function parseProgram() {\n        var body, node;\n\n        peek();\n        node = new Node();\n\n        body = parseScriptBody();\n        return node.finishProgram(body);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    lex();\n                } catch (lexError) {\n                    if (extra.errors) {\n                        recordError(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n        sourceType = 'script';\n        strict = false;\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n            if (options.sourceType === 'module') {\n                // very restrictive condition for now\n                sourceType = options.sourceType;\n                strict = true;\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '2.2.0';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n},{}],171:[function(require,module,exports){\n(function(definition){if(typeof exports===\"object\"){module.exports=definition();}else if(typeof define===\"function\"&&define.amd){define(definition);}else{mori=definition();}})(function(){return function(){\nvar g,aa=this;\nfunction m(a){var b=typeof a;if(\"object\"==b)if(a){if(a instanceof Array)return\"array\";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if(\"[object Window]\"==c)return\"object\";if(\"[object Array]\"==c||\"number\"==typeof a.length&&\"undefined\"!=typeof a.splice&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"splice\"))return\"array\";if(\"[object Function]\"==c||\"undefined\"!=typeof a.call&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"call\"))return\"function\"}else return\"null\";else if(\"function\"==\nb&&\"undefined\"==typeof a.call)return\"object\";return b}var ba=\"closure_uid_\"+(1E9*Math.random()>>>0),ca=0;function p(a,b){var c=a.split(\".\"),d=aa;c[0]in d||!d.execScript||d.execScript(\"var \"+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d=d[e]?d[e]:d[e]={}:d[e]=b};function da(a,b){for(var c in a)b.call(void 0,a[c],c,a)};function ea(a,b){null!=a&&this.append.apply(this,arguments)}ea.prototype.Va=\"\";ea.prototype.append=function(a,b,c){this.Va+=a;if(null!=b)for(var d=1;d<arguments.length;d++)this.Va+=arguments[d];return this};ea.prototype.toString=function(){return this.Va};function fa(a,b){a.sort(b||ga)}function ha(a,b){for(var c=0;c<a.length;c++)a[c]={index:c,value:a[c]};var d=b||ga;fa(a,function(a,b){return d(a.value,b.value)||a.index-b.index});for(c=0;c<a.length;c++)a[c]=a[c].value}function ga(a,b){return a>b?1:a<b?-1:0};var ia=null,ja=null;function ka(){return new la(null,5,[ma,!0,oa,!0,pa,!1,qa,!1,ra,ia],null)}function r(a){return null!=a&&!1!==a}function sa(a){return r(a)?!1:!0}function s(a,b){return a[m(null==b?null:b)]?!0:a._?!0:u?!1:null}function ta(a){return null==a?null:a.constructor}function x(a,b){var c=ta(b),c=r(r(c)?c.Db:c)?c.Bb:m(b);return Error([\"No protocol method \",a,\" defined for type \",c,\": \",b].join(\"\"))}function ua(a){var b=a.Bb;return r(b)?b:\"\"+A.b(a)}\nfunction va(a){for(var b=a.length,c=Array(b),d=0;;)if(d<b)c[d]=a[d],d+=1;else break;return c}function wa(a){return Array.prototype.slice.call(arguments)}\nvar xa=function(){function a(a,b){return C.c?C.c(function(a,b){a.push(b);return a},[],b):C.call(null,function(a,b){a.push(b);return a},[],b)}function b(a){return c.a(null,a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,0,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),ya={},za={};\nfunction Aa(a){if(a?a.L:a)return a.L(a);var b;b=Aa[m(null==a?null:a)];if(!b&&(b=Aa._,!b))throw x(\"ICounted.-count\",a);return b.call(null,a)}function Ba(a){if(a?a.I:a)return a.I(a);var b;b=Ba[m(null==a?null:a)];if(!b&&(b=Ba._,!b))throw x(\"IEmptyableCollection.-empty\",a);return b.call(null,a)}var Ca={};function Da(a,b){if(a?a.G:a)return a.G(a,b);var c;c=Da[m(null==a?null:a)];if(!c&&(c=Da._,!c))throw x(\"ICollection.-conj\",a);return c.call(null,a,b)}\nvar Ea={},D=function(){function a(a,b,c){if(a?a.aa:a)return a.aa(a,b,c);var h;h=D[m(null==a?null:a)];if(!h&&(h=D._,!h))throw x(\"IIndexed.-nth\",a);return h.call(null,a,b,c)}function b(a,b){if(a?a.J:a)return a.J(a,b);var c;c=D[m(null==a?null:a)];if(!c&&(c=D._,!c))throw x(\"IIndexed.-nth\",a);return c.call(null,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}(),\nFa={};function Ha(a){if(a?a.Q:a)return a.Q(a);var b;b=Ha[m(null==a?null:a)];if(!b&&(b=Ha._,!b))throw x(\"ISeq.-first\",a);return b.call(null,a)}function Ia(a){if(a?a.S:a)return a.S(a);var b;b=Ia[m(null==a?null:a)];if(!b&&(b=Ia._,!b))throw x(\"ISeq.-rest\",a);return b.call(null,a)}\nvar Ja={},Ka={},La=function(){function a(a,b,c){if(a?a.C:a)return a.C(a,b,c);var h;h=La[m(null==a?null:a)];if(!h&&(h=La._,!h))throw x(\"ILookup.-lookup\",a);return h.call(null,a,b,c)}function b(a,b){if(a?a.u:a)return a.u(a,b);var c;c=La[m(null==a?null:a)];if(!c&&(c=La._,!c))throw x(\"ILookup.-lookup\",a);return c.call(null,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=\na;return c}(),Ma={};function Na(a,b){if(a?a.kb:a)return a.kb(a,b);var c;c=Na[m(null==a?null:a)];if(!c&&(c=Na._,!c))throw x(\"IAssociative.-contains-key?\",a);return c.call(null,a,b)}function Oa(a,b,c){if(a?a.ua:a)return a.ua(a,b,c);var d;d=Oa[m(null==a?null:a)];if(!d&&(d=Oa._,!d))throw x(\"IAssociative.-assoc\",a);return d.call(null,a,b,c)}var Pa={};function Qa(a,b){if(a?a.nb:a)return a.nb(a,b);var c;c=Qa[m(null==a?null:a)];if(!c&&(c=Qa._,!c))throw x(\"IMap.-dissoc\",a);return c.call(null,a,b)}var Sa={};\nfunction Ta(a){if(a?a.$a:a)return a.$a(a);var b;b=Ta[m(null==a?null:a)];if(!b&&(b=Ta._,!b))throw x(\"IMapEntry.-key\",a);return b.call(null,a)}function Ua(a){if(a?a.ab:a)return a.ab(a);var b;b=Ua[m(null==a?null:a)];if(!b&&(b=Ua._,!b))throw x(\"IMapEntry.-val\",a);return b.call(null,a)}var Va={};function Wa(a,b){if(a?a.vb:a)return a.vb(a,b);var c;c=Wa[m(null==a?null:a)];if(!c&&(c=Wa._,!c))throw x(\"ISet.-disjoin\",a);return c.call(null,a,b)}\nfunction Xa(a){if(a?a.Ia:a)return a.Ia(a);var b;b=Xa[m(null==a?null:a)];if(!b&&(b=Xa._,!b))throw x(\"IStack.-peek\",a);return b.call(null,a)}function Ya(a){if(a?a.Ja:a)return a.Ja(a);var b;b=Ya[m(null==a?null:a)];if(!b&&(b=Ya._,!b))throw x(\"IStack.-pop\",a);return b.call(null,a)}var Za={};function $a(a,b,c){if(a?a.Pa:a)return a.Pa(a,b,c);var d;d=$a[m(null==a?null:a)];if(!d&&(d=$a._,!d))throw x(\"IVector.-assoc-n\",a);return d.call(null,a,b,c)}\nfunction ab(a){if(a?a.ub:a)return a.ub(a);var b;b=ab[m(null==a?null:a)];if(!b&&(b=ab._,!b))throw x(\"IDeref.-deref\",a);return b.call(null,a)}var bb={};function cb(a){if(a?a.D:a)return a.D(a);var b;b=cb[m(null==a?null:a)];if(!b&&(b=cb._,!b))throw x(\"IMeta.-meta\",a);return b.call(null,a)}var db={};function eb(a,b){if(a?a.F:a)return a.F(a,b);var c;c=eb[m(null==a?null:a)];if(!c&&(c=eb._,!c))throw x(\"IWithMeta.-with-meta\",a);return c.call(null,a,b)}\nvar fb={},gb=function(){function a(a,b,c){if(a?a.M:a)return a.M(a,b,c);var h;h=gb[m(null==a?null:a)];if(!h&&(h=gb._,!h))throw x(\"IReduce.-reduce\",a);return h.call(null,a,b,c)}function b(a,b){if(a?a.N:a)return a.N(a,b);var c;c=gb[m(null==a?null:a)];if(!c&&(c=gb._,!c))throw x(\"IReduce.-reduce\",a);return c.call(null,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}();\nfunction hb(a,b,c){if(a?a.Za:a)return a.Za(a,b,c);var d;d=hb[m(null==a?null:a)];if(!d&&(d=hb._,!d))throw x(\"IKVReduce.-kv-reduce\",a);return d.call(null,a,b,c)}function ib(a,b){if(a?a.v:a)return a.v(a,b);var c;c=ib[m(null==a?null:a)];if(!c&&(c=ib._,!c))throw x(\"IEquiv.-equiv\",a);return c.call(null,a,b)}function jb(a){if(a?a.B:a)return a.B(a);var b;b=jb[m(null==a?null:a)];if(!b&&(b=jb._,!b))throw x(\"IHash.-hash\",a);return b.call(null,a)}var kb={};\nfunction lb(a){if(a?a.H:a)return a.H(a);var b;b=lb[m(null==a?null:a)];if(!b&&(b=lb._,!b))throw x(\"ISeqable.-seq\",a);return b.call(null,a)}var mb={},nb={},ob={};function pb(a){if(a?a.Xa:a)return a.Xa(a);var b;b=pb[m(null==a?null:a)];if(!b&&(b=pb._,!b))throw x(\"IReversible.-rseq\",a);return b.call(null,a)}function qb(a,b){if(a?a.yb:a)return a.yb(a,b);var c;c=qb[m(null==a?null:a)];if(!c&&(c=qb._,!c))throw x(\"ISorted.-sorted-seq\",a);return c.call(null,a,b)}\nfunction rb(a,b,c){if(a?a.zb:a)return a.zb(a,b,c);var d;d=rb[m(null==a?null:a)];if(!d&&(d=rb._,!d))throw x(\"ISorted.-sorted-seq-from\",a);return d.call(null,a,b,c)}function sb(a,b){if(a?a.xb:a)return a.xb(a,b);var c;c=sb[m(null==a?null:a)];if(!c&&(c=sb._,!c))throw x(\"ISorted.-entry-key\",a);return c.call(null,a,b)}function tb(a){if(a?a.wb:a)return a.wb(a);var b;b=tb[m(null==a?null:a)];if(!b&&(b=tb._,!b))throw x(\"ISorted.-comparator\",a);return b.call(null,a)}\nfunction ub(a,b){if(a?a.Sb:a)return a.Sb(0,b);var c;c=ub[m(null==a?null:a)];if(!c&&(c=ub._,!c))throw x(\"IWriter.-write\",a);return c.call(null,a,b)}var vb={};function wb(a,b,c){if(a?a.w:a)return a.w(a,b,c);var d;d=wb[m(null==a?null:a)];if(!d&&(d=wb._,!d))throw x(\"IPrintWithWriter.-pr-writer\",a);return d.call(null,a,b,c)}function xb(a,b,c){if(a?a.Rb:a)return a.Rb(0,b,c);var d;d=xb[m(null==a?null:a)];if(!d&&(d=xb._,!d))throw x(\"IWatchable.-notify-watches\",a);return d.call(null,a,b,c)}\nfunction yb(a){if(a?a.Wa:a)return a.Wa(a);var b;b=yb[m(null==a?null:a)];if(!b&&(b=yb._,!b))throw x(\"IEditableCollection.-as-transient\",a);return b.call(null,a)}function zb(a,b){if(a?a.Ka:a)return a.Ka(a,b);var c;c=zb[m(null==a?null:a)];if(!c&&(c=zb._,!c))throw x(\"ITransientCollection.-conj!\",a);return c.call(null,a,b)}function Ab(a){if(a?a.Oa:a)return a.Oa(a);var b;b=Ab[m(null==a?null:a)];if(!b&&(b=Ab._,!b))throw x(\"ITransientCollection.-persistent!\",a);return b.call(null,a)}\nfunction Bb(a,b,c){if(a?a.cb:a)return a.cb(a,b,c);var d;d=Bb[m(null==a?null:a)];if(!d&&(d=Bb._,!d))throw x(\"ITransientAssociative.-assoc!\",a);return d.call(null,a,b,c)}function Cb(a,b){if(a?a.Ab:a)return a.Ab(a,b);var c;c=Cb[m(null==a?null:a)];if(!c&&(c=Cb._,!c))throw x(\"ITransientMap.-dissoc!\",a);return c.call(null,a,b)}function Db(a,b,c){if(a?a.Pb:a)return a.Pb(0,b,c);var d;d=Db[m(null==a?null:a)];if(!d&&(d=Db._,!d))throw x(\"ITransientVector.-assoc-n!\",a);return d.call(null,a,b,c)}\nfunction Eb(a){if(a?a.Qb:a)return a.Qb();var b;b=Eb[m(null==a?null:a)];if(!b&&(b=Eb._,!b))throw x(\"ITransientVector.-pop!\",a);return b.call(null,a)}function Fb(a,b){if(a?a.Ob:a)return a.Ob(0,b);var c;c=Fb[m(null==a?null:a)];if(!c&&(c=Fb._,!c))throw x(\"ITransientSet.-disjoin!\",a);return c.call(null,a,b)}function Gb(a){if(a?a.Kb:a)return a.Kb();var b;b=Gb[m(null==a?null:a)];if(!b&&(b=Gb._,!b))throw x(\"IChunk.-drop-first\",a);return b.call(null,a)}\nfunction Hb(a){if(a?a.sb:a)return a.sb(a);var b;b=Hb[m(null==a?null:a)];if(!b&&(b=Hb._,!b))throw x(\"IChunkedSeq.-chunked-first\",a);return b.call(null,a)}function Ib(a){if(a?a.tb:a)return a.tb(a);var b;b=Ib[m(null==a?null:a)];if(!b&&(b=Ib._,!b))throw x(\"IChunkedSeq.-chunked-rest\",a);return b.call(null,a)}function Jb(a){if(a?a.rb:a)return a.rb(a);var b;b=Jb[m(null==a?null:a)];if(!b&&(b=Jb._,!b))throw x(\"IChunkedNext.-chunked-next\",a);return b.call(null,a)}\nfunction Kb(a){this.vc=a;this.q=0;this.i=1073741824}Kb.prototype.Sb=function(a,b){return this.vc.append(b)};function Lb(a){var b=new ea;a.w(null,new Kb(b),ka());return\"\"+A.b(b)}var Mb=\"undefined\"!==typeof Math.imul&&0!==(Math.imul.a?Math.imul.a(4294967295,5):Math.imul.call(null,4294967295,5))?function(a,b){return Math.imul(a,b)}:function(a,b){var c=a&65535,d=b&65535;return c*d+((a>>>16&65535)*d+c*(b>>>16&65535)<<16>>>0)|0};function Nb(a){a=Mb(a,3432918353);return Mb(a<<15|a>>>-15,461845907)}\nfunction Ob(a,b){var c=a^b;return Mb(c<<13|c>>>-13,5)+3864292196}function Pb(a,b){var c=a^b,c=Mb(c^c>>>16,2246822507),c=Mb(c^c>>>13,3266489909);return c^c>>>16}var Qb={},Rb=0;function Sb(a){255<Rb&&(Qb={},Rb=0);var b=Qb[a];if(\"number\"!==typeof b){a:if(null!=a)if(b=a.length,0<b){for(var c=0,d=0;;)if(c<b)var e=c+1,d=Mb(31,d)+a.charCodeAt(c),c=e;else{b=d;break a}b=void 0}else b=0;else b=0;Qb[a]=b;Rb+=1}return a=b}\nfunction Tb(a){a&&(a.i&4194304||a.Dc)?a=a.B(null):\"number\"===typeof a?a=Math.floor(a)%2147483647:!0===a?a=1:!1===a?a=0:\"string\"===typeof a?(a=Sb(a),0!==a&&(a=Nb(a),a=Ob(0,a),a=Pb(a,4))):a=null==a?0:u?jb(a):null;return a}\nfunction Ub(a){var b;b=a.name;var c;a:{c=1;for(var d=0;;)if(c<b.length){var e=c+2,d=Ob(d,Nb(b.charCodeAt(c-1)|b.charCodeAt(c)<<16));c=e}else{c=d;break a}c=void 0}c=1===(b.length&1)?c^Nb(b.charCodeAt(b.length-1)):c;b=Pb(c,Mb(2,b.length));a=Sb(a.fa);return b^a+2654435769+(b<<6)+(b>>2)}\nfunction Vb(a,b){if(r(Wb.a?Wb.a(a,b):Wb.call(null,a,b)))return 0;var c=sa(a.fa);if(r(c?b.fa:c))return-1;if(r(a.fa)){if(sa(b.fa))return 1;c=Xb.a?Xb.a(a.fa,b.fa):Xb.call(null,a.fa,b.fa);return 0===c?Xb.a?Xb.a(a.name,b.name):Xb.call(null,a.name,b.name):c}return Yb?Xb.a?Xb.a(a.name,b.name):Xb.call(null,a.name,b.name):null}function Zb(a,b,c,d,e){this.fa=a;this.name=b;this.Na=c;this.Ua=d;this.W=e;this.i=2154168321;this.q=4096}g=Zb.prototype;g.w=function(a,b){return ub(b,this.Na)};\ng.B=function(){var a=this.Ua;return null!=a?a:this.Ua=a=Ub(this)};g.F=function(a,b){return new Zb(this.fa,this.name,this.Na,this.Ua,b)};g.D=function(){return this.W};g.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return La.c(c,this,null);case 3:return La.c(c,this,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return La.c(a,this,null)};\ng.a=function(a,b){return La.c(a,this,b)};g.v=function(a,b){return b instanceof Zb?this.Na===b.Na:!1};g.toString=function(){return this.Na};var $b=function(){function a(a,b){var c=null!=a?\"\"+A.b(a)+\"/\"+A.b(b):b;return new Zb(a,b,c,null,null)}function b(a){return a instanceof Zb?a:c.a(null,a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}();\nfunction E(a){if(null==a)return null;if(a&&(a.i&8388608||a.hc))return a.H(null);if(a instanceof Array||\"string\"===typeof a)return 0===a.length?null:new ac(a,0);if(s(kb,a))return lb(a);if(u)throw Error(\"\"+A.b(a)+\" is not ISeqable\");return null}function F(a){if(null==a)return null;if(a&&(a.i&64||a.bb))return a.Q(null);a=E(a);return null==a?null:Ha(a)}function G(a){return null!=a?a&&(a.i&64||a.bb)?a.S(null):(a=E(a))?Ia(a):H:H}function I(a){return null==a?null:a&&(a.i&128||a.ob)?a.U(null):E(G(a))}\nvar Wb=function(){function a(a,b){return null==a?null==b:a===b||ib(a,b)}var b=null,c=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){for(;;)if(b.a(a,d))if(I(e))a=d,d=F(e),e=I(e);else return b.a(d,F(e));else return!1}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return!0;case 2:return a.call(this,b,\ne);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.b=function(){return!0};b.a=a;b.d=c.d;return b}();function bc(a,b){var c=Nb(a),c=Ob(0,c);return Pb(c,b)}function cc(a){var b=0,c=1;for(a=E(a);;)if(null!=a)b+=1,c=Mb(31,c)+Tb(F(a))|0,a=I(a);else return bc(c,b)}function dc(a){var b=0,c=0;for(a=E(a);;)if(null!=a)b+=1,c=c+Tb(F(a))|0,a=I(a);else return bc(c,b)}za[\"null\"]=!0;Aa[\"null\"]=function(){return 0};\nDate.prototype.v=function(a,b){return b instanceof Date&&this.toString()===b.toString()};ib.number=function(a,b){return a===b};bb[\"function\"]=!0;cb[\"function\"]=function(){return null};ya[\"function\"]=!0;jb._=function(a){return a[ba]||(a[ba]=++ca)};function ec(a){this.l=a;this.q=0;this.i=32768}ec.prototype.ub=function(){return this.l};function fc(a){return a instanceof ec}\nvar gc=function(){function a(a,b,c,d){for(var l=Aa(a);;)if(d<l){c=b.a?b.a(c,D.a(a,d)):b.call(null,c,D.a(a,d));if(fc(c))return K.b?K.b(c):K.call(null,c);d+=1}else return c}function b(a,b,c){for(var d=Aa(a),l=0;;)if(l<d){c=b.a?b.a(c,D.a(a,l)):b.call(null,c,D.a(a,l));if(fc(c))return K.b?K.b(c):K.call(null,c);l+=1}else return c}function c(a,b){var c=Aa(a);if(0===c)return b.o?b.o():b.call(null);for(var d=D.a(a,0),l=1;;)if(l<c){d=b.a?b.a(d,D.a(a,l)):b.call(null,d,D.a(a,l));if(fc(d))return K.b?K.b(d):K.call(null,\nd);l+=1}else return d}var d=null,d=function(d,f,h,k){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,h);case 4:return a.call(this,d,f,h,k)}throw Error(\"Invalid arity: \"+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),hc=function(){function a(a,b,c,d){for(var l=a.length;;)if(d<l){c=b.a?b.a(c,a[d]):b.call(null,c,a[d]);if(fc(c))return K.b?K.b(c):K.call(null,c);d+=1}else return c}function b(a,b,c){for(var d=a.length,l=0;;)if(l<d){c=b.a?b.a(c,a[l]):b.call(null,c,\na[l]);if(fc(c))return K.b?K.b(c):K.call(null,c);l+=1}else return c}function c(a,b){var c=a.length;if(0===a.length)return b.o?b.o():b.call(null);for(var d=a[0],l=1;;)if(l<c){d=b.a?b.a(d,a[l]):b.call(null,d,a[l]);if(fc(d))return K.b?K.b(d):K.call(null,d);l+=1}else return d}var d=null,d=function(d,f,h,k){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,h);case 4:return a.call(this,d,f,h,k)}throw Error(\"Invalid arity: \"+arguments.length);};d.a=c;d.c=b;d.n=a;return d}();\nfunction ic(a){return a?a.i&2||a.Yb?!0:a.i?!1:s(za,a):s(za,a)}function jc(a){return a?a.i&16||a.Lb?!0:a.i?!1:s(Ea,a):s(Ea,a)}function ac(a,b){this.e=a;this.p=b;this.i=166199550;this.q=8192}g=ac.prototype;g.toString=function(){return Lb(this)};g.J=function(a,b){var c=b+this.p;return c<this.e.length?this.e[c]:null};g.aa=function(a,b,c){a=b+this.p;return a<this.e.length?this.e[a]:c};g.U=function(){return this.p+1<this.e.length?new ac(this.e,this.p+1):null};g.L=function(){return this.e.length-this.p};\ng.Xa=function(){var a=Aa(this);return 0<a?new kc(this,a-1,null):null};g.B=function(){return cc(this)};g.v=function(a,b){return lc.a?lc.a(this,b):lc.call(null,this,b)};g.I=function(){return H};g.N=function(a,b){return hc.n(this.e,b,this.e[this.p],this.p+1)};g.M=function(a,b,c){return hc.n(this.e,b,c,this.p)};g.Q=function(){return this.e[this.p]};g.S=function(){return this.p+1<this.e.length?new ac(this.e,this.p+1):H};g.H=function(){return this};\ng.G=function(a,b){return M.a?M.a(b,this):M.call(null,b,this)};\nvar mc=function(){function a(a,b){return b<a.length?new ac(a,b):null}function b(a){return c.a(a,0)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),J=function(){function a(a,b){return mc.a(a,b)}function b(a){return mc.a(a,0)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+\narguments.length);};c.b=b;c.a=a;return c}();function kc(a,b,c){this.jb=a;this.p=b;this.j=c;this.i=32374990;this.q=8192}g=kc.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};g.U=function(){return 0<this.p?new kc(this.jb,this.p-1,null):null};g.L=function(){return this.p+1};g.B=function(){return cc(this)};g.v=function(a,b){return lc.a?lc.a(this,b):lc.call(null,this,b)};g.I=function(){return N.a?N.a(H,this.j):N.call(null,H,this.j)};\ng.N=function(a,b){return nc.a?nc.a(b,this):nc.call(null,b,this)};g.M=function(a,b,c){return nc.c?nc.c(b,c,this):nc.call(null,b,c,this)};g.Q=function(){return D.a(this.jb,this.p)};g.S=function(){return 0<this.p?new kc(this.jb,this.p-1,null):H};g.H=function(){return this};g.F=function(a,b){return new kc(this.jb,this.p,b)};g.G=function(a,b){return M.a?M.a(b,this):M.call(null,b,this)};function oc(a){for(;;){var b=I(a);if(null!=b)a=b;else return F(a)}}ib._=function(a,b){return a===b};\nvar pc=function(){function a(a,b){return null!=a?Da(a,b):Da(H,b)}var b=null,c=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){for(;;)if(r(e))a=b.a(a,d),d=F(e),e=I(e);else return b.a(a,d)}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+\narguments.length);};b.k=2;b.f=c.f;b.a=a;b.d=c.d;return b}();function qc(a){return null==a?null:Ba(a)}function O(a){if(null!=a)if(a&&(a.i&2||a.Yb))a=a.L(null);else if(a instanceof Array)a=a.length;else if(\"string\"===typeof a)a=a.length;else if(s(za,a))a=Aa(a);else if(u)a:{a=E(a);for(var b=0;;){if(ic(a)){a=b+Aa(a);break a}a=I(a);b+=1}a=void 0}else a=null;else a=0;return a}\nvar rc=function(){function a(a,b,c){for(;;){if(null==a)return c;if(0===b)return E(a)?F(a):c;if(jc(a))return D.c(a,b,c);if(E(a))a=I(a),b-=1;else return u?c:null}}function b(a,b){for(;;){if(null==a)throw Error(\"Index out of bounds\");if(0===b){if(E(a))return F(a);throw Error(\"Index out of bounds\");}if(jc(a))return D.a(a,b);if(E(a)){var c=I(a),h=b-1;a=c;b=h}else{if(u)throw Error(\"Index out of bounds\");return null}}}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,\nc,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}(),P=function(){function a(a,b,c){if(\"number\"!==typeof b)throw Error(\"index argument to nth must be a number.\");if(null==a)return c;if(a&&(a.i&16||a.Lb))return a.aa(null,b,c);if(a instanceof Array||\"string\"===typeof a)return b<a.length?a[b]:c;if(s(Ea,a))return D.a(a,b);if(a?a.i&64||a.bb||(a.i?0:s(Fa,a)):s(Fa,a))return rc.c(a,b,c);if(u)throw Error(\"nth not supported on this type \"+A.b(ua(ta(a))));return null}function b(a,\nb){if(\"number\"!==typeof b)throw Error(\"index argument to nth must be a number\");if(null==a)return a;if(a&&(a.i&16||a.Lb))return a.J(null,b);if(a instanceof Array||\"string\"===typeof a)return b<a.length?a[b]:null;if(s(Ea,a))return D.a(a,b);if(a?a.i&64||a.bb||(a.i?0:s(Fa,a)):s(Fa,a))return rc.a(a,b);if(u)throw Error(\"nth not supported on this type \"+A.b(ua(ta(a))));return null}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+\narguments.length);};c.a=b;c.c=a;return c}(),Q=function(){function a(a,b,c){return null!=a?a&&(a.i&256||a.Mb)?a.C(null,b,c):a instanceof Array?b<a.length?a[b]:c:\"string\"===typeof a?b<a.length?a[b]:c:s(Ka,a)?La.c(a,b,c):u?c:null:c}function b(a,b){return null==a?null:a&&(a.i&256||a.Mb)?a.u(null,b):a instanceof Array?b<a.length?a[b]:null:\"string\"===typeof a?b<a.length?a[b]:null:s(Ka,a)?La.a(a,b):null}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,\nc,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}(),R=function(){function a(a,b,c){return null!=a?Oa(a,b,c):sc.a?sc.a([b],[c]):sc.call(null,[b],[c])}var b=null,c=function(){function a(b,d,k,l){var n=null;3<arguments.length&&(n=J(Array.prototype.slice.call(arguments,3),0));return c.call(this,b,d,k,n)}function c(a,d,e,l){for(;;)if(a=b.c(a,d,e),r(l))d=F(l),e=F(I(l)),l=I(I(l));else return a}a.k=3;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=I(a);var l=F(a);a=G(a);return c(b,\nd,l,a)};a.d=c;return a}(),b=function(b,e,f,h){switch(arguments.length){case 3:return a.call(this,b,e,f);default:return c.d(b,e,f,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=3;b.f=c.f;b.c=a;b.d=c.d;return b}(),tc=function(){function a(a,b){return null==a?null:Qa(a,b)}var b=null,c=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){for(;;){if(null==a)return null;a=b.a(a,d);\nif(r(e))d=F(e),e=I(e);else return a}}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function uc(a){var b=\"function\"==m(a);return b?b:a?r(r(null)?null:a.Xb)?!0:a.Cb?!1:s(ya,a):s(ya,a)}\nfunction vc(a,b){this.h=a;this.j=b;this.q=0;this.i=393217}g=vc.prototype;\ng.call=function(){var a=null;return a=function(a,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,Ra,wc){switch(arguments.length){case 1:var z=a,z=this;return z.h.o?z.h.o():z.h.call(null);case 2:return z=a,z=this,z.h.b?z.h.b(c):z.h.call(null,c);case 3:return z=a,z=this,z.h.a?z.h.a(c,d):z.h.call(null,c,d);case 4:return z=a,z=this,z.h.c?z.h.c(c,d,e):z.h.call(null,c,d,e);case 5:return z=a,z=this,z.h.n?z.h.n(c,d,e,f):z.h.call(null,c,d,e,f);case 6:return z=a,z=this,z.h.s?z.h.s(c,d,e,f,h):z.h.call(null,c,d,e,f,\nh);case 7:return z=a,z=this,z.h.X?z.h.X(c,d,e,f,h,k):z.h.call(null,c,d,e,f,h,k);case 8:return z=a,z=this,z.h.ga?z.h.ga(c,d,e,f,h,k,l):z.h.call(null,c,d,e,f,h,k,l);case 9:return z=a,z=this,z.h.Ga?z.h.Ga(c,d,e,f,h,k,l,n):z.h.call(null,c,d,e,f,h,k,l,n);case 10:return z=a,z=this,z.h.Ha?z.h.Ha(c,d,e,f,h,k,l,n,q):z.h.call(null,c,d,e,f,h,k,l,n,q);case 11:return z=a,z=this,z.h.va?z.h.va(c,d,e,f,h,k,l,n,q,t):z.h.call(null,c,d,e,f,h,k,l,n,q,t);case 12:return z=a,z=this,z.h.wa?z.h.wa(c,d,e,f,h,k,l,n,q,t,v):\nz.h.call(null,c,d,e,f,h,k,l,n,q,t,v);case 13:return z=a,z=this,z.h.xa?z.h.xa(c,d,e,f,h,k,l,n,q,t,v,w):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w);case 14:return z=a,z=this,z.h.ya?z.h.ya(c,d,e,f,h,k,l,n,q,t,v,w,y):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y);case 15:return z=a,z=this,z.h.za?z.h.za(c,d,e,f,h,k,l,n,q,t,v,w,y,B):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B);case 16:return z=a,z=this,z.h.Aa?z.h.Aa(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L);case 17:return z=a,z=this,\nz.h.Ba?z.h.Ba(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U);case 18:return z=a,z=this,z.h.Ca?z.h.Ca(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z);case 19:return z=a,z=this,z.h.Da?z.h.Da(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na);case 20:return z=a,z=this,z.h.Ea?z.h.Ea(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga);case 21:return z=\na,z=this,z.h.Fa?z.h.Fa(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,Ra):z.h.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,Ra);case 22:return z=a,z=this,S.bc?S.bc(z.h,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,Ra,wc):S.call(null,z.h,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,Ra,wc)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.o=function(){return this.h.o?this.h.o():this.h.call(null)};\ng.b=function(a){return this.h.b?this.h.b(a):this.h.call(null,a)};g.a=function(a,b){return this.h.a?this.h.a(a,b):this.h.call(null,a,b)};g.c=function(a,b,c){return this.h.c?this.h.c(a,b,c):this.h.call(null,a,b,c)};g.n=function(a,b,c,d){return this.h.n?this.h.n(a,b,c,d):this.h.call(null,a,b,c,d)};g.s=function(a,b,c,d,e){return this.h.s?this.h.s(a,b,c,d,e):this.h.call(null,a,b,c,d,e)};g.X=function(a,b,c,d,e,f){return this.h.X?this.h.X(a,b,c,d,e,f):this.h.call(null,a,b,c,d,e,f)};\ng.ga=function(a,b,c,d,e,f,h){return this.h.ga?this.h.ga(a,b,c,d,e,f,h):this.h.call(null,a,b,c,d,e,f,h)};g.Ga=function(a,b,c,d,e,f,h,k){return this.h.Ga?this.h.Ga(a,b,c,d,e,f,h,k):this.h.call(null,a,b,c,d,e,f,h,k)};g.Ha=function(a,b,c,d,e,f,h,k,l){return this.h.Ha?this.h.Ha(a,b,c,d,e,f,h,k,l):this.h.call(null,a,b,c,d,e,f,h,k,l)};g.va=function(a,b,c,d,e,f,h,k,l,n){return this.h.va?this.h.va(a,b,c,d,e,f,h,k,l,n):this.h.call(null,a,b,c,d,e,f,h,k,l,n)};\ng.wa=function(a,b,c,d,e,f,h,k,l,n,q){return this.h.wa?this.h.wa(a,b,c,d,e,f,h,k,l,n,q):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q)};g.xa=function(a,b,c,d,e,f,h,k,l,n,q,t){return this.h.xa?this.h.xa(a,b,c,d,e,f,h,k,l,n,q,t):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t)};g.ya=function(a,b,c,d,e,f,h,k,l,n,q,t,v){return this.h.ya?this.h.ya(a,b,c,d,e,f,h,k,l,n,q,t,v):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v)};\ng.za=function(a,b,c,d,e,f,h,k,l,n,q,t,v,w){return this.h.za?this.h.za(a,b,c,d,e,f,h,k,l,n,q,t,v,w):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v,w)};g.Aa=function(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y){return this.h.Aa?this.h.Aa(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v,w,y)};g.Ba=function(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B){return this.h.Ba?this.h.Ba(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B)};\ng.Ca=function(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L){return this.h.Ca?this.h.Ca(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L)};g.Da=function(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U){return this.h.Da?this.h.Da(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U)};\ng.Ea=function(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z){return this.h.Ea?this.h.Ea(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z)};g.Fa=function(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na){return this.h.Fa?this.h.Fa(a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na):this.h.call(null,a,b,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na)};g.Xb=!0;g.F=function(a,b){return new vc(this.h,b)};g.D=function(){return this.j};\nfunction N(a,b){return uc(a)&&!(a?a.i&262144||a.oc||(a.i?0:s(db,a)):s(db,a))?new vc(a,b):null==a?null:eb(a,b)}function xc(a){var b=null!=a;return(b?a?a.i&131072||a.ec||(a.i?0:s(bb,a)):s(bb,a):b)?cb(a):null}function yc(a){return null==a?null:Xa(a)}function zc(a){return null==a?null:Ya(a)}\nvar Ac=function(){function a(a,b){return null==a?null:Wa(a,b)}var b=null,c=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){for(;;){if(null==a)return null;a=b.a(a,d);if(r(e))d=F(e),e=I(e);else return a}}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:return c.d(b,\ne,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Bc(a){return null==a||sa(E(a))}function Cc(a){return null==a?!1:a?a.i&8||a.Ac?!0:a.i?!1:s(Ca,a):s(Ca,a)}function Dc(a){return null==a?!1:a?a.i&4096||a.jc?!0:a.i?!1:s(Va,a):s(Va,a)}function Ec(a){return a?a.i&512||a.yc?!0:a.i?!1:s(Ma,a):s(Ma,a)}function Fc(a){return a?a.i&16777216||a.ic?!0:a.i?!1:s(mb,a):s(mb,a)}\nfunction Gc(a){return null==a?!1:a?a.i&1024||a.cc?!0:a.i?!1:s(Pa,a):s(Pa,a)}function Hc(a){return a?a.i&16384||a.Gc?!0:a.i?!1:s(Za,a):s(Za,a)}function Ic(a){return a?a.q&512||a.zc?!0:!1:!1}function Jc(a){var b=[];da(a,function(a){return function(b,e){return a.push(e)}}(b));return b}function Kc(a,b,c,d,e){for(;0!==e;)c[d]=a[b],d+=1,e-=1,b+=1}var Lc={};function Mc(a){return null==a?!1:a?a.i&64||a.bb?!0:a.i?!1:s(Fa,a):s(Fa,a)}function Nc(a){return r(a)?!0:!1}\nfunction Oc(a,b){return Q.c(a,b,Lc)===Lc?!1:!0}function Xb(a,b){if(a===b)return 0;if(null==a)return-1;if(null==b)return 1;if(ta(a)===ta(b))return a&&(a.q&2048||a.lb)?a.mb(null,b):ga(a,b);if(u)throw Error(\"compare on non-nil objects of different types\");return null}\nvar Pc=function(){function a(a,b,c,h){for(;;){var k=Xb(P.a(a,h),P.a(b,h));if(0===k&&h+1<c)h+=1;else return k}}function b(a,b){var f=O(a),h=O(b);return f<h?-1:f>h?1:u?c.n(a,b,f,0):null}var c=null,c=function(c,e,f,h){switch(arguments.length){case 2:return b.call(this,c,e);case 4:return a.call(this,c,e,f,h)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.n=a;return c}();\nfunction Qc(a){return Wb.a(a,Xb)?Xb:function(b,c){var d=a.a?a.a(b,c):a.call(null,b,c);return\"number\"===typeof d?d:r(d)?-1:r(a.a?a.a(c,b):a.call(null,c,b))?1:0}}\nvar Sc=function(){function a(a,b){if(E(b)){var c=Rc.b?Rc.b(b):Rc.call(null,b);ha(c,Qc(a));return E(c)}return H}function b(a){return c.a(Xb,a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),Tc=function(){function a(a,b,c){return Sc.a(function(c,f){return Qc(b).call(null,a.b?a.b(c):a.call(null,c),a.b?a.b(f):a.call(null,f))},c)}function b(a,b){return c.c(a,Xb,b)}\nvar c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}(),nc=function(){function a(a,b,c){for(c=E(c);;)if(c){b=a.a?a.a(b,F(c)):a.call(null,b,F(c));if(fc(b))return K.b?K.b(b):K.call(null,b);c=I(c)}else return b}function b(a,b){var c=E(b);return c?C.c?C.c(a,F(c),I(c)):C.call(null,a,F(c),I(c)):a.o?a.o():a.call(null)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,\nc,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}(),C=function(){function a(a,b,c){return c&&(c.i&524288||c.Nb)?c.M(null,a,b):c instanceof Array?hc.c(c,a,b):\"string\"===typeof c?hc.c(c,a,b):s(fb,c)?gb.c(c,a,b):u?nc.c(a,b,c):null}function b(a,b){return b&&(b.i&524288||b.Nb)?b.N(null,a):b instanceof Array?hc.a(b,a):\"string\"===typeof b?hc.a(b,a):s(fb,b)?gb.a(b,a):u?nc.a(a,b):null}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,\nc,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}(),Uc=function(){var a=null,b=function(){function a(c,f,h){var k=null;2<arguments.length&&(k=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,f,k)}function b(a,c,d){for(;;)if(a>c)if(I(d))a=c,c=F(d),d=I(d);else return c>F(d);else return!1}a.k=2;a.f=function(a){var c=F(a);a=I(a);var h=F(a);a=G(a);return b(c,h,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;\ncase 2:return a>d;default:return b.d(a,d,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};a.k=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a>b};a.d=b.d;return a}(),Vc=function(){var a=null,b=function(){function a(c,f,h){var k=null;2<arguments.length&&(k=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,f,k)}function b(a,c,d){for(;;)if(a>=c)if(I(d))a=c,c=F(d),d=I(d);else return c>=F(d);else return!1}a.k=2;a.f=function(a){var c=F(a);a=I(a);var h=F(a);\na=G(a);return b(c,h,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 1:return!0;case 2:return a>=d;default:return b.d(a,d,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};a.k=2;a.f=b.f;a.b=function(){return!0};a.a=function(a,b){return a>=b};a.d=b.d;return a}();function Wc(a){return a-1}\nvar Xc=function(){function a(a,b){return a>b?a:b}var b=null,c=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){return C.c(b,a>d?a:d,e)}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);\n};b.k=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}();function Yc(a){a=(a-a%2)/2;return 0<=a?Math.floor.b?Math.floor.b(a):Math.floor.call(null,a):Math.ceil.b?Math.ceil.b(a):Math.ceil.call(null,a)}function Zc(a){a-=a>>1&1431655765;a=(a&858993459)+(a>>2&858993459);return 16843009*(a+(a>>4)&252645135)>>24}function $c(a){var b=1;for(a=E(a);;)if(a&&0<b)b-=1,a=I(a);else return a}\nvar A=function(){function a(a){return null==a?\"\":a.toString()}var b=null,c=function(){function a(b,d){var k=null;1<arguments.length&&(k=J(Array.prototype.slice.call(arguments,1),0));return c.call(this,b,k)}function c(a,d){for(var e=new ea(b.b(a)),l=d;;)if(r(l))e=e.append(b.b(F(l))),l=I(l);else return e.toString()}a.k=1;a.f=function(a){var b=F(a);a=G(a);return c(b,a)};a.d=c;return a}(),b=function(b,e){switch(arguments.length){case 0:return\"\";case 1:return a.call(this,b);default:return c.d(b,J(arguments,\n1))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=1;b.f=c.f;b.o=function(){return\"\"};b.b=a;b.d=c.d;return b}(),ad=function(){var a=null,a=function(a,c,d){switch(arguments.length){case 2:return a.substring(c);case 3:return a.substring(c,d)}throw Error(\"Invalid arity: \"+arguments.length);};a.a=function(a,c){return a.substring(c)};a.c=function(a,c,d){return a.substring(c,d)};return a}();\nfunction lc(a,b){return Nc(Fc(b)?function(){for(var c=E(a),d=E(b);;){if(null==c)return null==d;if(null==d)return!1;if(Wb.a(F(c),F(d)))c=I(c),d=I(d);else return u?!1:null}}():null)}function bd(a,b,c,d,e){this.j=a;this.first=b;this.ta=c;this.count=d;this.m=e;this.i=65937646;this.q=8192}g=bd.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};g.U=function(){return 1===this.count?null:this.ta};g.L=function(){return this.count};g.Ia=function(){return this.first};g.Ja=function(){return Ia(this)};\ng.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return H};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return this.first};g.S=function(){return 1===this.count?H:this.ta};g.H=function(){return this};g.F=function(a,b){return new bd(b,this.first,this.ta,this.count,this.m)};g.G=function(a,b){return new bd(this.j,b,this,this.count+1,null)};\nfunction cd(a){this.j=a;this.i=65937614;this.q=8192}g=cd.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};g.U=function(){return null};g.L=function(){return 0};g.Ia=function(){return null};g.Ja=function(){throw Error(\"Can't pop empty list\");};g.B=function(){return 0};g.v=function(a,b){return lc(this,b)};g.I=function(){return this};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return null};g.S=function(){return H};\ng.H=function(){return null};g.F=function(a,b){return new cd(b)};g.G=function(a,b){return new bd(this.j,b,null,1,null)};var H=new cd(null);function dd(a){return a?a.i&134217728||a.Fc?!0:a.i?!1:s(ob,a):s(ob,a)}function ed(a){return dd(a)?pb(a):C.c(pc,H,a)}\nvar fd=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){var b;if(a instanceof ac&&0===a.p)b=a.e;else a:{for(b=[];;)if(null!=a)b.push(a.Q(null)),a=a.U(null);else break a;b=void 0}a=b.length;for(var e=H;;)if(0<a){var f=a-1,e=e.G(null,b[a-1]);a=f}else return e}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}();function gd(a,b,c,d){this.j=a;this.first=b;this.ta=c;this.m=d;this.i=65929452;this.q=8192}\ng=gd.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};g.U=function(){return null==this.ta?null:E(this.ta)};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.j)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return this.first};g.S=function(){return null==this.ta?H:this.ta};g.H=function(){return this};\ng.F=function(a,b){return new gd(b,this.first,this.ta,this.m)};g.G=function(a,b){return new gd(null,b,this,this.m)};function M(a,b){var c=null==b;return(c?c:b&&(b.i&64||b.bb))?new gd(null,a,b,null):new gd(null,a,E(b),null)}function T(a,b,c,d){this.fa=a;this.name=b;this.sa=c;this.Ua=d;this.i=2153775105;this.q=4096}g=T.prototype;g.w=function(a,b){return ub(b,\":\"+A.b(this.sa))};g.B=function(){var a=this.Ua;return null!=a?a:this.Ua=a=Ub(this)+2654435769};\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return Q.a(c,this);case 3:return Q.c(c,this,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return Q.a(a,this)};g.a=function(a,b){return Q.c(a,this,b)};g.v=function(a,b){return b instanceof T?this.sa===b.sa:!1};g.toString=function(){return\":\"+A.b(this.sa)};\nfunction hd(a,b){return a===b?!0:a instanceof T&&b instanceof T?a.sa===b.sa:!1}\nvar jd=function(){function a(a,b){return new T(a,b,\"\"+A.b(r(a)?\"\"+A.b(a)+\"/\":null)+A.b(b),null)}function b(a){if(a instanceof T)return a;if(a instanceof Zb){var b;if(a&&(a.q&4096||a.fc))b=a.fa;else throw Error(\"Doesn't support namespace: \"+A.b(a));return new T(b,id.b?id.b(a):id.call(null,a),a.Na,null)}return\"string\"===typeof a?(b=a.split(\"/\"),2===b.length?new T(b[0],b[1],a,null):new T(null,b[0],a,null)):null}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,\nc,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}();function V(a,b,c,d){this.j=a;this.Ya=b;this.r=c;this.m=d;this.q=0;this.i=32374988}g=V.prototype;g.toString=function(){return Lb(this)};function kd(a){null!=a.Ya&&(a.r=a.Ya.o?a.Ya.o():a.Ya.call(null),a.Ya=null);return a.r}g.D=function(){return this.j};g.U=function(){lb(this);return null==this.r?null:I(this.r)};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};\ng.I=function(){return N(H,this.j)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){lb(this);return null==this.r?null:F(this.r)};g.S=function(){lb(this);return null!=this.r?G(this.r):H};g.H=function(){kd(this);if(null==this.r)return null;for(var a=this.r;;)if(a instanceof V)a=kd(a);else return this.r=a,E(this.r)};g.F=function(a,b){return new V(b,this.Ya,this.r,this.m)};g.G=function(a,b){return M(b,this)};\nfunction ld(a,b){this.qb=a;this.end=b;this.q=0;this.i=2}ld.prototype.L=function(){return this.end};ld.prototype.add=function(a){this.qb[this.end]=a;return this.end+=1};ld.prototype.da=function(){var a=new md(this.qb,0,this.end);this.qb=null;return a};function md(a,b,c){this.e=a;this.O=b;this.end=c;this.q=0;this.i=524306}g=md.prototype;g.N=function(a,b){return hc.n(this.e,b,this.e[this.O],this.O+1)};g.M=function(a,b,c){return hc.n(this.e,b,c,this.O)};\ng.Kb=function(){if(this.O===this.end)throw Error(\"-drop-first of empty chunk\");return new md(this.e,this.O+1,this.end)};g.J=function(a,b){return this.e[this.O+b]};g.aa=function(a,b,c){return 0<=b&&b<this.end-this.O?this.e[this.O+b]:c};g.L=function(){return this.end-this.O};\nvar nd=function(){function a(a,b,c){return new md(a,b,c)}function b(a,b){return new md(a,b,a.length)}function c(a){return new md(a,0,a.length)}var d=null,d=function(d,f,h){switch(arguments.length){case 1:return c.call(this,d);case 2:return b.call(this,d,f);case 3:return a.call(this,d,f,h)}throw Error(\"Invalid arity: \"+arguments.length);};d.b=c;d.a=b;d.c=a;return d}();function od(a,b,c,d){this.da=a;this.oa=b;this.j=c;this.m=d;this.i=31850732;this.q=1536}g=od.prototype;g.toString=function(){return Lb(this)};\ng.D=function(){return this.j};g.U=function(){if(1<Aa(this.da))return new od(Gb(this.da),this.oa,this.j,null);var a=lb(this.oa);return null==a?null:a};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.j)};g.Q=function(){return D.a(this.da,0)};g.S=function(){return 1<Aa(this.da)?new od(Gb(this.da),this.oa,this.j,null):null==this.oa?H:this.oa};g.H=function(){return this};g.sb=function(){return this.da};\ng.tb=function(){return null==this.oa?H:this.oa};g.F=function(a,b){return new od(this.da,this.oa,b,this.m)};g.G=function(a,b){return M(b,this)};g.rb=function(){return null==this.oa?null:this.oa};function pd(a,b){return 0===Aa(a)?b:new od(a,b,null,null)}function Rc(a){for(var b=[];;)if(E(a))b.push(F(a)),a=I(a);else return b}function qd(a,b){if(ic(a))return O(a);for(var c=a,d=b,e=0;;)if(0<d&&E(c))c=I(c),d-=1,e+=1;else return e}\nvar sd=function rd(b){return null==b?null:null==I(b)?E(F(b)):u?M(F(b),rd(I(b))):null},td=function(){function a(a,b){return new V(null,function(){var c=E(a);return c?Ic(c)?pd(Hb(c),d.a(Ib(c),b)):M(F(c),d.a(G(c),b)):b},null,null)}function b(a){return new V(null,function(){return a},null,null)}function c(){return new V(null,function(){return null},null,null)}var d=null,e=function(){function a(c,d,e){var f=null;2<arguments.length&&(f=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,\nd,f)}function b(a,c,e){return function t(a,b){return new V(null,function(){var c=E(a);return c?Ic(c)?pd(Hb(c),t(Ib(c),b)):M(F(c),t(G(c),b)):r(b)?t(F(b),I(b)):null},null,null)}(d.a(a,c),e)}a.k=2;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=G(a);return b(c,d,a)};a.d=b;return a}(),d=function(d,h,k){switch(arguments.length){case 0:return c.call(this);case 1:return b.call(this,d);case 2:return a.call(this,d,h);default:return e.d(d,h,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};d.k=\n2;d.f=e.f;d.o=c;d.b=b;d.a=a;d.d=e.d;return d}(),ud=function(){function a(a,b,c,d){return M(a,M(b,M(c,d)))}function b(a,b,c){return M(a,M(b,c))}var c=null,d=function(){function a(c,d,e,n,q){var t=null;4<arguments.length&&(t=J(Array.prototype.slice.call(arguments,4),0));return b.call(this,c,d,e,n,t)}function b(a,c,d,e,f){return M(a,M(c,M(d,M(e,sd(f)))))}a.k=4;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=I(a);var e=F(a);a=I(a);var q=F(a);a=G(a);return b(c,d,e,q,a)};a.d=b;return a}(),c=function(c,f,\nh,k,l){switch(arguments.length){case 1:return E(c);case 2:return M(c,f);case 3:return b.call(this,c,f,h);case 4:return a.call(this,c,f,h,k);default:return d.d(c,f,h,k,J(arguments,4))}throw Error(\"Invalid arity: \"+arguments.length);};c.k=4;c.f=d.f;c.b=function(a){return E(a)};c.a=function(a,b){return M(a,b)};c.c=b;c.n=a;c.d=d.d;return c}();function vd(a){return Ab(a)}\nvar wd=function(){var a=null,b=function(){function a(c,f,h){var k=null;2<arguments.length&&(k=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,f,k)}function b(a,c,d){for(;;)if(a=zb(a,c),r(d))c=F(d),d=I(d);else return a}a.k=2;a.f=function(a){var c=F(a);a=I(a);var h=F(a);a=G(a);return b(c,h,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 2:return zb(a,d);default:return b.d(a,d,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};a.k=2;a.f=b.f;a.a=\nfunction(a,b){return zb(a,b)};a.d=b.d;return a}(),xd=function(){var a=null,b=function(){function a(c,f,h,k){var l=null;3<arguments.length&&(l=J(Array.prototype.slice.call(arguments,3),0));return b.call(this,c,f,h,l)}function b(a,c,d,k){for(;;)if(a=Bb(a,c,d),r(k))c=F(k),d=F(I(k)),k=I(I(k));else return a}a.k=3;a.f=function(a){var c=F(a);a=I(a);var h=F(a);a=I(a);var k=F(a);a=G(a);return b(c,h,k,a)};a.d=b;return a}(),a=function(a,d,e,f){switch(arguments.length){case 3:return Bb(a,d,e);default:return b.d(a,\nd,e,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};a.k=3;a.f=b.f;a.c=function(a,b,e){return Bb(a,b,e)};a.d=b.d;return a}(),yd=function(){var a=null,b=function(){function a(c,f,h){var k=null;2<arguments.length&&(k=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,f,k)}function b(a,c,d){for(;;)if(a=Cb(a,c),r(d))c=F(d),d=I(d);else return a}a.k=2;a.f=function(a){var c=F(a);a=I(a);var h=F(a);a=G(a);return b(c,h,a)};a.d=b;return a}(),a=function(a,d,e){switch(arguments.length){case 2:return Cb(a,\nd);default:return b.d(a,d,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};a.k=2;a.f=b.f;a.a=function(a,b){return Cb(a,b)};a.d=b.d;return a}(),zd=function(){var a=null,b=function(){function a(c,f,h){var k=null;2<arguments.length&&(k=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,f,k)}function b(a,c,d){for(;;)if(a=Fb(a,c),r(d))c=F(d),d=I(d);else return a}a.k=2;a.f=function(a){var c=F(a);a=I(a);var h=F(a);a=G(a);return b(c,h,a)};a.d=b;return a}(),a=function(a,d,\ne){switch(arguments.length){case 2:return Fb(a,d);default:return b.d(a,d,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};a.k=2;a.f=b.f;a.a=function(a,b){return Fb(a,b)};a.d=b.d;return a}();\nfunction Ad(a,b,c){var d=E(c);if(0===b)return a.o?a.o():a.call(null);c=Ha(d);var e=Ia(d);if(1===b)return a.b?a.b(c):a.b?a.b(c):a.call(null,c);var d=Ha(e),f=Ia(e);if(2===b)return a.a?a.a(c,d):a.a?a.a(c,d):a.call(null,c,d);var e=Ha(f),h=Ia(f);if(3===b)return a.c?a.c(c,d,e):a.c?a.c(c,d,e):a.call(null,c,d,e);var f=Ha(h),k=Ia(h);if(4===b)return a.n?a.n(c,d,e,f):a.n?a.n(c,d,e,f):a.call(null,c,d,e,f);var h=Ha(k),l=Ia(k);if(5===b)return a.s?a.s(c,d,e,f,h):a.s?a.s(c,d,e,f,h):a.call(null,c,d,e,f,h);var k=Ha(l),\nn=Ia(l);if(6===b)return a.X?a.X(c,d,e,f,h,k):a.X?a.X(c,d,e,f,h,k):a.call(null,c,d,e,f,h,k);var l=Ha(n),q=Ia(n);if(7===b)return a.ga?a.ga(c,d,e,f,h,k,l):a.ga?a.ga(c,d,e,f,h,k,l):a.call(null,c,d,e,f,h,k,l);var n=Ha(q),t=Ia(q);if(8===b)return a.Ga?a.Ga(c,d,e,f,h,k,l,n):a.Ga?a.Ga(c,d,e,f,h,k,l,n):a.call(null,c,d,e,f,h,k,l,n);var q=Ha(t),v=Ia(t);if(9===b)return a.Ha?a.Ha(c,d,e,f,h,k,l,n,q):a.Ha?a.Ha(c,d,e,f,h,k,l,n,q):a.call(null,c,d,e,f,h,k,l,n,q);var t=Ha(v),w=Ia(v);if(10===b)return a.va?a.va(c,d,e,\nf,h,k,l,n,q,t):a.va?a.va(c,d,e,f,h,k,l,n,q,t):a.call(null,c,d,e,f,h,k,l,n,q,t);var v=Ha(w),y=Ia(w);if(11===b)return a.wa?a.wa(c,d,e,f,h,k,l,n,q,t,v):a.wa?a.wa(c,d,e,f,h,k,l,n,q,t,v):a.call(null,c,d,e,f,h,k,l,n,q,t,v);var w=Ha(y),B=Ia(y);if(12===b)return a.xa?a.xa(c,d,e,f,h,k,l,n,q,t,v,w):a.xa?a.xa(c,d,e,f,h,k,l,n,q,t,v,w):a.call(null,c,d,e,f,h,k,l,n,q,t,v,w);var y=Ha(B),L=Ia(B);if(13===b)return a.ya?a.ya(c,d,e,f,h,k,l,n,q,t,v,w,y):a.ya?a.ya(c,d,e,f,h,k,l,n,q,t,v,w,y):a.call(null,c,d,e,f,h,k,l,n,q,\nt,v,w,y);var B=Ha(L),U=Ia(L);if(14===b)return a.za?a.za(c,d,e,f,h,k,l,n,q,t,v,w,y,B):a.za?a.za(c,d,e,f,h,k,l,n,q,t,v,w,y,B):a.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B);var L=Ha(U),Z=Ia(U);if(15===b)return a.Aa?a.Aa(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L):a.Aa?a.Aa(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L):a.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L);var U=Ha(Z),na=Ia(Z);if(16===b)return a.Ba?a.Ba(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U):a.Ba?a.Ba(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U):a.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U);var Z=\nHa(na),Ga=Ia(na);if(17===b)return a.Ca?a.Ca(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z):a.Ca?a.Ca(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z):a.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z);var na=Ha(Ga),Ra=Ia(Ga);if(18===b)return a.Da?a.Da(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na):a.Da?a.Da(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na):a.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na);Ga=Ha(Ra);Ra=Ia(Ra);if(19===b)return a.Ea?a.Ea(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga):a.Ea?a.Ea(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga):a.call(null,\nc,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga);var wc=Ha(Ra);Ia(Ra);if(20===b)return a.Fa?a.Fa(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,wc):a.Fa?a.Fa(c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,wc):a.call(null,c,d,e,f,h,k,l,n,q,t,v,w,y,B,L,U,Z,na,Ga,wc);throw Error(\"Only up to 20 arguments supported on functions\");}\nvar S=function(){function a(a,b,c,d,e){b=ud.n(b,c,d,e);c=a.k;return a.f?(d=qd(b,c+1),d<=c?Ad(a,d,b):a.f(b)):a.apply(a,Rc(b))}function b(a,b,c,d){b=ud.c(b,c,d);c=a.k;return a.f?(d=qd(b,c+1),d<=c?Ad(a,d,b):a.f(b)):a.apply(a,Rc(b))}function c(a,b,c){b=ud.a(b,c);c=a.k;if(a.f){var d=qd(b,c+1);return d<=c?Ad(a,d,b):a.f(b)}return a.apply(a,Rc(b))}function d(a,b){var c=a.k;if(a.f){var d=qd(b,c+1);return d<=c?Ad(a,d,b):a.f(b)}return a.apply(a,Rc(b))}var e=null,f=function(){function a(c,d,e,f,h,w){var y=null;\n5<arguments.length&&(y=J(Array.prototype.slice.call(arguments,5),0));return b.call(this,c,d,e,f,h,y)}function b(a,c,d,e,f,h){c=M(c,M(d,M(e,M(f,sd(h)))));d=a.k;return a.f?(e=qd(c,d+1),e<=d?Ad(a,e,c):a.f(c)):a.apply(a,Rc(c))}a.k=5;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=I(a);var e=F(a);a=I(a);var f=F(a);a=I(a);var h=F(a);a=G(a);return b(c,d,e,f,h,a)};a.d=b;return a}(),e=function(e,k,l,n,q,t){switch(arguments.length){case 2:return d.call(this,e,k);case 3:return c.call(this,e,k,l);case 4:return b.call(this,\ne,k,l,n);case 5:return a.call(this,e,k,l,n,q);default:return f.d(e,k,l,n,q,J(arguments,5))}throw Error(\"Invalid arity: \"+arguments.length);};e.k=5;e.f=f.f;e.a=d;e.c=c;e.n=b;e.s=a;e.d=f.d;return e}(),Bd=function(){function a(a,b){return!Wb.a(a,b)}var b=null,c=function(){function a(c,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,d,l)}function b(a,c,d){return sa(S.n(Wb,a,c,d))}a.k=2;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=G(a);return b(c,\nd,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return!1;case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.b=function(){return!1};b.a=a;b.d=c.d;return b}();function Cd(a){return E(a)?a:null}function Dd(a,b){for(;;){if(null==E(b))return!0;if(r(a.b?a.b(F(b)):a.call(null,F(b)))){var c=a,d=I(b);a=c;b=d}else return u?!1:null}}\nfunction Ed(a,b){for(;;)if(E(b)){var c=a.b?a.b(F(b)):a.call(null,F(b));if(r(c))return c;var c=a,d=I(b);a=c;b=d}else return null}function Fd(a){return a}\nfunction Gd(a){return function(){var b=null,c=function(){function b(a,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,a,d,l)}function c(b,d,e){return sa(S.n(a,b,d,e))}b.k=2;b.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};b.d=c;return b}(),b=function(b,e,f){switch(arguments.length){case 0:return sa(a.o?a.o():a.call(null));case 1:var h=b;return sa(a.b?a.b(h):a.call(null,h));case 2:var h=b,k=e;return sa(a.a?a.a(h,k):a.call(null,\nh,k));default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;return b}()}\nvar Hd=function(){function a(a,b,c){return function(){var d=null,l=function(){function d(a,b,c,e){var f=null;3<arguments.length&&(f=J(Array.prototype.slice.call(arguments,3),0));return k.call(this,a,b,c,f)}function k(d,l,n,q){return a.b?a.b(b.b?b.b(S.s(c,d,l,n,q)):b.call(null,S.s(c,d,l,n,q))):a.call(null,b.b?b.b(S.s(c,d,l,n,q)):b.call(null,S.s(c,d,l,n,q)))}d.k=3;d.f=function(a){var b=F(a);a=I(a);var c=F(a);a=I(a);var d=F(a);a=G(a);return k(b,c,d,a)};d.d=k;return d}(),d=function(d,k,t,v){switch(arguments.length){case 0:return a.b?\na.b(b.b?b.b(c.o?c.o():c.call(null)):b.call(null,c.o?c.o():c.call(null))):a.call(null,b.b?b.b(c.o?c.o():c.call(null)):b.call(null,c.o?c.o():c.call(null)));case 1:var w=d;return a.b?a.b(b.b?b.b(c.b?c.b(w):c.call(null,w)):b.call(null,c.b?c.b(w):c.call(null,w))):a.call(null,b.b?b.b(c.b?c.b(w):c.call(null,w)):b.call(null,c.b?c.b(w):c.call(null,w)));case 2:var w=d,y=k;return a.b?a.b(b.b?b.b(c.a?c.a(w,y):c.call(null,w,y)):b.call(null,c.a?c.a(w,y):c.call(null,w,y))):a.call(null,b.b?b.b(c.a?c.a(w,y):c.call(null,\nw,y)):b.call(null,c.a?c.a(w,y):c.call(null,w,y)));case 3:var w=d,y=k,B=t;return a.b?a.b(b.b?b.b(c.c?c.c(w,y,B):c.call(null,w,y,B)):b.call(null,c.c?c.c(w,y,B):c.call(null,w,y,B))):a.call(null,b.b?b.b(c.c?c.c(w,y,B):c.call(null,w,y,B)):b.call(null,c.c?c.c(w,y,B):c.call(null,w,y,B)));default:return l.d(d,k,t,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};d.k=3;d.f=l.f;return d}()}function b(a,b){return function(){var c=null,d=function(){function c(a,b,e,f){var h=null;3<arguments.length&&\n(h=J(Array.prototype.slice.call(arguments,3),0));return d.call(this,a,b,e,h)}function d(c,h,k,l){return a.b?a.b(S.s(b,c,h,k,l)):a.call(null,S.s(b,c,h,k,l))}c.k=3;c.f=function(a){var b=F(a);a=I(a);var c=F(a);a=I(a);var e=F(a);a=G(a);return d(b,c,e,a)};c.d=d;return c}(),c=function(c,h,q,t){switch(arguments.length){case 0:return a.b?a.b(b.o?b.o():b.call(null)):a.call(null,b.o?b.o():b.call(null));case 1:var v=c;return a.b?a.b(b.b?b.b(v):b.call(null,v)):a.call(null,b.b?b.b(v):b.call(null,v));case 2:var v=\nc,w=h;return a.b?a.b(b.a?b.a(v,w):b.call(null,v,w)):a.call(null,b.a?b.a(v,w):b.call(null,v,w));case 3:var v=c,w=h,y=q;return a.b?a.b(b.c?b.c(v,w,y):b.call(null,v,w,y)):a.call(null,b.c?b.c(v,w,y):b.call(null,v,w,y));default:return d.d(c,h,q,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};c.k=3;c.f=d.f;return c}()}var c=null,d=function(){function a(c,d,e,n){var q=null;3<arguments.length&&(q=J(Array.prototype.slice.call(arguments,3),0));return b.call(this,c,d,e,q)}function b(a,c,d,\ne){return function(a){return function(){function b(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return c.call(this,d)}function c(b){b=S.a(F(a),b);for(var d=I(a);;)if(d)b=F(d).call(null,b),d=I(d);else return b}b.k=0;b.f=function(a){a=E(a);return c(a)};b.d=c;return b}()}(ed(ud.n(a,c,d,e)))}a.k=3;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=I(a);var e=F(a);a=G(a);return b(c,d,e,a)};a.d=b;return a}(),c=function(c,f,h,k){switch(arguments.length){case 0:return Fd;\ncase 1:return c;case 2:return b.call(this,c,f);case 3:return a.call(this,c,f,h);default:return d.d(c,f,h,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};c.k=3;c.f=d.f;c.o=function(){return Fd};c.b=function(a){return a};c.a=b;c.c=a;c.d=d.d;return c}(),Id=function(){function a(a,b,c,d){return function(){function e(a){var b=null;0<arguments.length&&(b=J(Array.prototype.slice.call(arguments,0),0));return q.call(this,b)}function q(e){return S.s(a,b,c,d,e)}e.k=0;e.f=function(a){a=E(a);\nreturn q(a)};e.d=q;return e}()}function b(a,b,c){return function(){function d(a){var b=null;0<arguments.length&&(b=J(Array.prototype.slice.call(arguments,0),0));return e.call(this,b)}function e(d){return S.n(a,b,c,d)}d.k=0;d.f=function(a){a=E(a);return e(a)};d.d=e;return d}()}function c(a,b){return function(){function c(a){var b=null;0<arguments.length&&(b=J(Array.prototype.slice.call(arguments,0),0));return d.call(this,b)}function d(c){return S.c(a,b,c)}c.k=0;c.f=function(a){a=E(a);return d(a)};\nc.d=d;return c}()}var d=null,e=function(){function a(c,d,e,f,t){var v=null;4<arguments.length&&(v=J(Array.prototype.slice.call(arguments,4),0));return b.call(this,c,d,e,f,v)}function b(a,c,d,e,f){return function(){function b(a){var c=null;0<arguments.length&&(c=J(Array.prototype.slice.call(arguments,0),0));return h.call(this,c)}function h(b){return S.s(a,c,d,e,td.a(f,b))}b.k=0;b.f=function(a){a=E(a);return h(a)};b.d=h;return b}()}a.k=4;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=I(a);var e=F(a);\na=I(a);var f=F(a);a=G(a);return b(c,d,e,f,a)};a.d=b;return a}(),d=function(d,h,k,l,n){switch(arguments.length){case 1:return d;case 2:return c.call(this,d,h);case 3:return b.call(this,d,h,k);case 4:return a.call(this,d,h,k,l);default:return e.d(d,h,k,l,J(arguments,4))}throw Error(\"Invalid arity: \"+arguments.length);};d.k=4;d.f=e.f;d.b=function(a){return a};d.a=c;d.c=b;d.n=a;d.d=e.d;return d}(),Jd=function(){function a(a,b,c,d){return function(){var l=null,n=function(){function l(a,b,c,d){var e=null;\n3<arguments.length&&(e=J(Array.prototype.slice.call(arguments,3),0));return n.call(this,a,b,c,e)}function n(l,q,t,B){return S.s(a,null==l?b:l,null==q?c:q,null==t?d:t,B)}l.k=3;l.f=function(a){var b=F(a);a=I(a);var c=F(a);a=I(a);var d=F(a);a=G(a);return n(b,c,d,a)};l.d=n;return l}(),l=function(l,t,v,w){switch(arguments.length){case 2:var y=l,B=t;return a.a?a.a(null==y?b:y,null==B?c:B):a.call(null,null==y?b:y,null==B?c:B);case 3:var y=l,B=t,L=v;return a.c?a.c(null==y?b:y,null==B?c:B,null==L?d:L):a.call(null,\nnull==y?b:y,null==B?c:B,null==L?d:L);default:return n.d(l,t,v,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};l.k=3;l.f=n.f;return l}()}function b(a,b,c){return function(){var d=null,l=function(){function d(a,b,c,e){var f=null;3<arguments.length&&(f=J(Array.prototype.slice.call(arguments,3),0));return k.call(this,a,b,c,f)}function k(d,l,n,q){return S.s(a,null==d?b:d,null==l?c:l,n,q)}d.k=3;d.f=function(a){var b=F(a);a=I(a);var c=F(a);a=I(a);var d=F(a);a=G(a);return k(b,c,d,a)};d.d=\nk;return d}(),d=function(d,k,t,v){switch(arguments.length){case 2:var w=d,y=k;return a.a?a.a(null==w?b:w,null==y?c:y):a.call(null,null==w?b:w,null==y?c:y);case 3:var w=d,y=k,B=t;return a.c?a.c(null==w?b:w,null==y?c:y,B):a.call(null,null==w?b:w,null==y?c:y,B);default:return l.d(d,k,t,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};d.k=3;d.f=l.f;return d}()}function c(a,b){return function(){var c=null,d=function(){function c(a,b,e,f){var h=null;3<arguments.length&&(h=J(Array.prototype.slice.call(arguments,\n3),0));return d.call(this,a,b,e,h)}function d(c,h,k,l){return S.s(a,null==c?b:c,h,k,l)}c.k=3;c.f=function(a){var b=F(a);a=I(a);var c=F(a);a=I(a);var e=F(a);a=G(a);return d(b,c,e,a)};c.d=d;return c}(),c=function(c,h,q,t){switch(arguments.length){case 1:var v=c;return a.b?a.b(null==v?b:v):a.call(null,null==v?b:v);case 2:var v=c,w=h;return a.a?a.a(null==v?b:v,w):a.call(null,null==v?b:v,w);case 3:var v=c,w=h,y=q;return a.c?a.c(null==v?b:v,w,y):a.call(null,null==v?b:v,w,y);default:return d.d(c,h,q,J(arguments,\n3))}throw Error(\"Invalid arity: \"+arguments.length);};c.k=3;c.f=d.f;return c}()}var d=null,d=function(d,f,h,k){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,h);case 4:return a.call(this,d,f,h,k)}throw Error(\"Invalid arity: \"+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),Kd=function(){function a(a,b,c,e){return new V(null,function(){var n=E(b),q=E(c),t=E(e);return n&&q&&t?M(a.c?a.c(F(n),F(q),F(t)):a.call(null,F(n),F(q),F(t)),d.n(a,G(n),G(q),G(t))):null},\nnull,null)}function b(a,b,c){return new V(null,function(){var e=E(b),n=E(c);return e&&n?M(a.a?a.a(F(e),F(n)):a.call(null,F(e),F(n)),d.c(a,G(e),G(n))):null},null,null)}function c(a,b){return new V(null,function(){var c=E(b);if(c){if(Ic(c)){for(var e=Hb(c),n=O(e),q=new ld(Array(n),0),t=0;;)if(t<n){var v=a.b?a.b(D.a(e,t)):a.call(null,D.a(e,t));q.add(v);t+=1}else break;return pd(q.da(),d.a(a,Ib(c)))}return M(a.b?a.b(F(c)):a.call(null,F(c)),d.a(a,G(c)))}return null},null,null)}var d=null,e=function(){function a(c,\nd,e,f,t){var v=null;4<arguments.length&&(v=J(Array.prototype.slice.call(arguments,4),0));return b.call(this,c,d,e,f,v)}function b(a,c,e,f,h){var v=function y(a){return new V(null,function(){var b=d.a(E,a);return Dd(Fd,b)?M(d.a(F,b),y(d.a(G,b))):null},null,null)};return d.a(function(){return function(b){return S.a(a,b)}}(v),v(pc.d(h,f,J([e,c],0))))}a.k=4;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=I(a);var e=F(a);a=I(a);var f=F(a);a=G(a);return b(c,d,e,f,a)};a.d=b;return a}(),d=function(d,h,k,l,\nn){switch(arguments.length){case 2:return c.call(this,d,h);case 3:return b.call(this,d,h,k);case 4:return a.call(this,d,h,k,l);default:return e.d(d,h,k,l,J(arguments,4))}throw Error(\"Invalid arity: \"+arguments.length);};d.k=4;d.f=e.f;d.a=c;d.c=b;d.n=a;d.d=e.d;return d}(),Md=function Ld(b,c){return new V(null,function(){if(0<b){var d=E(c);return d?M(F(d),Ld(b-1,G(d))):null}return null},null,null)};\nfunction Nd(a,b){return new V(null,function(c){return function(){return c(a,b)}}(function(a,b){for(;;){var e=E(b);if(0<a&&e){var f=a-1,e=G(e);a=f;b=e}else return e}}),null,null)}\nvar Od=function(){function a(a,b){return Md(a,c.b(b))}function b(a){return new V(null,function(){return M(a,c.b(a))},null,null)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),Pd=function(){function a(a,b){return Md(a,c.b(b))}function b(a){return new V(null,function(){return M(a.o?a.o():a.call(null),c.b(a))},null,null)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,\nc);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),Qd=function(){function a(a,c){return new V(null,function(){var f=E(a),h=E(c);return f&&h?M(F(f),M(F(h),b.a(G(f),G(h)))):null},null,null)}var b=null,c=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){return new V(null,function(){var c=Kd.a(E,pc.d(e,d,J([a],0)));return Dd(Fd,c)?td.a(Kd.a(F,\nc),S.a(b,Kd.a(G,c))):null},null,null)}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.a=a;b.d=c.d;return b}();function Rd(a){return function c(a,e){return new V(null,function(){var f=E(a);return f?M(F(f),c(G(f),e)):E(e)?c(F(e),G(e)):null},null,null)}(null,a)}\nvar Sd=function(){function a(a,b){return Rd(Kd.a(a,b))}var b=null,c=function(){function a(c,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,d,l)}function b(a,c,d){return Rd(S.n(Kd,a,c,d))}a.k=2;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=G(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};\nb.k=2;b.f=c.f;b.a=a;b.d=c.d;return b}(),Ud=function Td(b,c){return new V(null,function(){var d=E(c);if(d){if(Ic(d)){for(var e=Hb(d),f=O(e),h=new ld(Array(f),0),k=0;;)if(k<f){if(r(b.b?b.b(D.a(e,k)):b.call(null,D.a(e,k)))){var l=D.a(e,k);h.add(l)}k+=1}else break;return pd(h.da(),Td(b,Ib(d)))}e=F(d);d=G(d);return r(b.b?b.b(e):b.call(null,e))?M(e,Td(b,d)):Td(b,d)}return null},null,null)};function Vd(a,b){return Ud(Gd(a),b)}\nfunction Wd(a){var b=Xd;return function d(a){return new V(null,function(){return M(a,r(b.b?b.b(a):b.call(null,a))?Sd.a(d,E.b?E.b(a):E.call(null,a)):null)},null,null)}(a)}function Yd(a,b){return null!=a?a&&(a.q&4||a.Bc)?vd(C.c(zb,yb(a),b)):C.c(Da,a,b):C.c(pc,H,b)}\nvar Zd=function(){function a(a,b,c,k){return new V(null,function(){var l=E(k);if(l){var n=Md(a,l);return a===O(n)?M(n,d.n(a,b,c,Nd(b,l))):Da(H,Md(a,td.a(n,c)))}return null},null,null)}function b(a,b,c){return new V(null,function(){var k=E(c);if(k){var l=Md(a,k);return a===O(l)?M(l,d.c(a,b,Nd(b,k))):null}return null},null,null)}function c(a,b){return d.c(a,a,b)}var d=null,d=function(d,f,h,k){switch(arguments.length){case 2:return c.call(this,d,f);case 3:return b.call(this,d,f,h);case 4:return a.call(this,\nd,f,h,k)}throw Error(\"Invalid arity: \"+arguments.length);};d.a=c;d.c=b;d.n=a;return d}(),$d=function(){function a(a,b,c){var h=Lc;for(b=E(b);;)if(b){var k=a;if(k?k.i&256||k.Mb||(k.i?0:s(Ka,k)):s(Ka,k)){a=Q.c(a,F(b),h);if(h===a)return c;b=I(b)}else return c}else return a}function b(a,b){return c.c(a,b,null)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}(),ae=\nfunction(){function a(a,b,c,d,f,t){var v=P.c(b,0,null);return(b=$c(b))?R.c(a,v,e.X(Q.a(a,v),b,c,d,f,t)):R.c(a,v,c.n?c.n(Q.a(a,v),d,f,t):c.call(null,Q.a(a,v),d,f,t))}function b(a,b,c,d,f){var t=P.c(b,0,null);return(b=$c(b))?R.c(a,t,e.s(Q.a(a,t),b,c,d,f)):R.c(a,t,c.c?c.c(Q.a(a,t),d,f):c.call(null,Q.a(a,t),d,f))}function c(a,b,c,d){var f=P.c(b,0,null);return(b=$c(b))?R.c(a,f,e.n(Q.a(a,f),b,c,d)):R.c(a,f,c.a?c.a(Q.a(a,f),d):c.call(null,Q.a(a,f),d))}function d(a,b,c){var d=P.c(b,0,null);return(b=$c(b))?\nR.c(a,d,e.c(Q.a(a,d),b,c)):R.c(a,d,c.b?c.b(Q.a(a,d)):c.call(null,Q.a(a,d)))}var e=null,f=function(){function a(c,d,e,f,h,w,y){var B=null;6<arguments.length&&(B=J(Array.prototype.slice.call(arguments,6),0));return b.call(this,c,d,e,f,h,w,B)}function b(a,c,d,f,h,k,y){var B=P.c(c,0,null);return(c=$c(c))?R.c(a,B,S.d(e,Q.a(a,B),c,d,f,J([h,k,y],0))):R.c(a,B,S.d(d,Q.a(a,B),f,h,k,J([y],0)))}a.k=6;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=I(a);var e=F(a);a=I(a);var f=F(a);a=I(a);var h=F(a);a=I(a);var y=\nF(a);a=G(a);return b(c,d,e,f,h,y,a)};a.d=b;return a}(),e=function(e,k,l,n,q,t,v){switch(arguments.length){case 3:return d.call(this,e,k,l);case 4:return c.call(this,e,k,l,n);case 5:return b.call(this,e,k,l,n,q);case 6:return a.call(this,e,k,l,n,q,t);default:return f.d(e,k,l,n,q,t,J(arguments,6))}throw Error(\"Invalid arity: \"+arguments.length);};e.k=6;e.f=f.f;e.c=d;e.n=c;e.s=b;e.X=a;e.d=f.d;return e}();function be(a,b){this.t=a;this.e=b}\nfunction ce(a){return new be(a,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null])}function de(a){return new be(a.t,va(a.e))}function ee(a){a=a.g;return 32>a?0:a-1>>>5<<5}function fe(a,b,c){for(;;){if(0===b)return c;var d=ce(a);d.e[0]=c;c=d;b-=5}}var he=function ge(b,c,d,e){var f=de(d),h=b.g-1>>>c&31;5===c?f.e[h]=e:(d=d.e[h],b=null!=d?ge(b,c-5,d,e):fe(null,c-5,e),f.e[h]=b);return f};\nfunction ie(a,b){throw Error(\"No item \"+A.b(a)+\" in vector of length \"+A.b(b));}function je(a){var b=a.root;for(a=a.shift;;)if(0<a)a-=5,b=b.e[0];else return b.e}function ke(a,b){if(b>=ee(a))return a.R;for(var c=a.root,d=a.shift;;)if(0<d)var e=d-5,c=c.e[b>>>d&31],d=e;else return c.e}function le(a,b){return 0<=b&&b<a.g?ke(a,b):ie(b,a.g)}\nvar ne=function me(b,c,d,e,f){var h=de(d);if(0===c)h.e[e&31]=f;else{var k=e>>>c&31;b=me(b,c-5,d.e[k],e,f);h.e[k]=b}return h},pe=function oe(b,c,d){var e=b.g-2>>>c&31;if(5<c){b=oe(b,c-5,d.e[e]);if(null==b&&0===e)return null;d=de(d);d.e[e]=b;return d}return 0===e?null:u?(d=de(d),d.e[e]=null,d):null};function W(a,b,c,d,e,f){this.j=a;this.g=b;this.shift=c;this.root=d;this.R=e;this.m=f;this.i=167668511;this.q=8196}g=W.prototype;g.toString=function(){return Lb(this)};\ng.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){return\"number\"===typeof b?D.c(this,b,c):c};g.Za=function(a,b,c){a=[0,c];for(c=0;;)if(c<this.g){var d=ke(this,c),e=d.length;a:{for(var f=0,h=a[1];;)if(f<e){h=b.c?b.c(h,f+c,d[f]):b.call(null,h,f+c,d[f]);if(fc(h)){d=h;break a}f+=1}else{a[0]=e;d=a[1]=h;break a}d=void 0}if(fc(d))return K.b?K.b(d):K.call(null,d);c+=a[0]}else return a[1]};g.J=function(a,b){return le(this,b)[b&31]};\ng.aa=function(a,b,c){return 0<=b&&b<this.g?ke(this,b)[b&31]:c};g.Pa=function(a,b,c){if(0<=b&&b<this.g)return ee(this)<=b?(a=va(this.R),a[b&31]=c,new W(this.j,this.g,this.shift,this.root,a,null)):new W(this.j,this.g,this.shift,ne(this,this.shift,this.root,b,c),this.R,null);if(b===this.g)return Da(this,c);if(u)throw Error(\"Index \"+A.b(b)+\" out of bounds  [0,\"+A.b(this.g)+\"]\");return null};g.D=function(){return this.j};g.L=function(){return this.g};g.$a=function(){return D.a(this,0)};\ng.ab=function(){return D.a(this,1)};g.Ia=function(){return 0<this.g?D.a(this,this.g-1):null};g.Ja=function(){if(0===this.g)throw Error(\"Can't pop empty vector\");if(1===this.g)return eb(qe,this.j);if(1<this.g-ee(this))return new W(this.j,this.g-1,this.shift,this.root,this.R.slice(0,-1),null);if(u){var a=ke(this,this.g-2),b=pe(this,this.shift,this.root),b=null==b?X:b,c=this.g-1;return 5<this.shift&&null==b.e[1]?new W(this.j,c,this.shift-5,b.e[0],a,null):new W(this.j,c,this.shift,b,a,null)}return null};\ng.Xa=function(){return 0<this.g?new kc(this,this.g-1,null):null};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.Wa=function(){return new re(this.g,this.shift,se.b?se.b(this.root):se.call(null,this.root),te.b?te.b(this.R):te.call(null,this.R))};g.I=function(){return N(qe,this.j)};g.N=function(a,b){return gc.a(this,b)};g.M=function(a,b,c){return gc.c(this,b,c)};\ng.ua=function(a,b,c){if(\"number\"===typeof b)return $a(this,b,c);throw Error(\"Vector's key for assoc must be a number.\");};g.H=function(){return 0===this.g?null:32>=this.g?new ac(this.R,0):u?ue.n?ue.n(this,je(this),0,0):ue.call(null,this,je(this),0,0):null};g.F=function(a,b){return new W(b,this.g,this.shift,this.root,this.R,this.m)};\ng.G=function(a,b){if(32>this.g-ee(this)){for(var c=this.R.length,d=Array(c+1),e=0;;)if(e<c)d[e]=this.R[e],e+=1;else break;d[c]=b;return new W(this.j,this.g+1,this.shift,this.root,d,null)}c=(d=this.g>>>5>1<<this.shift)?this.shift+5:this.shift;d?(d=ce(null),d.e[0]=this.root,e=fe(null,this.shift,new be(null,this.R)),d.e[1]=e):d=he(this,this.shift,this.root,new be(null,this.R));return new W(this.j,this.g+1,c,d,[b],null)};\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.J(null,c);case 3:return this.aa(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.J(null,a)};g.a=function(a,b){return this.aa(null,a,b)};\nvar X=new be(null,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]),qe=new W(null,0,5,X,[],0);function ve(a,b){var c=a.length,d=b?a:va(a);if(32>c)return new W(null,c,5,X,d,null);for(var e=32,f=(new W(null,32,5,X,d.slice(0,32),null)).Wa(null);;)if(e<c)var h=e+1,f=wd.a(f,d[e]),e=h;else return Ab(f)}function we(a){return Ab(C.c(zb,yb(qe),a))}\nvar xe=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return a instanceof ac&&0===a.p?ve.a?ve.a(a.e,!0):ve.call(null,a.e,!0):we(a)}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}();function ye(a,b,c,d,e,f){this.P=a;this.ea=b;this.p=c;this.O=d;this.j=e;this.m=f;this.i=32243948;this.q=1536}g=ye.prototype;g.toString=function(){return Lb(this)};\ng.U=function(){if(this.O+1<this.ea.length){var a=ue.n?ue.n(this.P,this.ea,this.p,this.O+1):ue.call(null,this.P,this.ea,this.p,this.O+1);return null==a?null:a}return Jb(this)};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(qe,this.j)};g.N=function(a,b){return gc.a(ze.c?ze.c(this.P,this.p+this.O,O(this.P)):ze.call(null,this.P,this.p+this.O,O(this.P)),b)};\ng.M=function(a,b,c){return gc.c(ze.c?ze.c(this.P,this.p+this.O,O(this.P)):ze.call(null,this.P,this.p+this.O,O(this.P)),b,c)};g.Q=function(){return this.ea[this.O]};g.S=function(){if(this.O+1<this.ea.length){var a=ue.n?ue.n(this.P,this.ea,this.p,this.O+1):ue.call(null,this.P,this.ea,this.p,this.O+1);return null==a?H:a}return Ib(this)};g.H=function(){return this};g.sb=function(){return nd.a(this.ea,this.O)};\ng.tb=function(){var a=this.p+this.ea.length;return a<Aa(this.P)?ue.n?ue.n(this.P,ke(this.P,a),a,0):ue.call(null,this.P,ke(this.P,a),a,0):H};g.F=function(a,b){return ue.s?ue.s(this.P,this.ea,this.p,this.O,b):ue.call(null,this.P,this.ea,this.p,this.O,b)};g.G=function(a,b){return M(b,this)};g.rb=function(){var a=this.p+this.ea.length;return a<Aa(this.P)?ue.n?ue.n(this.P,ke(this.P,a),a,0):ue.call(null,this.P,ke(this.P,a),a,0):null};\nvar ue=function(){function a(a,b,c,d,l){return new ye(a,b,c,d,l,null)}function b(a,b,c,d){return new ye(a,b,c,d,null,null)}function c(a,b,c){return new ye(a,le(a,b),b,c,null,null)}var d=null,d=function(d,f,h,k,l){switch(arguments.length){case 3:return c.call(this,d,f,h);case 4:return b.call(this,d,f,h,k);case 5:return a.call(this,d,f,h,k,l)}throw Error(\"Invalid arity: \"+arguments.length);};d.c=c;d.n=b;d.s=a;return d}();\nfunction Ae(a,b,c,d,e){this.j=a;this.ca=b;this.start=c;this.end=d;this.m=e;this.i=166617887;this.q=8192}g=Ae.prototype;g.toString=function(){return Lb(this)};g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){return\"number\"===typeof b?D.c(this,b,c):c};g.J=function(a,b){return 0>b||this.end<=this.start+b?ie(b,this.end-this.start):D.a(this.ca,this.start+b)};g.aa=function(a,b,c){return 0>b||this.end<=this.start+b?c:D.c(this.ca,this.start+b,c)};\ng.Pa=function(a,b,c){var d=this,e=d.start+b;return Be.s?Be.s(d.j,R.c(d.ca,e,c),d.start,function(){var a=d.end,b=e+1;return a>b?a:b}(),null):Be.call(null,d.j,R.c(d.ca,e,c),d.start,function(){var a=d.end,b=e+1;return a>b?a:b}(),null)};g.D=function(){return this.j};g.L=function(){return this.end-this.start};g.Ia=function(){return D.a(this.ca,this.end-1)};\ng.Ja=function(){if(this.start===this.end)throw Error(\"Can't pop empty vector\");return Be.s?Be.s(this.j,this.ca,this.start,this.end-1,null):Be.call(null,this.j,this.ca,this.start,this.end-1,null)};g.Xa=function(){return this.start!==this.end?new kc(this,this.end-this.start-1,null):null};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(qe,this.j)};g.N=function(a,b){return gc.a(this,b)};\ng.M=function(a,b,c){return gc.c(this,b,c)};g.ua=function(a,b,c){if(\"number\"===typeof b)return $a(this,b,c);throw Error(\"Subvec's key for assoc must be a number.\");};g.H=function(){var a=this;return function(b){return function d(e){return e===a.end?null:M(D.a(a.ca,e),new V(null,function(){return function(){return d(e+1)}}(b),null,null))}}(this)(a.start)};g.F=function(a,b){return Be.s?Be.s(b,this.ca,this.start,this.end,this.m):Be.call(null,b,this.ca,this.start,this.end,this.m)};\ng.G=function(a,b){return Be.s?Be.s(this.j,$a(this.ca,this.end,b),this.start,this.end+1,null):Be.call(null,this.j,$a(this.ca,this.end,b),this.start,this.end+1,null)};g.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.J(null,c);case 3:return this.aa(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.J(null,a)};\ng.a=function(a,b){return this.aa(null,a,b)};function Be(a,b,c,d,e){for(;;)if(b instanceof Ae)c=b.start+c,d=b.start+d,b=b.ca;else{var f=O(b);if(0>c||0>d||c>f||d>f)throw Error(\"Index out of bounds\");return new Ae(a,b,c,d,e)}}\nvar ze=function(){function a(a,b,c){return Be(null,a,b,c,null)}function b(a,b){return c.c(a,b,O(a))}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}();function Ce(a,b){return a===b.t?b:new be(a,va(b.e))}function se(a){return new be({},va(a.e))}\nfunction te(a){var b=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];Kc(a,0,b,0,a.length);return b}\nvar Ee=function De(b,c,d,e){d=Ce(b.root.t,d);var f=b.g-1>>>c&31;if(5===c)b=e;else{var h=d.e[f];b=null!=h?De(b,c-5,h,e):fe(b.root.t,c-5,e)}d.e[f]=b;return d},Ge=function Fe(b,c,d){d=Ce(b.root.t,d);var e=b.g-2>>>c&31;if(5<c){b=Fe(b,c-5,d.e[e]);if(null==b&&0===e)return null;d.e[e]=b;return d}return 0===e?null:u?(d.e[e]=null,d):null};function re(a,b,c,d){this.g=a;this.shift=b;this.root=c;this.R=d;this.i=275;this.q=88}g=re.prototype;\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){return\"number\"===typeof b?D.c(this,b,c):c};\ng.J=function(a,b){if(this.root.t)return le(this,b)[b&31];throw Error(\"nth after persistent!\");};g.aa=function(a,b,c){return 0<=b&&b<this.g?D.a(this,b):c};g.L=function(){if(this.root.t)return this.g;throw Error(\"count after persistent!\");};\ng.Pb=function(a,b,c){var d=this;if(d.root.t){if(0<=b&&b<d.g)return ee(this)<=b?d.R[b&31]=c:(a=function(){return function f(a,k){var l=Ce(d.root.t,k);if(0===a)l.e[b&31]=c;else{var n=b>>>a&31,q=f(a-5,l.e[n]);l.e[n]=q}return l}}(this).call(null,d.shift,d.root),d.root=a),this;if(b===d.g)return zb(this,c);if(u)throw Error(\"Index \"+A.b(b)+\" out of bounds for TransientVector of length\"+A.b(d.g));return null}throw Error(\"assoc! after persistent!\");};\ng.Qb=function(){if(this.root.t){if(0===this.g)throw Error(\"Can't pop empty vector\");if(1===this.g)return this.g=0,this;if(0<(this.g-1&31))return this.g-=1,this;if(u){var a;a:if(a=this.g-2,a>=ee(this))a=this.R;else{for(var b=this.root,c=b,d=this.shift;;)if(0<d)c=Ce(b.t,c.e[a>>>d&31]),d-=5;else{a=c.e;break a}a=void 0}b=Ge(this,this.shift,this.root);b=null!=b?b:new be(this.root.t,[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,\nnull,null,null,null,null,null,null,null]);5<this.shift&&null==b.e[1]?(this.root=Ce(this.root.t,b.e[0]),this.shift-=5):this.root=b;this.g-=1;this.R=a;return this}return null}throw Error(\"pop! after persistent!\");};g.cb=function(a,b,c){if(\"number\"===typeof b)return Db(this,b,c);throw Error(\"TransientVector's key for assoc! must be a number.\");};\ng.Ka=function(a,b){if(this.root.t){if(32>this.g-ee(this))this.R[this.g&31]=b;else{var c=new be(this.root.t,this.R),d=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];d[0]=b;this.R=d;if(this.g>>>5>1<<this.shift){var d=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],e=this.shift+\n5;d[0]=this.root;d[1]=fe(this.root.t,this.shift,c);this.root=new be(this.root.t,d);this.shift=e}else this.root=Ee(this,this.shift,this.root,c)}this.g+=1;return this}throw Error(\"conj! after persistent!\");};g.Oa=function(){if(this.root.t){this.root.t=null;var a=this.g-ee(this),b=Array(a);Kc(this.R,0,b,0,a);return new W(null,this.g,this.shift,this.root,b,null)}throw Error(\"persistent! called twice\");};function He(a,b,c,d){this.j=a;this.ba=b;this.pa=c;this.m=d;this.q=0;this.i=31850572}g=He.prototype;\ng.toString=function(){return Lb(this)};g.D=function(){return this.j};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.j)};g.Q=function(){return F(this.ba)};g.S=function(){var a=I(this.ba);return a?new He(this.j,a,this.pa,null):null==this.pa?Ba(this):new He(this.j,this.pa,null,null)};g.H=function(){return this};g.F=function(a,b){return new He(b,this.ba,this.pa,this.m)};g.G=function(a,b){return M(b,this)};\nfunction Ie(a,b,c,d,e){this.j=a;this.count=b;this.ba=c;this.pa=d;this.m=e;this.i=31858766;this.q=8192}g=Ie.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};g.L=function(){return this.count};g.Ia=function(){return F(this.ba)};g.Ja=function(){if(r(this.ba)){var a=I(this.ba);return a?new Ie(this.j,this.count-1,a,this.pa,null):new Ie(this.j,this.count-1,E(this.pa),qe,null)}return this};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};\ng.v=function(a,b){return lc(this,b)};g.I=function(){return Je};g.Q=function(){return F(this.ba)};g.S=function(){return G(E(this))};g.H=function(){var a=E(this.pa),b=this.ba;return r(r(b)?b:a)?new He(null,this.ba,E(a),null):null};g.F=function(a,b){return new Ie(b,this.count,this.ba,this.pa,this.m)};g.G=function(a,b){var c;r(this.ba)?(c=this.pa,c=new Ie(this.j,this.count+1,this.ba,pc.a(r(c)?c:qe,b),null)):c=new Ie(this.j,this.count+1,pc.a(this.ba,b),qe,null);return c};var Je=new Ie(null,0,null,qe,0);\nfunction Ke(){this.q=0;this.i=2097152}Ke.prototype.v=function(){return!1};var Le=new Ke;function Me(a,b){return Nc(Gc(b)?O(a)===O(b)?Dd(Fd,Kd.a(function(a){return Wb.a(Q.c(b,F(a),Le),F(I(a)))},a)):null:null)}function Ne(a){this.r=a}Ne.prototype.next=function(){if(null!=this.r){var a=F(this.r);this.r=I(this.r);return{done:!1,value:a}}return{done:!0,value:null}};function Oe(a){return new Ne(E(a))}function Pe(a){this.r=a}\nPe.prototype.next=function(){if(null!=this.r){var a=F(this.r),b=P.c(a,0,null),a=P.c(a,1,null);this.r=I(this.r);return{done:!1,value:[b,a]}}return{done:!0,value:null}};function Qe(a){return new Pe(E(a))}function Re(a){this.r=a}Re.prototype.next=function(){if(null!=this.r){var a=F(this.r);this.r=I(this.r);return{done:!1,value:[a,a]}}return{done:!0,value:null}};function Se(a){return new Re(E(a))}\nfunction Te(a,b){var c=a.e;if(b instanceof T)a:{for(var d=c.length,e=b.sa,f=0;;){if(d<=f){c=-1;break a}var h=c[f];if(h instanceof T&&e===h.sa){c=f;break a}if(u)f+=2;else{c=null;break a}}c=void 0}else if(\"string\"==typeof b||\"number\"===typeof b)a:{d=c.length;for(e=0;;){if(d<=e){c=-1;break a}if(b===c[e]){c=e;break a}if(u)e+=2;else{c=null;break a}}c=void 0}else if(b instanceof Zb)a:{d=c.length;e=b.Na;for(f=0;;){if(d<=f){c=-1;break a}h=c[f];if(h instanceof Zb&&e===h.Na){c=f;break a}if(u)f+=2;else{c=null;\nbreak a}}c=void 0}else if(null==b)a:{d=c.length;for(e=0;;){if(d<=e){c=-1;break a}if(null==c[e]){c=e;break a}if(u)e+=2;else{c=null;break a}}c=void 0}else if(u)a:{d=c.length;for(e=0;;){if(d<=e){c=-1;break a}if(Wb.a(b,c[e])){c=e;break a}if(u)e+=2;else{c=null;break a}}c=void 0}else c=null;return c}function Ue(a,b,c){this.e=a;this.p=b;this.W=c;this.q=0;this.i=32374990}g=Ue.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.W};\ng.U=function(){return this.p<this.e.length-2?new Ue(this.e,this.p+2,this.W):null};g.L=function(){return(this.e.length-this.p)/2};g.B=function(){return cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.W)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return new W(null,2,5,X,[this.e[this.p],this.e[this.p+1]],null)};g.S=function(){return this.p<this.e.length-2?new Ue(this.e,this.p+2,this.W):H};g.H=function(){return this};\ng.F=function(a,b){return new Ue(this.e,this.p,b)};g.G=function(a,b){return M(b,this)};function la(a,b,c,d){this.j=a;this.g=b;this.e=c;this.m=d;this.i=16647951;this.q=8196}g=la.prototype;g.toString=function(){return Lb(this)};g.keys=function(){return Oe(Ve.b?Ve.b(this):Ve.call(null,this))};g.entries=function(){return Qe(E(this))};g.values=function(){return Oe(We.b?We.b(this):We.call(null,this))};g.has=function(a){return Oc(this,a)};g.get=function(a){return this.u(null,a)};\ng.forEach=function(a){for(var b=E(this),c=null,d=0,e=0;;)if(e<d){var f=c.J(null,e),h=P.c(f,0,null),f=P.c(f,1,null);a.a?a.a(f,h):a.call(null,f,h);e+=1}else if(b=E(b))Ic(b)?(c=Hb(b),b=Ib(b),h=c,d=O(c),c=h):(c=F(b),h=P.c(c,0,null),f=P.c(c,1,null),a.a?a.a(f,h):a.call(null,f,h),b=I(b),c=null,d=0),e=0;else return null};g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){a=Te(this,b);return-1===a?c:this.e[a+1]};\ng.Za=function(a,b,c){a=this.e.length;for(var d=0;;)if(d<a){c=b.c?b.c(c,this.e[d],this.e[d+1]):b.call(null,c,this.e[d],this.e[d+1]);if(fc(c))return K.b?K.b(c):K.call(null,c);d+=2}else return c};g.D=function(){return this.j};g.L=function(){return this.g};g.B=function(){var a=this.m;return null!=a?a:this.m=a=dc(this)};g.v=function(a,b){return Me(this,b)};g.Wa=function(){return new Xe({},this.e.length,va(this.e))};g.I=function(){return eb(Ye,this.j)};g.N=function(a,b){return nc.a(b,this)};\ng.M=function(a,b,c){return nc.c(b,c,this)};g.nb=function(a,b){if(0<=Te(this,b)){var c=this.e.length,d=c-2;if(0===d)return Ba(this);for(var d=Array(d),e=0,f=0;;){if(e>=c)return new la(this.j,this.g-1,d,null);if(Wb.a(b,this.e[e]))e+=2;else if(u)d[f]=this.e[e],d[f+1]=this.e[e+1],f+=2,e+=2;else return null}}else return this};\ng.ua=function(a,b,c){a=Te(this,b);if(-1===a){if(this.g<Ze){a=this.e;for(var d=a.length,e=Array(d+2),f=0;;)if(f<d)e[f]=a[f],f+=1;else break;e[d]=b;e[d+1]=c;return new la(this.j,this.g+1,e,null)}return eb(Oa(Yd($e,this),b,c),this.j)}return c===this.e[a+1]?this:u?(b=va(this.e),b[a+1]=c,new la(this.j,this.g,b,null)):null};g.kb=function(a,b){return-1!==Te(this,b)};g.H=function(){var a=this.e;return 0<=a.length-2?new Ue(a,0,null):null};g.F=function(a,b){return new la(b,this.g,this.e,this.m)};\ng.G=function(a,b){if(Hc(b))return Oa(this,D.a(b,0),D.a(b,1));for(var c=this,d=E(b);;){if(null==d)return c;var e=F(d);if(Hc(e))c=Oa(c,D.a(e,0),D.a(e,1)),d=I(d);else throw Error(\"conj on a map takes map entries or seqables of map entries\");}};g.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};\ng.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};var Ye=new la(null,0,[],null),Ze=8;function af(a){for(var b=a.length,c=0,d=yb(Ye);;)if(c<b)var e=c+2,d=Bb(d,a[c],a[c+1]),c=e;else return Ab(d)}function Xe(a,b,c){this.Ra=a;this.ja=b;this.e=c;this.q=56;this.i=258}g=Xe.prototype;\ng.Ab=function(a,b){if(r(this.Ra)){var c=Te(this,b);0<=c&&(this.e[c]=this.e[this.ja-2],this.e[c+1]=this.e[this.ja-1],c=this.e,c.pop(),c.pop(),this.ja-=2);return this}throw Error(\"dissoc! after persistent!\");};g.cb=function(a,b,c){if(r(this.Ra)){a=Te(this,b);if(-1===a)return this.ja+2<=2*Ze?(this.ja+=2,this.e.push(b),this.e.push(c),this):xd.c(bf.a?bf.a(this.ja,this.e):bf.call(null,this.ja,this.e),b,c);c!==this.e[a+1]&&(this.e[a+1]=c);return this}throw Error(\"assoc! after persistent!\");};\ng.Ka=function(a,b){if(r(this.Ra)){if(b?b.i&2048||b.dc||(b.i?0:s(Sa,b)):s(Sa,b))return Bb(this,cf.b?cf.b(b):cf.call(null,b),df.b?df.b(b):df.call(null,b));for(var c=E(b),d=this;;){var e=F(c);if(r(e))c=I(c),d=Bb(d,cf.b?cf.b(e):cf.call(null,e),df.b?df.b(e):df.call(null,e));else return d}}else throw Error(\"conj! after persistent!\");};g.Oa=function(){if(r(this.Ra))return this.Ra=!1,new la(null,Yc(this.ja),this.e,null);throw Error(\"persistent! called twice\");};g.u=function(a,b){return La.c(this,b,null)};\ng.C=function(a,b,c){if(r(this.Ra))return a=Te(this,b),-1===a?c:this.e[a+1];throw Error(\"lookup after persistent!\");};g.L=function(){if(r(this.Ra))return Yc(this.ja);throw Error(\"count after persistent!\");};function bf(a,b){for(var c=yb($e),d=0;;)if(d<a)c=xd.c(c,b[d],b[d+1]),d+=2;else return c}function ef(){this.l=!1}function ff(a,b){return a===b?!0:hd(a,b)?!0:u?Wb.a(a,b):null}\nvar gf=function(){function a(a,b,c,h,k){a=va(a);a[b]=c;a[h]=k;return a}function b(a,b,c){a=va(a);a[b]=c;return a}var c=null,c=function(c,e,f,h,k){switch(arguments.length){case 3:return b.call(this,c,e,f);case 5:return a.call(this,c,e,f,h,k)}throw Error(\"Invalid arity: \"+arguments.length);};c.c=b;c.s=a;return c}();function hf(a,b){var c=Array(a.length-2);Kc(a,0,c,0,2*b);Kc(a,2*(b+1),c,2*b,c.length-2*b);return c}\nvar jf=function(){function a(a,b,c,h,k,l){a=a.La(b);a.e[c]=h;a.e[k]=l;return a}function b(a,b,c,h){a=a.La(b);a.e[c]=h;return a}var c=null,c=function(c,e,f,h,k,l){switch(arguments.length){case 4:return b.call(this,c,e,f,h);case 6:return a.call(this,c,e,f,h,k,l)}throw Error(\"Invalid arity: \"+arguments.length);};c.n=b;c.X=a;return c}();\nfunction kf(a,b,c){for(var d=a.length,e=0;;)if(e<d){var f=a[e];null!=f?c=b.c?b.c(c,f,a[e+1]):b.call(null,c,f,a[e+1]):(f=a[e+1],c=null!=f?f.Ta(b,c):c);if(fc(c))return K.b?K.b(c):K.call(null,c);e+=2}else return c}function lf(a,b,c){this.t=a;this.A=b;this.e=c}g=lf.prototype;g.La=function(a){if(a===this.t)return this;var b=Zc(this.A),c=Array(0>b?4:2*(b+1));Kc(this.e,0,c,0,2*b);return new lf(a,this.A,c)};\ng.gb=function(a,b,c,d,e){var f=1<<(c>>>b&31);if(0===(this.A&f))return this;var h=Zc(this.A&f-1),k=this.e[2*h],l=this.e[2*h+1];return null==k?(b=l.gb(a,b+5,c,d,e),b===l?this:null!=b?jf.n(this,a,2*h+1,b):this.A===f?null:u?mf(this,a,f,h):null):ff(d,k)?(e[0]=!0,mf(this,a,f,h)):u?this:null};function mf(a,b,c,d){if(a.A===c)return null;a=a.La(b);b=a.e;var e=b.length;a.A^=c;Kc(b,2*(d+1),b,2*d,e-2*(d+1));b[e-2]=null;b[e-1]=null;return a}g.eb=function(){return nf.b?nf.b(this.e):nf.call(null,this.e)};\ng.Ta=function(a,b){return kf(this.e,a,b)};g.Ma=function(a,b,c,d){var e=1<<(b>>>a&31);if(0===(this.A&e))return d;var f=Zc(this.A&e-1),e=this.e[2*f],f=this.e[2*f+1];return null==e?f.Ma(a+5,b,c,d):ff(c,e)?f:u?d:null};\ng.ia=function(a,b,c,d,e,f){var h=1<<(c>>>b&31),k=Zc(this.A&h-1);if(0===(this.A&h)){var l=Zc(this.A);if(2*l<this.e.length){a=this.La(a);b=a.e;f.l=!0;a:for(c=2*(l-k),f=2*k+(c-1),l=2*(k+1)+(c-1);;){if(0===c)break a;b[l]=b[f];l-=1;c-=1;f-=1}b[2*k]=d;b[2*k+1]=e;a.A|=h;return a}if(16<=l){k=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];k[c>>>b&31]=of.ia(a,b+5,c,d,e,f);for(e=d=0;;)if(32>d)0!==\n(this.A>>>d&1)&&(k[d]=null!=this.e[e]?of.ia(a,b+5,Tb(this.e[e]),this.e[e],this.e[e+1],f):this.e[e+1],e+=2),d+=1;else break;return new pf(a,l+1,k)}return u?(b=Array(2*(l+4)),Kc(this.e,0,b,0,2*k),b[2*k]=d,b[2*k+1]=e,Kc(this.e,2*k,b,2*(k+1),2*(l-k)),f.l=!0,a=this.La(a),a.e=b,a.A|=h,a):null}l=this.e[2*k];h=this.e[2*k+1];return null==l?(l=h.ia(a,b+5,c,d,e,f),l===h?this:jf.n(this,a,2*k+1,l)):ff(d,l)?e===h?this:jf.n(this,a,2*k+1,e):u?(f.l=!0,jf.X(this,a,2*k,null,2*k+1,qf.ga?qf.ga(a,b+5,l,h,c,d,e):qf.call(null,\na,b+5,l,h,c,d,e))):null};\ng.ha=function(a,b,c,d,e){var f=1<<(b>>>a&31),h=Zc(this.A&f-1);if(0===(this.A&f)){var k=Zc(this.A);if(16<=k){h=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null];h[b>>>a&31]=of.ha(a+5,b,c,d,e);for(d=c=0;;)if(32>c)0!==(this.A>>>c&1)&&(h[c]=null!=this.e[d]?of.ha(a+5,Tb(this.e[d]),this.e[d],this.e[d+1],e):this.e[d+1],d+=2),c+=1;else break;return new pf(null,k+1,h)}a=Array(2*(k+1));Kc(this.e,\n0,a,0,2*h);a[2*h]=c;a[2*h+1]=d;Kc(this.e,2*h,a,2*(h+1),2*(k-h));e.l=!0;return new lf(null,this.A|f,a)}k=this.e[2*h];f=this.e[2*h+1];return null==k?(k=f.ha(a+5,b,c,d,e),k===f?this:new lf(null,this.A,gf.c(this.e,2*h+1,k))):ff(c,k)?d===f?this:new lf(null,this.A,gf.c(this.e,2*h+1,d)):u?(e.l=!0,new lf(null,this.A,gf.s(this.e,2*h,null,2*h+1,qf.X?qf.X(a+5,k,f,b,c,d):qf.call(null,a+5,k,f,b,c,d)))):null};\ng.fb=function(a,b,c){var d=1<<(b>>>a&31);if(0===(this.A&d))return this;var e=Zc(this.A&d-1),f=this.e[2*e],h=this.e[2*e+1];return null==f?(a=h.fb(a+5,b,c),a===h?this:null!=a?new lf(null,this.A,gf.c(this.e,2*e+1,a)):this.A===d?null:u?new lf(null,this.A^d,hf(this.e,e)):null):ff(c,f)?new lf(null,this.A^d,hf(this.e,e)):u?this:null};var of=new lf(null,0,[]);\nfunction rf(a,b,c){var d=a.e;a=2*(a.g-1);for(var e=Array(a),f=0,h=1,k=0;;)if(f<a)f!==c&&null!=d[f]&&(e[h]=d[f],h+=2,k|=1<<f),f+=1;else return new lf(b,k,e)}function pf(a,b,c){this.t=a;this.g=b;this.e=c}g=pf.prototype;g.La=function(a){return a===this.t?this:new pf(a,this.g,va(this.e))};\ng.gb=function(a,b,c,d,e){var f=c>>>b&31,h=this.e[f];if(null==h)return this;b=h.gb(a,b+5,c,d,e);if(b===h)return this;if(null==b){if(8>=this.g)return rf(this,a,f);a=jf.n(this,a,f,b);a.g-=1;return a}return u?jf.n(this,a,f,b):null};g.eb=function(){return sf.b?sf.b(this.e):sf.call(null,this.e)};g.Ta=function(a,b){for(var c=this.e.length,d=0,e=b;;)if(d<c){var f=this.e[d];if(null!=f&&(e=f.Ta(a,e),fc(e)))return K.b?K.b(e):K.call(null,e);d+=1}else return e};\ng.Ma=function(a,b,c,d){var e=this.e[b>>>a&31];return null!=e?e.Ma(a+5,b,c,d):d};g.ia=function(a,b,c,d,e,f){var h=c>>>b&31,k=this.e[h];if(null==k)return a=jf.n(this,a,h,of.ia(a,b+5,c,d,e,f)),a.g+=1,a;b=k.ia(a,b+5,c,d,e,f);return b===k?this:jf.n(this,a,h,b)};g.ha=function(a,b,c,d,e){var f=b>>>a&31,h=this.e[f];if(null==h)return new pf(null,this.g+1,gf.c(this.e,f,of.ha(a+5,b,c,d,e)));a=h.ha(a+5,b,c,d,e);return a===h?this:new pf(null,this.g,gf.c(this.e,f,a))};\ng.fb=function(a,b,c){var d=b>>>a&31,e=this.e[d];return null!=e?(a=e.fb(a+5,b,c),a===e?this:null==a?8>=this.g?rf(this,null,d):new pf(null,this.g-1,gf.c(this.e,d,a)):u?new pf(null,this.g,gf.c(this.e,d,a)):null):this};function tf(a,b,c){b*=2;for(var d=0;;)if(d<b){if(ff(c,a[d]))return d;d+=2}else return-1}function uf(a,b,c,d){this.t=a;this.ra=b;this.g=c;this.e=d}g=uf.prototype;\ng.La=function(a){if(a===this.t)return this;var b=Array(2*(this.g+1));Kc(this.e,0,b,0,2*this.g);return new uf(a,this.ra,this.g,b)};g.gb=function(a,b,c,d,e){b=tf(this.e,this.g,d);if(-1===b)return this;e[0]=!0;if(1===this.g)return null;a=this.La(a);e=a.e;e[b]=e[2*this.g-2];e[b+1]=e[2*this.g-1];e[2*this.g-1]=null;e[2*this.g-2]=null;a.g-=1;return a};g.eb=function(){return nf.b?nf.b(this.e):nf.call(null,this.e)};g.Ta=function(a,b){return kf(this.e,a,b)};\ng.Ma=function(a,b,c,d){a=tf(this.e,this.g,c);return 0>a?d:ff(c,this.e[a])?this.e[a+1]:u?d:null};\ng.ia=function(a,b,c,d,e,f){if(c===this.ra){b=tf(this.e,this.g,d);if(-1===b){if(this.e.length>2*this.g)return a=jf.X(this,a,2*this.g,d,2*this.g+1,e),f.l=!0,a.g+=1,a;c=this.e.length;b=Array(c+2);Kc(this.e,0,b,0,c);b[c]=d;b[c+1]=e;f.l=!0;f=this.g+1;a===this.t?(this.e=b,this.g=f,a=this):a=new uf(this.t,this.ra,f,b);return a}return this.e[b+1]===e?this:jf.n(this,a,b+1,e)}return(new lf(a,1<<(this.ra>>>b&31),[null,this,null,null])).ia(a,b,c,d,e,f)};\ng.ha=function(a,b,c,d,e){return b===this.ra?(a=tf(this.e,this.g,c),-1===a?(a=2*this.g,b=Array(a+2),Kc(this.e,0,b,0,a),b[a]=c,b[a+1]=d,e.l=!0,new uf(null,this.ra,this.g+1,b)):Wb.a(this.e[a],d)?this:new uf(null,this.ra,this.g,gf.c(this.e,a+1,d))):(new lf(null,1<<(this.ra>>>a&31),[null,this])).ha(a,b,c,d,e)};g.fb=function(a,b,c){a=tf(this.e,this.g,c);return-1===a?this:1===this.g?null:u?new uf(null,this.ra,this.g-1,hf(this.e,Yc(a))):null};\nvar qf=function(){function a(a,b,c,h,k,l,n){var q=Tb(c);if(q===k)return new uf(null,q,2,[c,h,l,n]);var t=new ef;return of.ia(a,b,q,c,h,t).ia(a,b,k,l,n,t)}function b(a,b,c,h,k,l){var n=Tb(b);if(n===h)return new uf(null,n,2,[b,c,k,l]);var q=new ef;return of.ha(a,n,b,c,q).ha(a,h,k,l,q)}var c=null,c=function(c,e,f,h,k,l,n){switch(arguments.length){case 6:return b.call(this,c,e,f,h,k,l);case 7:return a.call(this,c,e,f,h,k,l,n)}throw Error(\"Invalid arity: \"+arguments.length);};c.X=b;c.ga=a;return c}();\nfunction vf(a,b,c,d,e){this.j=a;this.ka=b;this.p=c;this.r=d;this.m=e;this.q=0;this.i=32374860}g=vf.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.j)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return null==this.r?new W(null,2,5,X,[this.ka[this.p],this.ka[this.p+1]],null):F(this.r)};\ng.S=function(){return null==this.r?nf.c?nf.c(this.ka,this.p+2,null):nf.call(null,this.ka,this.p+2,null):nf.c?nf.c(this.ka,this.p,I(this.r)):nf.call(null,this.ka,this.p,I(this.r))};g.H=function(){return this};g.F=function(a,b){return new vf(b,this.ka,this.p,this.r,this.m)};g.G=function(a,b){return M(b,this)};\nvar nf=function(){function a(a,b,c){if(null==c)for(c=a.length;;)if(b<c){if(null!=a[b])return new vf(null,a,b,null,null);var h=a[b+1];if(r(h)&&(h=h.eb(),r(h)))return new vf(null,a,b+2,h,null);b+=2}else return null;else return new vf(null,a,b,c,null)}function b(a){return c.c(a,0,null)}var c=null,c=function(c,e,f){switch(arguments.length){case 1:return b.call(this,c);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.c=a;return c}();\nfunction wf(a,b,c,d,e){this.j=a;this.ka=b;this.p=c;this.r=d;this.m=e;this.q=0;this.i=32374860}g=wf.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.j)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return F(this.r)};\ng.S=function(){return sf.n?sf.n(null,this.ka,this.p,I(this.r)):sf.call(null,null,this.ka,this.p,I(this.r))};g.H=function(){return this};g.F=function(a,b){return new wf(b,this.ka,this.p,this.r,this.m)};g.G=function(a,b){return M(b,this)};\nvar sf=function(){function a(a,b,c,h){if(null==h)for(h=b.length;;)if(c<h){var k=b[c];if(r(k)&&(k=k.eb(),r(k)))return new wf(a,b,c+1,k,null);c+=1}else return null;else return new wf(a,b,c,h,null)}function b(a){return c.n(null,a,0,null)}var c=null,c=function(c,e,f,h){switch(arguments.length){case 1:return b.call(this,c);case 4:return a.call(this,c,e,f,h)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.n=a;return c}();\nfunction xf(a,b,c,d,e,f){this.j=a;this.g=b;this.root=c;this.T=d;this.Y=e;this.m=f;this.i=16123663;this.q=8196}g=xf.prototype;g.toString=function(){return Lb(this)};g.keys=function(){return Oe(Ve.b?Ve.b(this):Ve.call(null,this))};g.entries=function(){return Qe(E(this))};g.values=function(){return Oe(We.b?We.b(this):We.call(null,this))};g.has=function(a){return Oc(this,a)};g.get=function(a){return this.u(null,a)};\ng.forEach=function(a){for(var b=E(this),c=null,d=0,e=0;;)if(e<d){var f=c.J(null,e),h=P.c(f,0,null),f=P.c(f,1,null);a.a?a.a(f,h):a.call(null,f,h);e+=1}else if(b=E(b))Ic(b)?(c=Hb(b),b=Ib(b),h=c,d=O(c),c=h):(c=F(b),h=P.c(c,0,null),f=P.c(c,1,null),a.a?a.a(f,h):a.call(null,f,h),b=I(b),c=null,d=0),e=0;else return null};g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){return null==b?this.T?this.Y:c:null==this.root?c:u?this.root.Ma(0,Tb(b),b,c):null};\ng.Za=function(a,b,c){a=this.T?b.c?b.c(c,null,this.Y):b.call(null,c,null,this.Y):c;return fc(a)?K.b?K.b(a):K.call(null,a):null!=this.root?this.root.Ta(b,a):u?a:null};g.D=function(){return this.j};g.L=function(){return this.g};g.B=function(){var a=this.m;return null!=a?a:this.m=a=dc(this)};g.v=function(a,b){return Me(this,b)};g.Wa=function(){return new yf({},this.root,this.g,this.T,this.Y)};g.I=function(){return eb($e,this.j)};\ng.nb=function(a,b){if(null==b)return this.T?new xf(this.j,this.g-1,this.root,!1,null,null):this;if(null==this.root)return this;if(u){var c=this.root.fb(0,Tb(b),b);return c===this.root?this:new xf(this.j,this.g-1,c,this.T,this.Y,null)}return null};\ng.ua=function(a,b,c){if(null==b)return this.T&&c===this.Y?this:new xf(this.j,this.T?this.g:this.g+1,this.root,!0,c,null);a=new ef;b=(null==this.root?of:this.root).ha(0,Tb(b),b,c,a);return b===this.root?this:new xf(this.j,a.l?this.g+1:this.g,b,this.T,this.Y,null)};g.kb=function(a,b){return null==b?this.T:null==this.root?!1:u?this.root.Ma(0,Tb(b),b,Lc)!==Lc:null};g.H=function(){if(0<this.g){var a=null!=this.root?this.root.eb():null;return this.T?M(new W(null,2,5,X,[null,this.Y],null),a):a}return null};\ng.F=function(a,b){return new xf(b,this.g,this.root,this.T,this.Y,this.m)};g.G=function(a,b){if(Hc(b))return Oa(this,D.a(b,0),D.a(b,1));for(var c=this,d=E(b);;){if(null==d)return c;var e=F(d);if(Hc(e))c=Oa(c,D.a(e,0),D.a(e,1)),d=I(d);else throw Error(\"conj on a map takes map entries or seqables of map entries\");}};\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};var $e=new xf(null,0,null,!1,null,0);function sc(a,b){for(var c=a.length,d=0,e=yb($e);;)if(d<c)var f=d+1,e=e.cb(null,a[d],b[d]),d=f;else return Ab(e)}\nfunction yf(a,b,c,d,e){this.t=a;this.root=b;this.count=c;this.T=d;this.Y=e;this.q=56;this.i=258}g=yf.prototype;g.Ab=function(a,b){if(this.t)if(null==b)this.T&&(this.T=!1,this.Y=null,this.count-=1);else{if(null!=this.root){var c=new ef,d=this.root.gb(this.t,0,Tb(b),b,c);d!==this.root&&(this.root=d);r(c[0])&&(this.count-=1)}}else throw Error(\"dissoc! after persistent!\");return this};g.cb=function(a,b,c){return zf(this,b,c)};\ng.Ka=function(a,b){var c;a:{if(this.t){if(b?b.i&2048||b.dc||(b.i?0:s(Sa,b)):s(Sa,b)){c=zf(this,cf.b?cf.b(b):cf.call(null,b),df.b?df.b(b):df.call(null,b));break a}c=E(b);for(var d=this;;){var e=F(c);if(r(e))c=I(c),d=zf(d,cf.b?cf.b(e):cf.call(null,e),df.b?df.b(e):df.call(null,e));else{c=d;break a}}}else throw Error(\"conj! after persistent\");c=void 0}return c};\ng.Oa=function(){var a;if(this.t)this.t=null,a=new xf(null,this.count,this.root,this.T,this.Y,null);else throw Error(\"persistent! called twice\");return a};g.u=function(a,b){return null==b?this.T?this.Y:null:null==this.root?null:this.root.Ma(0,Tb(b),b)};g.C=function(a,b,c){return null==b?this.T?this.Y:c:null==this.root?c:this.root.Ma(0,Tb(b),b,c)};g.L=function(){if(this.t)return this.count;throw Error(\"count after persistent!\");};\nfunction zf(a,b,c){if(a.t){if(null==b)a.Y!==c&&(a.Y=c),a.T||(a.count+=1,a.T=!0);else{var d=new ef;b=(null==a.root?of:a.root).ia(a.t,0,Tb(b),b,c,d);b!==a.root&&(a.root=b);d.l&&(a.count+=1)}return a}throw Error(\"assoc! after persistent!\");}function Af(a,b,c){for(var d=b;;)if(null!=a)b=c?a.left:a.right,d=pc.a(d,a),a=b;else return d}function Bf(a,b,c,d,e){this.j=a;this.stack=b;this.ib=c;this.g=d;this.m=e;this.q=0;this.i=32374862}g=Bf.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.j};\ng.L=function(){return 0>this.g?O(I(this))+1:this.g};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.j)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return yc(this.stack)};g.S=function(){var a=F(this.stack),a=Af(this.ib?a.right:a.left,I(this.stack),this.ib);return null!=a?new Bf(null,a,this.ib,this.g-1,null):H};g.H=function(){return this};\ng.F=function(a,b){return new Bf(b,this.stack,this.ib,this.g,this.m)};g.G=function(a,b){return M(b,this)};function Cf(a,b,c){return new Bf(null,Af(a,null,b),b,c,null)}function Df(a,b,c,d){return c instanceof Y?c.left instanceof Y?new Y(c.key,c.l,c.left.qa(),new $(a,b,c.right,d,null),null):c.right instanceof Y?new Y(c.right.key,c.right.l,new $(c.key,c.l,c.left,c.right.left,null),new $(a,b,c.right.right,d,null),null):u?new $(a,b,c,d,null):null:new $(a,b,c,d,null)}\nfunction Ef(a,b,c,d){return d instanceof Y?d.right instanceof Y?new Y(d.key,d.l,new $(a,b,c,d.left,null),d.right.qa(),null):d.left instanceof Y?new Y(d.left.key,d.left.l,new $(a,b,c,d.left.left,null),new $(d.key,d.l,d.left.right,d.right,null),null):u?new $(a,b,c,d,null):null:new $(a,b,c,d,null)}\nfunction Ff(a,b,c,d){if(c instanceof Y)return new Y(a,b,c.qa(),d,null);if(d instanceof $)return Ef(a,b,c,d.hb());if(d instanceof Y&&d.left instanceof $)return new Y(d.left.key,d.left.l,new $(a,b,c,d.left.left,null),Ef(d.key,d.l,d.left.right,d.right.hb()),null);if(u)throw Error(\"red-black tree invariant violation\");return null}\nvar Hf=function Gf(b,c,d){d=null!=b.left?Gf(b.left,c,d):d;if(fc(d))return K.b?K.b(d):K.call(null,d);d=c.c?c.c(d,b.key,b.l):c.call(null,d,b.key,b.l);if(fc(d))return K.b?K.b(d):K.call(null,d);b=null!=b.right?Gf(b.right,c,d):d;return fc(b)?K.b?K.b(b):K.call(null,b):b};function $(a,b,c,d,e){this.key=a;this.l=b;this.left=c;this.right=d;this.m=e;this.q=0;this.i=32402207}g=$.prototype;g.Hb=function(a){return a.Jb(this)};g.hb=function(){return new Y(this.key,this.l,this.left,this.right,null)};g.qa=function(){return this};\ng.Gb=function(a){return a.Ib(this)};g.replace=function(a,b,c,d){return new $(a,b,c,d,null)};g.Ib=function(a){return new $(a.key,a.l,this,a.right,null)};g.Jb=function(a){return new $(a.key,a.l,a.left,this,null)};g.Ta=function(a,b){return Hf(this,a,b)};g.u=function(a,b){return D.c(this,b,null)};g.C=function(a,b,c){return D.c(this,b,c)};g.J=function(a,b){return 0===b?this.key:1===b?this.l:null};g.aa=function(a,b,c){return 0===b?this.key:1===b?this.l:u?c:null};\ng.Pa=function(a,b,c){return(new W(null,2,5,X,[this.key,this.l],null)).Pa(null,b,c)};g.D=function(){return null};g.L=function(){return 2};g.$a=function(){return this.key};g.ab=function(){return this.l};g.Ia=function(){return this.l};g.Ja=function(){return new W(null,1,5,X,[this.key],null)};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return qe};g.N=function(a,b){return gc.a(this,b)};g.M=function(a,b,c){return gc.c(this,b,c)};\ng.ua=function(a,b,c){return R.c(new W(null,2,5,X,[this.key,this.l],null),b,c)};g.H=function(){return Da(Da(H,this.l),this.key)};g.F=function(a,b){return N(new W(null,2,5,X,[this.key,this.l],null),b)};g.G=function(a,b){return new W(null,3,5,X,[this.key,this.l,b],null)};g.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();\ng.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};function Y(a,b,c,d,e){this.key=a;this.l=b;this.left=c;this.right=d;this.m=e;this.q=0;this.i=32402207}g=Y.prototype;g.Hb=function(a){return new Y(this.key,this.l,this.left,a,null)};g.hb=function(){throw Error(\"red-black tree invariant violation\");};g.qa=function(){return new $(this.key,this.l,this.left,this.right,null)};\ng.Gb=function(a){return new Y(this.key,this.l,a,this.right,null)};g.replace=function(a,b,c,d){return new Y(a,b,c,d,null)};g.Ib=function(a){return this.left instanceof Y?new Y(this.key,this.l,this.left.qa(),new $(a.key,a.l,this.right,a.right,null),null):this.right instanceof Y?new Y(this.right.key,this.right.l,new $(this.key,this.l,this.left,this.right.left,null),new $(a.key,a.l,this.right.right,a.right,null),null):u?new $(a.key,a.l,this,a.right,null):null};\ng.Jb=function(a){return this.right instanceof Y?new Y(this.key,this.l,new $(a.key,a.l,a.left,this.left,null),this.right.qa(),null):this.left instanceof Y?new Y(this.left.key,this.left.l,new $(a.key,a.l,a.left,this.left.left,null),new $(this.key,this.l,this.left.right,this.right,null),null):u?new $(a.key,a.l,a.left,this,null):null};g.Ta=function(a,b){return Hf(this,a,b)};g.u=function(a,b){return D.c(this,b,null)};g.C=function(a,b,c){return D.c(this,b,c)};\ng.J=function(a,b){return 0===b?this.key:1===b?this.l:null};g.aa=function(a,b,c){return 0===b?this.key:1===b?this.l:u?c:null};g.Pa=function(a,b,c){return(new W(null,2,5,X,[this.key,this.l],null)).Pa(null,b,c)};g.D=function(){return null};g.L=function(){return 2};g.$a=function(){return this.key};g.ab=function(){return this.l};g.Ia=function(){return this.l};g.Ja=function(){return new W(null,1,5,X,[this.key],null)};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};\ng.v=function(a,b){return lc(this,b)};g.I=function(){return qe};g.N=function(a,b){return gc.a(this,b)};g.M=function(a,b,c){return gc.c(this,b,c)};g.ua=function(a,b,c){return R.c(new W(null,2,5,X,[this.key,this.l],null),b,c)};g.H=function(){return Da(Da(H,this.l),this.key)};g.F=function(a,b){return N(new W(null,2,5,X,[this.key,this.l],null),b)};g.G=function(a,b){return new W(null,3,5,X,[this.key,this.l,b],null)};\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};\nvar Jf=function If(b,c,d,e,f){if(null==c)return new Y(d,e,null,null,null);var h=b.a?b.a(d,c.key):b.call(null,d,c.key);return 0===h?(f[0]=c,null):0>h?(b=If(b,c.left,d,e,f),null!=b?c.Gb(b):null):u?(b=If(b,c.right,d,e,f),null!=b?c.Hb(b):null):null},Lf=function Kf(b,c){if(null==b)return c;if(null==c)return b;if(b instanceof Y){if(c instanceof Y){var d=Kf(b.right,c.left);return d instanceof Y?new Y(d.key,d.l,new Y(b.key,b.l,b.left,d.left,null),new Y(c.key,c.l,d.right,c.right,null),null):new Y(b.key,b.l,\nb.left,new Y(c.key,c.l,d,c.right,null),null)}return new Y(b.key,b.l,b.left,Kf(b.right,c),null)}return c instanceof Y?new Y(c.key,c.l,Kf(b,c.left),c.right,null):u?(d=Kf(b.right,c.left),d instanceof Y?new Y(d.key,d.l,new $(b.key,b.l,b.left,d.left,null),new $(c.key,c.l,d.right,c.right,null),null):Ff(b.key,b.l,b.left,new $(c.key,c.l,d,c.right,null))):null},Nf=function Mf(b,c,d,e){if(null!=c){var f=b.a?b.a(d,c.key):b.call(null,d,c.key);if(0===f)return e[0]=c,Lf(c.left,c.right);if(0>f)return b=Mf(b,c.left,\nd,e),null!=b||null!=e[0]?c.left instanceof $?Ff(c.key,c.l,b,c.right):new Y(c.key,c.l,b,c.right,null):null;if(u){b=Mf(b,c.right,d,e);if(null!=b||null!=e[0])if(c.right instanceof $)if(e=c.key,d=c.l,c=c.left,b instanceof Y)c=new Y(e,d,c,b.qa(),null);else if(c instanceof $)c=Df(e,d,c.hb(),b);else if(c instanceof Y&&c.right instanceof $)c=new Y(c.right.key,c.right.l,Df(c.key,c.l,c.left.hb(),c.right.left),new $(e,d,c.right.right,b,null),null);else{if(u)throw Error(\"red-black tree invariant violation\");\nc=null}else c=new Y(c.key,c.l,c.left,b,null);else c=null;return c}}return null},Pf=function Of(b,c,d,e){var f=c.key,h=b.a?b.a(d,f):b.call(null,d,f);return 0===h?c.replace(f,e,c.left,c.right):0>h?c.replace(f,c.l,Of(b,c.left,d,e),c.right):u?c.replace(f,c.l,c.left,Of(b,c.right,d,e)):null};function Qf(a,b,c,d,e){this.Z=a;this.ma=b;this.g=c;this.j=d;this.m=e;this.i=418776847;this.q=8192}g=Qf.prototype;g.toString=function(){return Lb(this)};g.keys=function(){return Oe(Ve.b?Ve.b(this):Ve.call(null,this))};\ng.entries=function(){return Qe(E(this))};g.values=function(){return Oe(We.b?We.b(this):We.call(null,this))};g.has=function(a){return Oc(this,a)};g.get=function(a){return this.u(null,a)};g.forEach=function(a){for(var b=E(this),c=null,d=0,e=0;;)if(e<d){var f=c.J(null,e),h=P.c(f,0,null),f=P.c(f,1,null);a.a?a.a(f,h):a.call(null,f,h);e+=1}else if(b=E(b))Ic(b)?(c=Hb(b),b=Ib(b),h=c,d=O(c),c=h):(c=F(b),h=P.c(c,0,null),f=P.c(c,1,null),a.a?a.a(f,h):a.call(null,f,h),b=I(b),c=null,d=0),e=0;else return null};\nfunction Rf(a,b){for(var c=a.ma;;)if(null!=c){var d=a.Z.a?a.Z.a(b,c.key):a.Z.call(null,b,c.key);if(0===d)return c;if(0>d)c=c.left;else if(u)c=c.right;else return null}else return null}g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){a=Rf(this,b);return null!=a?a.l:c};g.Za=function(a,b,c){return null!=this.ma?Hf(this.ma,b,c):c};g.D=function(){return this.j};g.L=function(){return this.g};g.Xa=function(){return 0<this.g?Cf(this.ma,!1,this.g):null};\ng.B=function(){var a=this.m;return null!=a?a:this.m=a=dc(this)};g.v=function(a,b){return Me(this,b)};g.I=function(){return N(Sf,this.j)};g.nb=function(a,b){var c=[null],d=Nf(this.Z,this.ma,b,c);return null==d?null==P.a(c,0)?this:new Qf(this.Z,null,0,this.j,null):new Qf(this.Z,d.qa(),this.g-1,this.j,null)};\ng.ua=function(a,b,c){a=[null];var d=Jf(this.Z,this.ma,b,c,a);return null==d?(a=P.a(a,0),Wb.a(c,a.l)?this:new Qf(this.Z,Pf(this.Z,this.ma,b,c),this.g,this.j,null)):new Qf(this.Z,d.qa(),this.g+1,this.j,null)};g.kb=function(a,b){return null!=Rf(this,b)};g.H=function(){return 0<this.g?Cf(this.ma,!0,this.g):null};g.F=function(a,b){return new Qf(this.Z,this.ma,this.g,b,this.m)};\ng.G=function(a,b){if(Hc(b))return Oa(this,D.a(b,0),D.a(b,1));for(var c=this,d=E(b);;){if(null==d)return c;var e=F(d);if(Hc(e))c=Oa(c,D.a(e,0),D.a(e,1)),d=I(d);else throw Error(\"conj on a map takes map entries or seqables of map entries\");}};g.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};\ng.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};g.yb=function(a,b){return 0<this.g?Cf(this.ma,b,this.g):null};g.zb=function(a,b,c){if(0<this.g){a=null;for(var d=this.ma;;)if(null!=d){var e=this.Z.a?this.Z.a(b,d.key):this.Z.call(null,b,d.key);if(0===e)return new Bf(null,pc.a(a,d),c,-1,null);if(r(c))0>e?(a=pc.a(a,d),d=d.left):d=d.right;else if(u)0<e?(a=pc.a(a,d),d=d.right):d=d.left;else return null}else return null==a?null:new Bf(null,a,c,-1,null)}else return null};\ng.xb=function(a,b){return cf.b?cf.b(b):cf.call(null,b)};g.wb=function(){return this.Z};\nvar Sf=new Qf(Xb,null,0,null,0),Tf=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){a=E(a);for(var b=yb($e);;)if(a){var e=I(I(a)),b=xd.c(b,F(a),F(I(a)));a=e}else return Ab(b)}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}(),Uf=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return new la(null,Yc(O(a)),S.a(wa,\na),null)}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}(),Vf=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){a=E(a);for(var b=Sf;;)if(a){var e=I(I(a)),b=R.c(b,F(a),F(I(a)));a=e}else return b}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}(),Wf=function(){function a(a,d){var e=null;1<arguments.length&&(e=J(Array.prototype.slice.call(arguments,1),0));return b.call(this,a,e)}function b(a,\nb){for(var e=E(b),f=new Qf(Qc(a),null,0,null,0);;)if(e)var h=I(I(e)),f=R.c(f,F(e),F(I(e))),e=h;else return f}a.k=1;a.f=function(a){var d=F(a);a=G(a);return b(d,a)};a.d=b;return a}();function Xf(a,b){this.V=a;this.W=b;this.q=0;this.i=32374988}g=Xf.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.W};g.U=function(){var a=this.V,a=(a?a.i&128||a.ob||(a.i?0:s(Ja,a)):s(Ja,a))?this.V.U(null):I(this.V);return null==a?null:new Xf(a,this.W)};g.B=function(){return cc(this)};\ng.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.W)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return this.V.Q(null).$a(null)};g.S=function(){var a=this.V,a=(a?a.i&128||a.ob||(a.i?0:s(Ja,a)):s(Ja,a))?this.V.U(null):I(this.V);return null!=a?new Xf(a,this.W):H};g.H=function(){return this};g.F=function(a,b){return new Xf(this.V,b)};g.G=function(a,b){return M(b,this)};function Ve(a){return(a=E(a))?new Xf(a,null):null}\nfunction cf(a){return Ta(a)}function Yf(a,b){this.V=a;this.W=b;this.q=0;this.i=32374988}g=Yf.prototype;g.toString=function(){return Lb(this)};g.D=function(){return this.W};g.U=function(){var a=this.V,a=(a?a.i&128||a.ob||(a.i?0:s(Ja,a)):s(Ja,a))?this.V.U(null):I(this.V);return null==a?null:new Yf(a,this.W)};g.B=function(){return cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.W)};g.N=function(a,b){return nc.a(b,this)};g.M=function(a,b,c){return nc.c(b,c,this)};g.Q=function(){return this.V.Q(null).ab(null)};\ng.S=function(){var a=this.V,a=(a?a.i&128||a.ob||(a.i?0:s(Ja,a)):s(Ja,a))?this.V.U(null):I(this.V);return null!=a?new Yf(a,this.W):H};g.H=function(){return this};g.F=function(a,b){return new Yf(this.V,b)};g.G=function(a,b){return M(b,this)};function We(a){return(a=E(a))?new Yf(a,null):null}function df(a){return Ua(a)}\nvar Zf=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return r(Ed(Fd,a))?C.a(function(a,b){return pc.a(r(a)?a:Ye,b)},a):null}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}();function $f(a,b,c){this.j=a;this.Sa=b;this.m=c;this.i=15077647;this.q=8196}g=$f.prototype;g.toString=function(){return Lb(this)};g.keys=function(){return Oe(E(this))};g.entries=function(){return Se(E(this))};g.values=function(){return Oe(E(this))};\ng.has=function(a){return Oc(this,a)};g.forEach=function(a){for(var b=E(this),c=null,d=0,e=0;;)if(e<d){var f=c.J(null,e),h=P.c(f,0,null),f=P.c(f,1,null);a.a?a.a(f,h):a.call(null,f,h);e+=1}else if(b=E(b))Ic(b)?(c=Hb(b),b=Ib(b),h=c,d=O(c),c=h):(c=F(b),h=P.c(c,0,null),f=P.c(c,1,null),a.a?a.a(f,h):a.call(null,f,h),b=I(b),c=null,d=0),e=0;else return null};g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){return Na(this.Sa,b)?b:c};g.D=function(){return this.j};g.L=function(){return Aa(this.Sa)};\ng.B=function(){var a=this.m;return null!=a?a:this.m=a=dc(this)};g.v=function(a,b){return Dc(b)&&O(this)===O(b)&&Dd(function(a){return function(b){return Oc(a,b)}}(this),b)};g.Wa=function(){return new ag(yb(this.Sa))};g.I=function(){return N(bg,this.j)};g.vb=function(a,b){return new $f(this.j,Qa(this.Sa,b),null)};g.H=function(){return Ve(this.Sa)};g.F=function(a,b){return new $f(b,this.Sa,this.m)};g.G=function(a,b){return new $f(this.j,R.c(this.Sa,b,null),null)};\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};var bg=new $f(null,Ye,0);function ag(a){this.la=a;this.i=259;this.q=136}g=ag.prototype;\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return La.c(this.la,c,Lc)===Lc?null:c;case 3:return La.c(this.la,c,Lc)===Lc?d:c}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return La.c(this.la,a,Lc)===Lc?null:a};g.a=function(a,b){return La.c(this.la,a,Lc)===Lc?b:a};g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){return La.c(this.la,b,Lc)===Lc?c:b};\ng.L=function(){return O(this.la)};g.Ob=function(a,b){this.la=yd.a(this.la,b);return this};g.Ka=function(a,b){this.la=xd.c(this.la,b,null);return this};g.Oa=function(){return new $f(null,Ab(this.la),null)};function cg(a,b,c){this.j=a;this.na=b;this.m=c;this.i=417730831;this.q=8192}g=cg.prototype;g.toString=function(){return Lb(this)};g.keys=function(){return Oe(E(this))};g.entries=function(){return Se(E(this))};g.values=function(){return Oe(E(this))};g.has=function(a){return Oc(this,a)};\ng.forEach=function(a){for(var b=E(this),c=null,d=0,e=0;;)if(e<d){var f=c.J(null,e),h=P.c(f,0,null),f=P.c(f,1,null);a.a?a.a(f,h):a.call(null,f,h);e+=1}else if(b=E(b))Ic(b)?(c=Hb(b),b=Ib(b),h=c,d=O(c),c=h):(c=F(b),h=P.c(c,0,null),f=P.c(c,1,null),a.a?a.a(f,h):a.call(null,f,h),b=I(b),c=null,d=0),e=0;else return null};g.u=function(a,b){return La.c(this,b,null)};g.C=function(a,b,c){a=Rf(this.na,b);return null!=a?a.key:c};g.D=function(){return this.j};g.L=function(){return O(this.na)};\ng.Xa=function(){return 0<O(this.na)?Kd.a(cf,pb(this.na)):null};g.B=function(){var a=this.m;return null!=a?a:this.m=a=dc(this)};g.v=function(a,b){return Dc(b)&&O(this)===O(b)&&Dd(function(a){return function(b){return Oc(a,b)}}(this),b)};g.I=function(){return N(dg,this.j)};g.vb=function(a,b){return new cg(this.j,tc.a(this.na,b),null)};g.H=function(){return Ve(this.na)};g.F=function(a,b){return new cg(b,this.na,this.m)};g.G=function(a,b){return new cg(this.j,R.c(this.na,b,null),null)};\ng.call=function(){var a=null;return a=function(a,c,d){switch(arguments.length){case 2:return this.u(null,c);case 3:return this.C(null,c,d)}throw Error(\"Invalid arity: \"+arguments.length);}}();g.apply=function(a,b){return this.call.apply(this,[this].concat(va(b)))};g.b=function(a){return this.u(null,a)};g.a=function(a,b){return this.C(null,a,b)};g.yb=function(a,b){return Kd.a(cf,qb(this.na,b))};g.zb=function(a,b,c){return Kd.a(cf,rb(this.na,b,c))};g.xb=function(a,b){return b};g.wb=function(){return tb(this.na)};\nvar dg=new cg(null,Sf,0);function eg(a){a=E(a);if(null==a)return bg;if(a instanceof ac&&0===a.p){a=a.e;a:{for(var b=0,c=yb(bg);;)if(b<a.length)var d=b+1,c=c.Ka(null,a[b]),b=d;else{a=c;break a}a=void 0}return a.Oa(null)}if(u)for(d=yb(bg);;)if(null!=a)b=a.U(null),d=d.Ka(null,a.Q(null)),a=b;else return d.Oa(null);else return null}\nvar fg=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return C.c(Da,dg,a)}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}(),gg=function(){function a(a,d){var e=null;1<arguments.length&&(e=J(Array.prototype.slice.call(arguments,1),0));return b.call(this,a,e)}function b(a,b){return C.c(Da,new cg(null,Wf(a),0),b)}a.k=1;a.f=function(a){var d=F(a);a=G(a);return b(d,a)};a.d=b;return a}();\nfunction hg(a){for(var b=qe;;)if(I(a))b=pc.a(b,F(a)),a=I(a);else return E(b)}function id(a){if(a&&(a.q&4096||a.fc))return a.name;if(\"string\"===typeof a)return a;throw Error(\"Doesn't support name: \"+A.b(a));}\nvar ig=function(){function a(a,b,c){return(a.b?a.b(b):a.call(null,b))>(a.b?a.b(c):a.call(null,c))?b:c}var b=null,c=function(){function a(b,d,k,l){var n=null;3<arguments.length&&(n=J(Array.prototype.slice.call(arguments,3),0));return c.call(this,b,d,k,n)}function c(a,d,e,l){return C.c(function(c,d){return b.c(a,c,d)},b.c(a,d,e),l)}a.k=3;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=I(a);var l=F(a);a=G(a);return c(b,d,l,a)};a.d=c;return a}(),b=function(b,e,f,h){switch(arguments.length){case 2:return e;\ncase 3:return a.call(this,b,e,f);default:return c.d(b,e,f,J(arguments,3))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=3;b.f=c.f;b.a=function(a,b){return b};b.c=a;b.d=c.d;return b}(),jg=function(){function a(a,b,f){return new V(null,function(){var h=E(f);return h?M(Md(a,h),c.c(a,b,Nd(b,h))):null},null,null)}function b(a,b){return c.c(a,a,b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);\n};c.a=b;c.c=a;return c}(),lg=function kg(b,c){return new V(null,function(){var d=E(c);return d?r(b.b?b.b(F(d)):b.call(null,F(d)))?M(F(d),kg(b,G(d))):null:null},null,null)};function mg(a,b,c){return function(d){var e=tb(a);return b.a?b.a(e.a?e.a(sb(a,d),c):e.call(null,sb(a,d),c),0):b.call(null,e.a?e.a(sb(a,d),c):e.call(null,sb(a,d),c),0)}}\nvar ng=function(){function a(a,b,c,h,k){var l=rb(a,c,!0);if(r(l)){var n=P.c(l,0,null);return lg(mg(a,h,k),r(mg(a,b,c).call(null,n))?l:I(l))}return null}function b(a,b,c){var h=mg(a,b,c),k;a:{k=[Uc,Vc];var l=k.length;if(l<=Ze)for(var n=0,q=yb(Ye);;)if(n<l)var t=n+1,q=Bb(q,k[n],null),n=t;else{k=new $f(null,Ab(q),null);break a}else for(n=0,q=yb(bg);;)if(n<l)t=n+1,q=zb(q,k[n]),n=t;else{k=Ab(q);break a}k=void 0}return r(k.call(null,b))?(a=rb(a,c,!0),r(a)?(b=P.c(a,0,null),r(h.b?h.b(b):h.call(null,b))?a:\nI(a)):null):lg(h,qb(a,!0))}var c=null,c=function(c,e,f,h,k){switch(arguments.length){case 3:return b.call(this,c,e,f);case 5:return a.call(this,c,e,f,h,k)}throw Error(\"Invalid arity: \"+arguments.length);};c.c=b;c.s=a;return c}();function og(a,b,c,d,e){this.j=a;this.start=b;this.end=c;this.step=d;this.m=e;this.i=32375006;this.q=8192}g=og.prototype;g.toString=function(){return Lb(this)};\ng.J=function(a,b){if(b<Aa(this))return this.start+b*this.step;if(this.start>this.end&&0===this.step)return this.start;throw Error(\"Index out of bounds\");};g.aa=function(a,b,c){return b<Aa(this)?this.start+b*this.step:this.start>this.end&&0===this.step?this.start:c};g.D=function(){return this.j};\ng.U=function(){return 0<this.step?this.start+this.step<this.end?new og(this.j,this.start+this.step,this.end,this.step,null):null:this.start+this.step>this.end?new og(this.j,this.start+this.step,this.end,this.step,null):null};g.L=function(){return sa(lb(this))?0:Math.ceil((this.end-this.start)/this.step)};g.B=function(){var a=this.m;return null!=a?a:this.m=a=cc(this)};g.v=function(a,b){return lc(this,b)};g.I=function(){return N(H,this.j)};g.N=function(a,b){return gc.a(this,b)};\ng.M=function(a,b,c){return gc.c(this,b,c)};g.Q=function(){return null==lb(this)?null:this.start};g.S=function(){return null!=lb(this)?new og(this.j,this.start+this.step,this.end,this.step,null):H};g.H=function(){return 0<this.step?this.start<this.end?this:null:this.start>this.end?this:null};g.F=function(a,b){return new og(b,this.start,this.end,this.step,this.m)};g.G=function(a,b){return M(b,this)};\nvar pg=function(){function a(a,b,c){return new og(null,a,b,c,null)}function b(a,b){return e.c(a,b,1)}function c(a){return e.c(0,a,1)}function d(){return e.c(0,Number.MAX_VALUE,1)}var e=null,e=function(e,h,k){switch(arguments.length){case 0:return d.call(this);case 1:return c.call(this,e);case 2:return b.call(this,e,h);case 3:return a.call(this,e,h,k)}throw Error(\"Invalid arity: \"+arguments.length);};e.o=d;e.b=c;e.a=b;e.c=a;return e}(),qg=function(){function a(a,b){for(;;)if(E(b)&&0<a){var c=a-1,h=\nI(b);a=c;b=h}else return null}function b(a){for(;;)if(E(a))a=I(a);else return null}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),rg=function(){function a(a,b){qg.a(a,b);return b}function b(a){qg.b(a);return a}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);\n};c.b=b;c.a=a;return c}();function sg(a,b){if(\"string\"===typeof b){var c=a.exec(b);return Wb.a(F(c),b)?1===O(c)?F(c):we(c):null}throw new TypeError(\"re-matches must match against a string.\");}function tg(a){var b;b=/^(?:\\(\\?([idmsux]*)\\))?(.*)/;if(\"string\"===typeof a)a=b.exec(a),b=null==a?null:1===O(a)?F(a):we(a);else throw new TypeError(\"re-find must match against a string.\");P.c(b,0,null);a=P.c(b,1,null);b=P.c(b,2,null);return new RegExp(b,a)}\nfunction ug(a,b,c,d,e,f,h){var k=ja;try{ja=null==ja?null:ja-1;if(null!=ja&&0>ja)return ub(a,\"#\");ub(a,c);E(h)&&(b.c?b.c(F(h),a,f):b.call(null,F(h),a,f));for(var l=I(h),n=ra.b(f)-1;;)if(!l||null!=n&&0===n){E(l)&&0===n&&(ub(a,d),ub(a,\"...\"));break}else{ub(a,d);b.c?b.c(F(l),a,f):b.call(null,F(l),a,f);var q=I(l);c=n-1;l=q;n=c}return ub(a,e)}finally{ja=k}}\nvar vg=function(){function a(a,d){var e=null;1<arguments.length&&(e=J(Array.prototype.slice.call(arguments,1),0));return b.call(this,a,e)}function b(a,b){for(var e=E(b),f=null,h=0,k=0;;)if(k<h){var l=f.J(null,k);ub(a,l);k+=1}else if(e=E(e))f=e,Ic(f)?(e=Hb(f),h=Ib(f),f=e,l=O(e),e=h,h=l):(l=F(f),ub(a,l),e=I(f),f=null,h=0),k=0;else return null}a.k=1;a.f=function(a){var d=F(a);a=G(a);return b(d,a)};a.d=b;return a}(),wg={'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\",\"\\b\":\"\\\\b\",\"\\f\":\"\\\\f\",\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\"};\nfunction xg(a){return'\"'+A.b(a.replace(RegExp('[\\\\\\\\\"\\b\\f\\n\\r\\t]',\"g\"),function(a){return wg[a]}))+'\"'}\nvar Ag=function yg(b,c,d){if(null==b)return ub(c,\"nil\");if(void 0===b)return ub(c,\"#\\x3cundefined\\x3e\");if(u){r(function(){var c=Q.a(d,pa);return r(c)?(c=b?b.i&131072||b.ec?!0:b.i?!1:s(bb,b):s(bb,b))?xc(b):c:c}())&&(ub(c,\"^\"),yg(xc(b),c,d),ub(c,\" \"));if(null==b)return ub(c,\"nil\");if(b.Db)return b.Tb(b,c,d);if(b&&(b.i&2147483648||b.K))return b.w(null,c,d);if(ta(b)===Boolean||\"number\"===typeof b)return ub(c,\"\"+A.b(b));if(null!=b&&b.constructor===Object)return ub(c,\"#js \"),zg.n?zg.n(Kd.a(function(c){return new W(null,\n2,5,X,[jd.b(c),b[c]],null)},Jc(b)),yg,c,d):zg.call(null,Kd.a(function(c){return new W(null,2,5,X,[jd.b(c),b[c]],null)},Jc(b)),yg,c,d);if(b instanceof Array)return ug(c,yg,\"#js [\",\" \",\"]\",d,b);if(\"string\"==typeof b)return r(oa.b(d))?ub(c,xg(b)):ub(c,b);if(uc(b))return vg.d(c,J([\"#\\x3c\",\"\"+A.b(b),\"\\x3e\"],0));if(b instanceof Date){var e=function(b,c){for(var d=\"\"+A.b(b);;)if(O(d)<c)d=\"0\"+A.b(d);else return d};return vg.d(c,J(['#inst \"',\"\"+A.b(b.getUTCFullYear()),\"-\",e(b.getUTCMonth()+1,2),\"-\",e(b.getUTCDate(),\n2),\"T\",e(b.getUTCHours(),2),\":\",e(b.getUTCMinutes(),2),\":\",e(b.getUTCSeconds(),2),\".\",e(b.getUTCMilliseconds(),3),\"-\",'00:00\"'],0))}return b instanceof RegExp?vg.d(c,J(['#\"',b.source,'\"'],0)):(b?b.i&2147483648||b.K||(b.i?0:s(vb,b)):s(vb,b))?wb(b,c,d):u?vg.d(c,J([\"#\\x3c\",\"\"+A.b(b),\"\\x3e\"],0)):null}return null};\nfunction Bg(a,b){var c=new ea;a:{var d=new Kb(c);Ag(F(a),d,b);for(var e=E(I(a)),f=null,h=0,k=0;;)if(k<h){var l=f.J(null,k);ub(d,\" \");Ag(l,d,b);k+=1}else if(e=E(e))f=e,Ic(f)?(e=Hb(f),h=Ib(f),f=e,l=O(e),e=h,h=l):(l=F(f),ub(d,\" \"),Ag(l,d,b),e=I(f),f=null,h=0),k=0;else break a}return c}\nvar Cg=function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){var b=ka();return Bc(a)?\"\":\"\"+A.b(Bg(a,b))}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}();function zg(a,b,c,d){return ug(c,function(a,c,d){b.c?b.c(Ta(a),c,d):b.call(null,Ta(a),c,d);ub(c,\" \");return b.c?b.c(Ua(a),c,d):b.call(null,Ua(a),c,d)},\"{\",\", \",\"}\",d,E(a))}ac.prototype.K=!0;\nac.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};V.prototype.K=!0;V.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};Bf.prototype.K=!0;Bf.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};vf.prototype.K=!0;vf.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};$.prototype.K=!0;$.prototype.w=function(a,b,c){return ug(b,Ag,\"[\",\" \",\"]\",c,this)};Ue.prototype.K=!0;Ue.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};\ncg.prototype.K=!0;cg.prototype.w=function(a,b,c){return ug(b,Ag,\"#{\",\" \",\"}\",c,this)};ye.prototype.K=!0;ye.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};gd.prototype.K=!0;gd.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};kc.prototype.K=!0;kc.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};xf.prototype.K=!0;xf.prototype.w=function(a,b,c){return zg(this,Ag,b,c)};wf.prototype.K=!0;wf.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};\nAe.prototype.K=!0;Ae.prototype.w=function(a,b,c){return ug(b,Ag,\"[\",\" \",\"]\",c,this)};Qf.prototype.K=!0;Qf.prototype.w=function(a,b,c){return zg(this,Ag,b,c)};$f.prototype.K=!0;$f.prototype.w=function(a,b,c){return ug(b,Ag,\"#{\",\" \",\"}\",c,this)};od.prototype.K=!0;od.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};Yf.prototype.K=!0;Yf.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};Y.prototype.K=!0;Y.prototype.w=function(a,b,c){return ug(b,Ag,\"[\",\" \",\"]\",c,this)};\nW.prototype.K=!0;W.prototype.w=function(a,b,c){return ug(b,Ag,\"[\",\" \",\"]\",c,this)};He.prototype.K=!0;He.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};cd.prototype.K=!0;cd.prototype.w=function(a,b){return ub(b,\"()\")};Ie.prototype.K=!0;Ie.prototype.w=function(a,b,c){return ug(b,Ag,\"#queue [\",\" \",\"]\",c,E(this))};la.prototype.K=!0;la.prototype.w=function(a,b,c){return zg(this,Ag,b,c)};og.prototype.K=!0;og.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};\nXf.prototype.K=!0;Xf.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};bd.prototype.K=!0;bd.prototype.w=function(a,b,c){return ug(b,Ag,\"(\",\" \",\")\",c,this)};W.prototype.lb=!0;W.prototype.mb=function(a,b){return Pc.a(this,b)};Ae.prototype.lb=!0;Ae.prototype.mb=function(a,b){return Pc.a(this,b)};T.prototype.lb=!0;T.prototype.mb=function(a,b){return Vb(this,b)};Zb.prototype.lb=!0;Zb.prototype.mb=function(a,b){return Vb(this,b)};\nfunction Dg(a,b){if(a?a.gc:a)return a.gc(a,b);var c;c=Dg[m(null==a?null:a)];if(!c&&(c=Dg._,!c))throw x(\"IReset.-reset!\",a);return c.call(null,a,b)}\nvar Eg=function(){function a(a,b,c,d,e){if(a?a.nc:a)return a.nc(a,b,c,d,e);var q;q=Eg[m(null==a?null:a)];if(!q&&(q=Eg._,!q))throw x(\"ISwap.-swap!\",a);return q.call(null,a,b,c,d,e)}function b(a,b,c,d){if(a?a.mc:a)return a.mc(a,b,c,d);var e;e=Eg[m(null==a?null:a)];if(!e&&(e=Eg._,!e))throw x(\"ISwap.-swap!\",a);return e.call(null,a,b,c,d)}function c(a,b,c){if(a?a.lc:a)return a.lc(a,b,c);var d;d=Eg[m(null==a?null:a)];if(!d&&(d=Eg._,!d))throw x(\"ISwap.-swap!\",a);return d.call(null,a,b,c)}function d(a,b){if(a?\na.kc:a)return a.kc(a,b);var c;c=Eg[m(null==a?null:a)];if(!c&&(c=Eg._,!c))throw x(\"ISwap.-swap!\",a);return c.call(null,a,b)}var e=null,e=function(e,h,k,l,n){switch(arguments.length){case 2:return d.call(this,e,h);case 3:return c.call(this,e,h,k);case 4:return b.call(this,e,h,k,l);case 5:return a.call(this,e,h,k,l,n)}throw Error(\"Invalid arity: \"+arguments.length);};e.a=d;e.c=c;e.n=b;e.s=a;return e}();function Fg(a,b,c,d){this.state=a;this.j=b;this.wc=c;this.Wb=d;this.i=2153938944;this.q=16386}g=Fg.prototype;\ng.B=function(){return this[ba]||(this[ba]=++ca)};g.Rb=function(a,b,c){a=E(this.Wb);for(var d=null,e=0,f=0;;)if(f<e){var h=d.J(null,f),k=P.c(h,0,null),h=P.c(h,1,null);h.n?h.n(k,this,b,c):h.call(null,k,this,b,c);f+=1}else if(a=E(a))Ic(a)?(d=Hb(a),a=Ib(a),k=d,e=O(d),d=k):(d=F(a),k=P.c(d,0,null),h=P.c(d,1,null),h.n?h.n(k,this,b,c):h.call(null,k,this,b,c),a=I(a),d=null,e=0),f=0;else return null};g.w=function(a,b,c){ub(b,\"#\\x3cAtom: \");Ag(this.state,b,c);return ub(b,\"\\x3e\")};g.D=function(){return this.j};\ng.ub=function(){return this.state};g.v=function(a,b){return this===b};\nvar Hg=function(){function a(a){return new Fg(a,null,null,null)}var b=null,c=function(){function a(c,d){var k=null;1<arguments.length&&(k=J(Array.prototype.slice.call(arguments,1),0));return b.call(this,c,k)}function b(a,c){var d=Mc(c)?S.a(Tf,c):c,e=Q.a(d,Gg),d=Q.a(d,pa);return new Fg(a,d,e,null)}a.k=1;a.f=function(a){var c=F(a);a=G(a);return b(c,a)};a.d=b;return a}(),b=function(b,e){switch(arguments.length){case 1:return a.call(this,b);default:return c.d(b,J(arguments,1))}throw Error(\"Invalid arity: \"+\narguments.length);};b.k=1;b.f=c.f;b.b=a;b.d=c.d;return b}();function Ig(a,b){if(a instanceof Fg){var c=a.wc;if(null!=c&&!r(c.b?c.b(b):c.call(null,b)))throw Error(\"Assert failed: Validator rejected reference state\\n\"+A.b(Cg.d(J([fd(new Zb(null,\"validate\",\"validate\",1439230700,null),new Zb(null,\"new-value\",\"new-value\",-1567397401,null))],0))));c=a.state;a.state=b;null!=a.Wb&&xb(a,c,b);return b}return Dg(a,b)}function K(a){return ab(a)}\nvar Jg=function(){function a(a,b,c,d){return a instanceof Fg?Ig(a,b.c?b.c(a.state,c,d):b.call(null,a.state,c,d)):Eg.n(a,b,c,d)}function b(a,b,c){return a instanceof Fg?Ig(a,b.a?b.a(a.state,c):b.call(null,a.state,c)):Eg.c(a,b,c)}function c(a,b){return a instanceof Fg?Ig(a,b.b?b.b(a.state):b.call(null,a.state)):Eg.a(a,b)}var d=null,e=function(){function a(c,d,e,f,t){var v=null;4<arguments.length&&(v=J(Array.prototype.slice.call(arguments,4),0));return b.call(this,c,d,e,f,v)}function b(a,c,d,e,f){return a instanceof\nFg?Ig(a,S.s(c,a.state,d,e,f)):Eg.s(a,c,d,e,f)}a.k=4;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=I(a);var e=F(a);a=I(a);var f=F(a);a=G(a);return b(c,d,e,f,a)};a.d=b;return a}(),d=function(d,h,k,l,n){switch(arguments.length){case 2:return c.call(this,d,h);case 3:return b.call(this,d,h,k);case 4:return a.call(this,d,h,k,l);default:return e.d(d,h,k,l,J(arguments,4))}throw Error(\"Invalid arity: \"+arguments.length);};d.k=4;d.f=e.f;d.a=c;d.c=b;d.n=a;d.d=e.d;return d}(),Kg={};\nfunction Lg(a){if(a?a.ac:a)return a.ac(a);var b;b=Lg[m(null==a?null:a)];if(!b&&(b=Lg._,!b))throw x(\"IEncodeJS.-clj-\\x3ejs\",a);return b.call(null,a)}function Mg(a){return(a?r(r(null)?null:a.$b)||(a.Cb?0:s(Kg,a)):s(Kg,a))?Lg(a):\"string\"===typeof a||\"number\"===typeof a||a instanceof T||a instanceof Zb?Ng.b?Ng.b(a):Ng.call(null,a):Cg.d(J([a],0))}\nvar Ng=function Og(b){if(null==b)return null;if(b?r(r(null)?null:b.$b)||(b.Cb?0:s(Kg,b)):s(Kg,b))return Lg(b);if(b instanceof T)return id(b);if(b instanceof Zb)return\"\"+A.b(b);if(Gc(b)){var c={};b=E(b);for(var d=null,e=0,f=0;;)if(f<e){var h=d.J(null,f),k=P.c(h,0,null),h=P.c(h,1,null);c[Mg(k)]=Og(h);f+=1}else if(b=E(b))Ic(b)?(e=Hb(b),b=Ib(b),d=e,e=O(e)):(e=F(b),d=P.c(e,0,null),e=P.c(e,1,null),c[Mg(d)]=Og(e),b=I(b),d=null,e=0),f=0;else break;return c}if(Cc(b)){c=[];b=E(Kd.a(Og,b));d=null;for(f=e=0;;)if(f<\ne)k=d.J(null,f),c.push(k),f+=1;else if(b=E(b))d=b,Ic(d)?(b=Hb(d),f=Ib(d),d=b,e=O(b),b=f):(b=F(d),c.push(b),b=I(d),d=null,e=0),f=0;else break;return c}return u?b:null},Pg={};function Qg(a,b){if(a?a.Zb:a)return a.Zb(a,b);var c;c=Qg[m(null==a?null:a)];if(!c&&(c=Qg._,!c))throw x(\"IEncodeClojure.-js-\\x3eclj\",a);return c.call(null,a,b)}\nvar Sg=function(){function a(a){return b.d(a,J([new la(null,1,[Rg,!1],null)],0))}var b=null,c=function(){function a(c,d){var k=null;1<arguments.length&&(k=J(Array.prototype.slice.call(arguments,1),0));return b.call(this,c,k)}function b(a,c){if(a?r(r(null)?null:a.Cc)||(a.Cb?0:s(Pg,a)):s(Pg,a))return Qg(a,S.a(Uf,c));if(E(c)){var d=Mc(c)?S.a(Tf,c):c,e=Q.a(d,Rg);return function(a,b,c,d){return function y(e){return Mc(e)?rg.b(Kd.a(y,e)):Cc(e)?Yd(qc(e),Kd.a(y,e)):e instanceof Array?we(Kd.a(y,e)):ta(e)===\nObject?Yd(Ye,function(){return function(a,b,c,d){return function Ra(f){return new V(null,function(a,b,c,d){return function(){for(;;){var a=E(f);if(a){if(Ic(a)){var b=Hb(a),c=O(b),h=new ld(Array(c),0);a:{for(var k=0;;)if(k<c){var l=D.a(b,k),l=new W(null,2,5,X,[d.b?d.b(l):d.call(null,l),y(e[l])],null);h.add(l);k+=1}else{b=!0;break a}b=void 0}return b?pd(h.da(),Ra(Ib(a))):pd(h.da(),null)}h=F(a);return M(new W(null,2,5,X,[d.b?d.b(h):d.call(null,h),y(e[h])],null),Ra(G(a)))}return null}}}(a,b,c,d),null,\nnull)}}(a,b,c,d)(Jc(e))}()):u?e:null}}(c,d,e,r(e)?jd:A)(a)}return null}a.k=1;a.f=function(a){var c=F(a);a=G(a);return b(c,a)};a.d=b;return a}(),b=function(b,e){switch(arguments.length){case 1:return a.call(this,b);default:return c.d(b,J(arguments,1))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=1;b.f=c.f;b.b=a;b.d=c.d;return b}();function Tg(a){this.pb=a;this.q=0;this.i=2153775104}\nTg.prototype.B=function(){for(var a=Cg.d(J([this],0)),b=0,c=0;c<a.length;++c)b=31*b+a.charCodeAt(c),b%=4294967296;return b};Tg.prototype.w=function(a,b){return ub(b,'#uuid \"'+A.b(this.pb)+'\"')};Tg.prototype.v=function(a,b){return b instanceof Tg&&this.pb===b.pb};Tg.prototype.toString=function(){return this.pb};var Ug=new T(null,\"ppath\",\"ppath\"),Vg=new T(\"zip\",\"branch?\",\"zip/branch?\"),Wg=new T(null,\"r\",\"r\"),Xg=new T(\"zip\",\"children\",\"zip/children\"),pa=new T(null,\"meta\",\"meta\"),qa=new T(null,\"dup\",\"dup\"),u=new T(null,\"else\",\"else\"),Gg=new T(null,\"validator\",\"validator\"),Yb=new T(null,\"default\",\"default\"),Yg=new T(null,\"sequential\",\"sequential\"),ma=new T(null,\"flush-on-newline\",\"flush-on-newline\"),Zg=new T(null,\"l\",\"l\"),$g=new T(\"zip\",\"make-node\",\"zip/make-node\"),oa=new T(null,\"readably\",\"readably\"),ra=new T(null,\n\"print-length\",\"print-length\"),ah=new T(null,\"pnodes\",\"pnodes\"),bh=new T(null,\"changed?\",\"changed?\"),ch=new T(null,\"tag\",\"tag\"),dh=new T(null,\"set\",\"set\"),eh=new T(null,\"end\",\"end\"),fh=new T(null,\"atom\",\"atom\"),Rg=new T(null,\"keywordize-keys\",\"keywordize-keys\"),gh=new T(null,\"map\",\"map\"),hh=new T(\"mori\",\"not-found\",\"mori/not-found\"),ih=new T(\"cljs.core\",\"not-found\",\"cljs.core/not-found\");var jh,kh;function lh(a){return a.o?a.o():a.call(null)}function mh(a){return a.o?a.o():a.call(null)}var nh=function(){function a(a,b,c){return Gc(c)?hb(c,a,b):null==c?b:c instanceof Array?hc.c(c,a,b):u?gb.c(c,a,b):null}function b(a,b){return c.c(a,a.o?a.o():a.call(null),b)}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}();\nfunction oh(a,b,c,d){if(a?a.Eb:a)return a.Eb(a,b,c,d);var e;e=oh[m(null==a?null:a)];if(!e&&(e=oh._,!e))throw x(\"CollFold.coll-fold\",a);return e.call(null,a,b,c,d)}\nvar qh=function ph(b,c){\"undefined\"===typeof jh&&(jh=function(b,c,f,h){this.$=b;this.Qa=c;this.uc=f;this.sc=h;this.q=0;this.i=917504},jh.Db=!0,jh.Bb=\"clojure.core.reducers/t6322\",jh.Tb=function(b,c){return ub(c,\"clojure.core.reducers/t6322\")},jh.prototype.N=function(b,c){return gb.c(this,c,c.o?c.o():c.call(null))},jh.prototype.M=function(b,c,f){return gb.c(this.Qa,this.$.b?this.$.b(c):this.$.call(null,c),f)},jh.prototype.D=function(){return this.sc},jh.prototype.F=function(b,c){return new jh(this.$,\nthis.Qa,this.uc,c)});return new jh(c,b,ph,null)},sh=function rh(b,c){\"undefined\"===typeof kh&&(kh=function(b,c,f,h){this.$=b;this.Qa=c;this.rc=f;this.tc=h;this.q=0;this.i=917504},kh.Db=!0,kh.Bb=\"clojure.core.reducers/t6328\",kh.Tb=function(b,c){return ub(c,\"clojure.core.reducers/t6328\")},kh.prototype.Eb=function(b,c,f,h){return oh(this.Qa,c,f,this.$.b?this.$.b(h):this.$.call(null,h))},kh.prototype.N=function(b,c){return gb.c(this.Qa,this.$.b?this.$.b(c):this.$.call(null,c),c.o?c.o():c.call(null))},\nkh.prototype.M=function(b,c,f){return gb.c(this.Qa,this.$.b?this.$.b(c):this.$.call(null,c),f)},kh.prototype.D=function(){return this.tc},kh.prototype.F=function(b,c){return new kh(this.$,this.Qa,this.rc,c)});return new kh(c,b,rh,null)},th=function(){function a(a,b){return sh(b,function(b){return function(){var c=null;return c=function(c,e,h){switch(arguments.length){case 0:return b.o?b.o():b.call(null);case 2:return b.a?b.a(c,a.b?a.b(e):a.call(null,e)):b.call(null,c,a.b?a.b(e):a.call(null,e));case 3:return b.a?\nb.a(c,a.a?a.a(e,h):a.call(null,e,h)):b.call(null,c,a.a?a.a(e,h):a.call(null,e,h))}throw Error(\"Invalid arity: \"+arguments.length);}}()})}function b(a){return function(b){return c.a(a,b)}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),uh=function(){function a(a,b){return sh(b,function(b){return function(){var c=null;return c=function(c,e,h){switch(arguments.length){case 0:return b.o?\nb.o():b.call(null);case 2:return r(a.b?a.b(e):a.call(null,e))?b.a?b.a(c,e):b.call(null,c,e):c;case 3:return r(a.a?a.a(e,h):a.call(null,e,h))?b.c?b.c(c,e,h):b.call(null,c,e,h):c}throw Error(\"Invalid arity: \"+arguments.length);}}()})}function b(a){return function(b){return c.a(a,b)}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),vh=function(){function a(a){return sh(a,\nfunction(a){return function(){var b=null;return b=function(b,d){switch(arguments.length){case 0:return a.o?a.o():a.call(null);case 2:return Fc(d)?c.b(d).M(null,a,b):a.a?a.a(b,d):a.call(null,b,d)}throw Error(\"Invalid arity: \"+arguments.length);}}()})}function b(){return function(a){return c.b(a)}}var c=null,c=function(c){switch(arguments.length){case 0:return b.call(this);case 1:return a.call(this,c)}throw Error(\"Invalid arity: \"+arguments.length);};c.o=b;c.b=a;return c}(),wh=function(){function a(a,\nb){return uh.a(Gd(a),b)}function b(a){return function(b){return c.a(a,b)}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),xh=function(){function a(a,b){return qh(b,function(b){return function(){var c=null;return c=function(c,e,h){switch(arguments.length){case 0:return b.o?b.o():b.call(null);case 2:return r(a.b?a.b(e):a.call(null,e))?b.a?b.a(c,e):b.call(null,c,e):\nnew ec(c);case 3:return r(a.a?a.a(e,h):a.call(null,e,h))?b.c?b.c(c,e,h):b.call(null,c,e,h):new ec(c)}throw Error(\"Invalid arity: \"+arguments.length);}}()})}function b(a){return function(b){return c.a(a,b)}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),yh=function(){function a(a,b){return qh(b,function(b){return function(a){return function(){var c=null;return c=\nfunction(c,d,e){switch(arguments.length){case 0:return b.o?b.o():b.call(null);case 2:return Jg.a(a,Wc),0>ab(a)?new ec(c):b.a?b.a(c,d):b.call(null,c,d);case 3:return Jg.a(a,Wc),0>ab(a)?new ec(c):b.c?b.c(c,d,e):b.call(null,c,d,e)}throw Error(\"Invalid arity: \"+arguments.length);}}()}(Hg.b(a))})}function b(a){return function(b){return c.a(a,b)}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);\n};c.b=b;c.a=a;return c}(),zh=function(){function a(a,b){return qh(b,function(b){return function(a){return function(){var c=null;return c=function(c,d,e){switch(arguments.length){case 0:return b.o?b.o():b.call(null);case 2:return Jg.a(a,Wc),0>ab(a)?b.a?b.a(c,d):b.call(null,c,d):c;case 3:return Jg.a(a,Wc),0>ab(a)?b.c?b.c(c,d,e):b.call(null,c,d,e):c}throw Error(\"Invalid arity: \"+arguments.length);}}()}(Hg.b(a))})}function b(a){return function(b){return c.a(a,b)}}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,\nc);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}(),Bh=function Ah(b,c,d,e){if(Bc(b))return d.o?d.o():d.call(null);if(O(b)<=c)return nh.c(e,d.o?d.o():d.call(null),b);if(u){var f=Yc(O(b)),h=ze.c(b,0,f);b=ze.c(b,f,O(b));return lh(function(b,c,e,f){return function(){var b=f(c),h;h=f(e);return d.a?d.a(b.o?b.o():b.call(null),mh(h)):d.call(null,b.o?b.o():b.call(null),mh(h))}}(f,h,b,function(b,f,h){return function(q){return function(){return function(){return Ah(q,\nc,d,e)}}(b,f,h)}}(f,h,b)))}return null};W.prototype.Eb=function(a,b,c,d){return Bh(this,b,c,d)};oh.object=function(a,b,c,d){return nh.c(d,c.o?c.o():c.call(null),a)};oh[\"null\"]=function(a,b,c){return c.o?c.o():c.call(null)};function Ch(a,b){var c=S.c(ig,a,b);return M(c,Vd(function(a){return function(b){return a===b}}(c),b))}\nvar Dh=function(){function a(a,b){return O(a)<O(b)?C.c(pc,b,a):C.c(pc,a,b)}var b=null,c=function(){function a(c,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,c,d,l)}function b(a,c,d){a=Ch(O,pc.d(d,c,J([a],0)));return C.c(Yd,F(a),G(a))}a.k=2;a.f=function(a){var c=F(a);a=I(a);var d=F(a);a=G(a);return b(c,d,a)};a.d=b;return a}(),b=function(b,e,f){switch(arguments.length){case 0:return bg;case 1:return b;case 2:return a.call(this,b,e);default:return c.d(b,\ne,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.o=function(){return bg};b.b=function(a){return a};b.a=a;b.d=c.d;return b}(),Eh=function(){function a(a,b){for(;;)if(O(b)<O(a)){var c=a;a=b;b=c}else return C.c(function(a,b){return function(a,c){return Oc(b,c)?a:Ac.a(a,c)}}(a,b),a,a)}var b=null,c=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){a=Ch(function(a){return-O(a)},\npc.d(e,d,J([a],0)));return C.c(b,F(a),G(a))}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=c.d;return b}(),Fh=function(){function a(a,b){return O(a)<O(b)?C.c(function(a,c){return Oc(b,c)?Ac.a(a,c):a},a,a):C.c(Ac,a,b)}var b=null,\nc=function(){function a(b,d,k){var l=null;2<arguments.length&&(l=J(Array.prototype.slice.call(arguments,2),0));return c.call(this,b,d,l)}function c(a,d,e){return C.c(b,a,pc.a(e,d))}a.k=2;a.f=function(a){var b=F(a);a=I(a);var d=F(a);a=G(a);return c(b,d,a)};a.d=c;return a}(),b=function(b,e,f){switch(arguments.length){case 1:return b;case 2:return a.call(this,b,e);default:return c.d(b,e,J(arguments,2))}throw Error(\"Invalid arity: \"+arguments.length);};b.k=2;b.f=c.f;b.b=function(a){return a};b.a=a;b.d=\nc.d;return b}();function Gh(a,b){return Wb.a(a,b)?new W(null,3,5,X,[null,null,a],null):new W(null,3,5,X,[a,b,null],null)}function Hh(a){return E(a)?C.c(function(a,c){var d=P.c(c,0,null),e=P.c(c,1,null);return R.c(a,d,e)},we(Od.a(S.a(Xc,Ve(a)),null)),a):null}\nfunction Ih(a,b,c){var d=Q.a(a,c),e=Q.a(b,c),f=Jh.a?Jh.a(d,e):Jh.call(null,d,e),h=P.c(f,0,null),k=P.c(f,1,null),f=P.c(f,2,null);a=Oc(a,c);b=Oc(b,c);d=a&&b&&(null!=f||null==d&&null==e);return new W(null,3,5,X,[!a||null==h&&d?null:new af([c,h]),!b||null==k&&d?null:new af([c,k]),d?new af([c,f]):null],null)}\nvar Kh=function(){function a(a,b,c){return C.c(function(a,b){return rg.b(Kd.c(Zf,a,b))},new W(null,3,5,X,[null,null,null],null),Kd.a(Id.c(Ih,a,b),c))}function b(a,b){return c.c(a,b,Dh.a(Ve(a),Ve(b)))}var c=null,c=function(c,e,f){switch(arguments.length){case 2:return b.call(this,c,e);case 3:return a.call(this,c,e,f)}throw Error(\"Invalid arity: \"+arguments.length);};c.a=b;c.c=a;return c}();\nfunction Lh(a,b){return we(Kd.a(Hh,Kh.c(Hc(a)?a:we(a),Hc(b)?b:we(b),pg.b(function(){var c=O(a),d=O(b);return c>d?c:d}()))))}function Mh(a,b){return new W(null,3,5,X,[Cd(Fh.a(a,b)),Cd(Fh.a(b,a)),Cd(Eh.a(a,b))],null)}function Nh(a){if(a?a.qc:a)return a.qc(a);var b;b=Nh[m(null==a?null:a)];if(!b&&(b=Nh._,!b))throw x(\"EqualityPartition.equality-partition\",a);return b.call(null,a)}\nfunction Oh(a,b){if(a?a.pc:a)return a.pc(a,b);var c;c=Oh[m(null==a?null:a)];if(!c&&(c=Oh._,!c))throw x(\"Diff.diff-similar\",a);return c.call(null,a,b)}Nh._=function(a){return(a?a.i&1024||a.cc||(a.i?0:s(Pa,a)):s(Pa,a))?gh:(a?a.i&4096||a.jc||(a.i?0:s(Va,a)):s(Va,a))?dh:(a?a.i&16777216||a.ic||(a.i?0:s(mb,a)):s(mb,a))?Yg:Yb?fh:null};Nh[\"boolean\"]=function(){return fh};Nh[\"function\"]=function(){return fh};Nh.array=function(){return Yg};Nh.number=function(){return fh};Nh.string=function(){return fh};\nNh[\"null\"]=function(){return fh};Oh._=function(a,b){return function(){switch(Nh(a)instanceof T?Nh(a).sa:null){case \"map\":return Kh;case \"sequential\":return Lh;case \"set\":return Mh;case \"atom\":return Gh;default:throw Error(\"No matching clause: \"+A.b(Nh(a)));}}().call(null,a,b)};Oh[\"boolean\"]=function(a,b){return Gh(a,b)};Oh[\"function\"]=function(a,b){return Gh(a,b)};Oh.array=function(a,b){return Lh(a,b)};Oh.number=function(a,b){return Gh(a,b)};Oh.string=function(a,b){return Gh(a,b)};\nOh[\"null\"]=function(a,b){return Gh(a,b)};function Jh(a,b){return Wb.a(a,b)?new W(null,3,5,X,[null,null,a],null):Wb.a(Nh(a),Nh(b))?Oh(a,b):Gh(a,b)};function Ph(a){if(a?a.Ub:a)return a.Ub();var b;b=Ph[m(null==a?null:a)];if(!b&&(b=Ph._,!b))throw x(\"PushbackReader.read-char\",a);return b.call(null,a)}function Qh(a,b){if(a?a.Vb:a)return a.Vb(0,b);var c;c=Qh[m(null==a?null:a)];if(!c&&(c=Qh._,!c))throw x(\"PushbackReader.unread\",a);return c.call(null,a,b)}function Rh(a,b,c){this.r=a;this.buffer=b;this.Fb=c}Rh.prototype.Ub=function(){return 0===this.buffer.length?(this.Fb+=1,this.r[this.Fb]):this.buffer.pop()};Rh.prototype.Vb=function(a,b){return this.buffer.push(b)};\nfunction Sh(a){var b=!/[^\\t\\n\\r ]/.test(a);return r(b)?b:\",\"===a}var Th=function(){function a(a,d){var e=null;1<arguments.length&&(e=J(Array.prototype.slice.call(arguments,1),0));return b.call(this,0,e)}function b(a,b){throw Error(S.a(A,b));}a.k=1;a.f=function(a){F(a);a=G(a);return b(0,a)};a.d=b;return a}();\nfunction Uh(a,b){for(var c=new ea(b),d=Ph(a);;){var e;if(!(e=null==d||Sh(d))){e=d;var f=\"#\"!==e;e=f?(f=\"'\"!==e)?(f=\":\"!==e)?Vh.b?Vh.b(e):Vh.call(null,e):f:f:f}if(e)return Qh(a,d),c.toString();c.append(d);d=Ph(a)}}function Wh(a){for(;;){var b=Ph(a);if(\"\\n\"===b||\"\\r\"===b||null==b)return a}}var Xh=tg(\"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+))(N)?$\"),Yh=tg(\"^([-+]?[0-9]+)/([0-9]+)$\"),Zh=tg(\"^([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?$\"),$h=tg(\"^[:]?([^0-9/].*/)?([^0-9/][^/]*)$\");\nfunction ai(a,b){var c=a.exec(b);return null!=c&&c[0]===b?1===c.length?c[0]:c:null}var bi=tg(\"^[0-9A-Fa-f]{2}$\"),ci=tg(\"^[0-9A-Fa-f]{4}$\");function di(a,b,c,d){return r(sg(a,d))?d:Th.d(b,J([\"Unexpected unicode escape \\\\\",c,d],0))}function ei(a){return String.fromCharCode(parseInt(a,16))}\nfunction fi(a){var b=Ph(a),c=\"t\"===b?\"\\t\":\"r\"===b?\"\\r\":\"n\"===b?\"\\n\":\"\\\\\"===b?\"\\\\\":'\"'===b?'\"':\"b\"===b?\"\\b\":\"f\"===b?\"\\f\":null;r(c)?a=c:\"x\"===b?(c=(new ea(Ph(a),Ph(a))).toString(),a=ei(di(bi,a,b,c))):\"u\"===b?(c=(new ea(Ph(a),Ph(a),Ph(a),Ph(a))).toString(),a=ei(di(ci,a,b,c))):a=/[^0-9]/.test(b)?u?Th.d(a,J([\"Unexpected unicode escape \\\\\",b],0)):null:String.fromCharCode(b);return a}\nfunction gi(a,b){for(var c=yb(qe);;){var d;a:{d=Sh;for(var e=b,f=Ph(e);;)if(r(d.b?d.b(f):d.call(null,f)))f=Ph(e);else{d=f;break a}d=void 0}r(d)||Th.d(b,J([\"EOF while reading\"],0));if(a===d)return Ab(c);e=Vh.b?Vh.b(d):Vh.call(null,d);r(e)?d=e.a?e.a(b,d):e.call(null,b,d):(Qh(b,d),d=hi.n?hi.n(b,!0,null,!0):hi.call(null,b,!0,null));c=d===b?c:wd.a(c,d)}}function ii(a,b){return Th.d(a,J([\"Reader for \",b,\" not implemented yet\"],0))}\nfunction ji(a,b){var c=Ph(a),d=ki.b?ki.b(c):ki.call(null,c);if(r(d))return d.a?d.a(a,b):d.call(null,a,b);d=li.a?li.a(a,c):li.call(null,a,c);return r(d)?d:Th.d(a,J([\"No dispatch macro for \",c],0))}function mi(a,b){return Th.d(a,J([\"Unmached delimiter \",b],0))}function ni(a){return S.a(fd,gi(\")\",a))}function oi(a){return gi(\"]\",a)}\nfunction pi(a){var b=gi(\"}\",a),c=O(b);if(\"number\"!==typeof c||isNaN(c)||Infinity===c||parseFloat(c)!==parseInt(c,10))throw Error(\"Argument must be an integer: \"+A.b(c));0!==(c&1)&&Th.d(a,J([\"Map literal must contain an even number of forms\"],0));return S.a(Tf,b)}function qi(a){for(var b=new ea,c=Ph(a);;){if(null==c)return Th.d(a,J([\"EOF while reading\"],0));if(\"\\\\\"===c)b.append(fi(a)),c=Ph(a);else{if('\"'===c)return b.toString();if(Yb)b.append(c),c=Ph(a);else return null}}}\nfunction ri(a){for(var b=new ea,c=Ph(a);;){if(null==c)return Th.d(a,J([\"EOF while reading\"],0));if(\"\\\\\"===c){b.append(c);var d=Ph(a);if(null==d)return Th.d(a,J([\"EOF while reading\"],0));var e=function(){var a=b;a.append(d);return a}(),f=Ph(a),b=e,c=f}else{if('\"'===c)return b.toString();if(u)e=function(){var a=b;a.append(c);return a}(),f=Ph(a),b=e,c=f;else return null}}}\nfunction si(a,b){var c=Uh(a,b);if(r(-1!=c.indexOf(\"/\")))c=$b.a(ad.c(c,0,c.indexOf(\"/\")),ad.c(c,c.indexOf(\"/\")+1,c.length));else var d=$b.b(c),c=\"nil\"===c?null:\"true\"===c?!0:\"false\"===c?!1:u?d:null;return c}function ti(a){var b=Uh(a,Ph(a)),c=ai($h,b),b=c[0],d=c[1],c=c[2];return void 0!==d&&\":/\"===d.substring(d.length-2,d.length)||\":\"===c[c.length-1]||-1!==b.indexOf(\"::\",1)?Th.d(a,J([\"Invalid token: \",b],0)):null!=d&&0<d.length?jd.a(d.substring(0,d.indexOf(\"/\")),c):jd.b(b)}\nfunction ui(a){return function(b){return Da(Da(H,hi.n?hi.n(b,!0,null,!0):hi.call(null,b,!0,null)),a)}}function vi(){return function(a){return Th.d(a,J([\"Unreadable form\"],0))}}\nfunction wi(a){var b;b=hi.n?hi.n(a,!0,null,!0):hi.call(null,a,!0,null);b=b instanceof Zb?new la(null,1,[ch,b],null):\"string\"===typeof b?new la(null,1,[ch,b],null):b instanceof T?new af([b,!0]):u?b:null;Gc(b)||Th.d(a,J([\"Metadata must be Symbol,Keyword,String or Map\"],0));var c=hi.n?hi.n(a,!0,null,!0):hi.call(null,a,!0,null);return(c?c.i&262144||c.oc||(c.i?0:s(db,c)):s(db,c))?N(c,Zf.d(J([xc(c),b],0))):Th.d(a,J([\"Metadata can only be applied to IWithMetas\"],0))}function xi(a){return eg(gi(\"}\",a))}\nfunction yi(a){return tg(ri(a))}function zi(a){hi.n?hi.n(a,!0,null,!0):hi.call(null,a,!0,null);return a}function Vh(a){return'\"'===a?qi:\":\"===a?ti:\";\"===a?Wh:\"'\"===a?ui(new Zb(null,\"quote\",\"quote\",1377916282,null)):\"@\"===a?ui(new Zb(null,\"deref\",\"deref\",1494944732,null)):\"^\"===a?wi:\"`\"===a?ii:\"~\"===a?ii:\"(\"===a?ni:\")\"===a?mi:\"[\"===a?oi:\"]\"===a?mi:\"{\"===a?pi:\"}\"===a?mi:\"\\\\\"===a?Ph:\"#\"===a?ji:null}function ki(a){return\"{\"===a?xi:\"\\x3c\"===a?vi():'\"'===a?yi:\"!\"===a?Wh:\"_\"===a?zi:null}\nfunction hi(a,b,c){for(;;){var d=Ph(a);if(null==d)return r(b)?Th.d(a,J([\"EOF while reading\"],0)):c;if(!Sh(d))if(\";\"===d)a=Wh.a?Wh.a(a,d):Wh.call(null,a);else if(u){var e=Vh(d);if(r(e))e=e.a?e.a(a,d):e.call(null,a,d);else{var e=a,f=void 0;!(f=!/[^0-9]/.test(d))&&(f=void 0,f=\"+\"===d||\"-\"===d)&&(f=Ph(e),Qh(e,f),f=!/[^0-9]/.test(f));if(f)a:{e=a;d=new ea(d);for(f=Ph(e);;){var h;h=null==f;h||(h=(h=Sh(f))?h:Vh.b?Vh.b(f):Vh.call(null,f));if(r(h)){Qh(e,f);f=d=d.toString();h=void 0;if(r(ai(Xh,f)))if(f=ai(Xh,\nf),null!=f[2])h=0;else{h=r(f[3])?[f[3],10]:r(f[4])?[f[4],16]:r(f[5])?[f[5],8]:r(f[6])?[f[7],parseInt(f[6],10)]:u?[null,null]:null;var k=h[0];null==k?h=null:(h=parseInt(k,h[1]),h=\"-\"===f[1]?-h:h)}else h=void 0,r(ai(Yh,f))?(f=ai(Yh,f),h=parseInt(f[1],10)/parseInt(f[2],10)):h=r(ai(Zh,f))?parseFloat(f):null;f=h;e=r(f)?f:Th.d(e,J([\"Invalid number format [\",d,\"]\"],0));break a}d.append(f);f=Ph(e)}e=void 0}else e=u?si(a,d):null}if(e!==a)return e}else return null}}\nfunction Ai(a){if(Wb.a(3,O(a)))return a;if(3<O(a))return ad.c(a,0,3);if(u)for(a=new ea(a);;)if(3>a.Va.length)a=a.append(\"0\");else return a.toString();else return null}var Bi=function(a,b){return function(c,d){return Q.a(r(d)?b:a,c)}}(new W(null,13,5,X,[null,31,28,31,30,31,30,31,31,30,31,30,31],null),new W(null,13,5,X,[null,31,29,31,30,31,30,31,31,30,31,30,31],null)),Ci=/(\\d\\d\\d\\d)(?:-(\\d\\d)(?:-(\\d\\d)(?:[T](\\d\\d)(?::(\\d\\d)(?::(\\d\\d)(?:[.](\\d+))?)?)?)?)?)?(?:[Z]|([-+])(\\d\\d):(\\d\\d))?/;\nfunction Di(a){a=parseInt(a,10);return sa(isNaN(a))?a:null}function Ei(a,b,c,d){a<=b&&b<=c||Th.d(null,J([\"\"+A.b(d)+\" Failed:  \"+A.b(a)+\"\\x3c\\x3d\"+A.b(b)+\"\\x3c\\x3d\"+A.b(c)],0));return b}\nfunction Fi(a){var b=sg(Ci,a);P.c(b,0,null);var c=P.c(b,1,null),d=P.c(b,2,null),e=P.c(b,3,null),f=P.c(b,4,null),h=P.c(b,5,null),k=P.c(b,6,null),l=P.c(b,7,null),n=P.c(b,8,null),q=P.c(b,9,null),t=P.c(b,10,null);if(sa(b))return Th.d(null,J([\"Unrecognized date/time syntax: \"+A.b(a)],0));a=Di(c);var b=function(){var a=Di(d);return r(a)?a:1}(),c=function(){var a=Di(e);return r(a)?a:1}(),v=function(){var a=Di(f);return r(a)?a:0}(),w=function(){var a=Di(h);return r(a)?a:0}(),y=function(){var a=Di(k);return r(a)?\na:0}(),B=function(){var a=Di(Ai(l));return r(a)?a:0}(),n=(Wb.a(n,\"-\")?-1:1)*(60*function(){var a=Di(q);return r(a)?a:0}()+function(){var a=Di(t);return r(a)?a:0}());return new W(null,8,5,X,[a,Ei(1,b,12,\"timestamp month field must be in range 1..12\"),Ei(1,c,Bi.a?Bi.a(b,0===(a%4+4)%4&&(0!==(a%100+100)%100||0===(a%400+400)%400)):Bi.call(null,b,0===(a%4+4)%4&&(0!==(a%100+100)%100||0===(a%400+400)%400)),\"timestamp day field must be in range 1..last day in month\"),Ei(0,v,23,\"timestamp hour field must be in range 0..23\"),\nEi(0,w,59,\"timestamp minute field must be in range 0..59\"),Ei(0,y,Wb.a(w,59)?60:59,\"timestamp second field must be in range 0..60\"),Ei(0,B,999,\"timestamp millisecond field must be in range 0..999\"),n],null)}\nvar Gi=Hg.b(new la(null,4,[\"inst\",function(a){var b;if(\"string\"===typeof a)if(b=Fi(a),r(b)){a=P.c(b,0,null);var c=P.c(b,1,null),d=P.c(b,2,null),e=P.c(b,3,null),f=P.c(b,4,null),h=P.c(b,5,null),k=P.c(b,6,null);b=P.c(b,7,null);b=new Date(Date.UTC(a,c-1,d,e,f,h,k)-6E4*b)}else b=Th.d(null,J([\"Unrecognized date/time syntax: \"+A.b(a)],0));else b=Th.d(null,J([\"Instance literal expects a string for its timestamp.\"],0));return b},\"uuid\",function(a){return\"string\"===typeof a?new Tg(a):Th.d(null,J([\"UUID literal expects a string as its representation.\"],\n0))},\"queue\",function(a){return Hc(a)?Yd(Je,a):Th.d(null,J([\"Queue literal expects a vector for its elements.\"],0))},\"js\",function(a){if(Hc(a)){var b=[];a=E(a);for(var c=null,d=0,e=0;;)if(e<d){var f=c.J(null,e);b.push(f);e+=1}else if(a=E(a))c=a,Ic(c)?(a=Hb(c),e=Ib(c),c=a,d=O(a),a=e):(a=F(c),b.push(a),a=I(c),c=null,d=0),e=0;else break;return b}if(Gc(a)){b={};a=E(a);c=null;for(e=d=0;;)if(e<d){var h=c.J(null,e),f=P.c(h,0,null),h=P.c(h,1,null);b[id(f)]=h;e+=1}else if(a=E(a))Ic(a)?(d=Hb(a),a=Ib(a),c=d,\nd=O(d)):(d=F(a),c=P.c(d,0,null),d=P.c(d,1,null),b[id(c)]=d,a=I(a),c=null,d=0),e=0;else break;return b}return u?Th.d(null,J([\"JS literal expects a vector or map containing only string or unqualified keyword keys\"],0)):null}],null)),Hi=Hg.b(null);\nfunction li(a,b){var c=si(a,b),d=Q.a(ab(Gi),\"\"+A.b(c)),e=ab(Hi);return r(d)?d.b?d.b(hi(a,!0,null)):d.call(null,hi(a,!0,null)):r(e)?e.a?e.a(c,hi(a,!0,null)):e.call(null,c,hi(a,!0,null)):u?Th.d(a,J([\"Could not find tag parser for \",\"\"+A.b(c),\" in \",Cg.d(J([Ve(ab(Gi))],0))],0)):null};p(\"mori.apply\",S);p(\"mori.count\",O);p(\"mori.distinct\",function(a){return function c(a,e){return new V(null,function(){return function(a,d){for(;;){var e=a,l=P.c(e,0,null);if(e=E(e))if(Oc(d,l))l=G(e),e=d,a=l,d=e;else return M(l,c(G(e),pc.a(d,l)));else return null}}.call(null,a,e)},null,null)}(a,bg)});p(\"mori.empty\",qc);p(\"mori.first\",F);p(\"mori.rest\",G);p(\"mori.seq\",E);p(\"mori.conj\",pc);p(\"mori.cons\",M);\np(\"mori.find\",function(a,b){return null!=a&&Ec(a)&&Oc(a,b)?new W(null,2,5,X,[b,Q.a(a,b)],null):null});p(\"mori.nth\",P);p(\"mori.last\",oc);p(\"mori.assoc\",R);p(\"mori.dissoc\",tc);p(\"mori.get_in\",$d);p(\"mori.update_in\",ae);p(\"mori.assoc_in\",function Ii(b,c,d){var e=P.c(c,0,null);return(c=$c(c))?R.c(b,e,Ii(Q.a(b,e),c,d)):R.c(b,e,d)});p(\"mori.fnil\",Jd);p(\"mori.disj\",Ac);p(\"mori.pop\",zc);p(\"mori.peek\",yc);p(\"mori.hash\",Tb);p(\"mori.get\",Q);p(\"mori.has_key\",Oc);p(\"mori.is_empty\",Bc);p(\"mori.reverse\",ed);\np(\"mori.take\",Md);p(\"mori.drop\",Nd);p(\"mori.take_nth\",function Ji(b,c){return new V(null,function(){var d=E(c);return d?M(F(d),Ji(b,Nd(b,d))):null},null,null)});p(\"mori.partition\",Zd);p(\"mori.partition_all\",jg);p(\"mori.partition_by\",function Ki(b,c){return new V(null,function(){var d=E(c);if(d){var e=F(d),f=b.b?b.b(e):b.call(null,e),e=M(e,lg(function(c,d){return function(c){return Wb.a(d,b.b?b.b(c):b.call(null,c))}}(e,f,d,d),I(d)));return M(e,Ki(b,E(Nd(O(e),d))))}return null},null,null)});\np(\"mori.iterate\",function Li(b,c){return M(c,new V(null,function(){return Li(b,b.b?b.b(c):b.call(null,c))},null,null))});p(\"mori.into\",Yd);p(\"mori.merge\",Zf);p(\"mori.subvec\",ze);p(\"mori.take_while\",lg);p(\"mori.drop_while\",function(a,b){return new V(null,function(c){return function(){return c(a,b)}}(function(a,b){for(;;){var e=E(b),f;f=(f=e)?a.b?a.b(F(e)):a.call(null,F(e)):f;if(r(f))f=a,e=G(e),a=f,b=e;else return e}}),null,null)});\np(\"mori.group_by\",function(a,b){return C.c(function(b,d){var e=a.b?a.b(d):a.call(null,d);return R.c(b,e,pc.a(Q.c(b,e,qe),d))},Ye,b)});p(\"mori.interpose\",function(a,b){return Nd(1,Qd.a(Od.b(a),b))});p(\"mori.interleave\",Qd);p(\"mori.concat\",td);p(\"mori.conj1\",function(a,b){return a.G(null,b)});function Xd(a){return a instanceof Array||Fc(a)}p(\"mori.flatten\",function(a){return Ud(function(a){return!Xd(a)},G(Wd(a)))});p(\"mori.lazy_seq\",function(a){return new V(null,a,null,null)});p(\"mori.keys\",Ve);\np(\"mori.select_keys\",function(a,b){for(var c=Ye,d=E(b);;)if(d)var e=F(d),f=Q.c(a,e,ih),c=Bd.a(f,ih)?R.c(c,e,f):c,d=I(d);else return c});p(\"mori.vals\",We);p(\"mori.prim_seq\",mc);p(\"mori.map\",Kd);p(\"mori.mapcat\",Sd);p(\"mori.reduce\",C);p(\"mori.reduce_kv\",function(a,b,c){return null!=c?hb(c,a,b):b});p(\"mori.filter\",Ud);p(\"mori.remove\",Vd);p(\"mori.some\",Ed);p(\"mori.every\",Dd);p(\"mori.equals\",Wb);p(\"mori.range\",pg);p(\"mori.repeat\",Od);p(\"mori.repeatedly\",Pd);p(\"mori.sort\",Sc);p(\"mori.sort_by\",Tc);\np(\"mori.into_array\",xa);p(\"mori.subseq\",ng);p(\"mori.rmap\",th);p(\"mori.rfilter\",uh);p(\"mori.rremove\",wh);p(\"mori.rtake\",yh);p(\"mori.rtake_while\",xh);p(\"mori.rdrop\",zh);p(\"mori.rflatten\",vh);p(\"mori.list\",fd);p(\"mori.vector\",xe);p(\"mori.array_map\",Uf);p(\"mori.hash_map\",Tf);p(\"mori.set\",eg);p(\"mori.sorted_set\",fg);p(\"mori.sorted_set_by\",gg);p(\"mori.sorted_map\",Vf);p(\"mori.sorted_map_by\",Wf);\np(\"mori.queue\",function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return Yd.a?Yd.a(Je,a):Yd.call(null,Je,a)}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}());p(\"mori.keyword\",jd);p(\"mori.symbol\",$b);p(\"mori.zipmap\",function(a,b){for(var c=yb(Ye),d=E(a),e=E(b);;)if(d&&e)c=xd.c(c,F(d),F(e)),d=I(d),e=I(e);else return Ab(c)});\np(\"mori.is_list\",function(a){return a?a.i&33554432||a.Ec?!0:a.i?!1:s(nb,a):s(nb,a)});p(\"mori.is_seq\",Mc);p(\"mori.is_vector\",Hc);p(\"mori.is_map\",Gc);p(\"mori.is_set\",Dc);p(\"mori.is_keyword\",function(a){return a instanceof T});p(\"mori.is_symbol\",function(a){return a instanceof Zb});p(\"mori.is_collection\",Cc);p(\"mori.is_sequential\",Fc);p(\"mori.is_associative\",Ec);p(\"mori.is_counted\",ic);p(\"mori.is_indexed\",jc);p(\"mori.is_reduceable\",function(a){return a?a.i&524288||a.Nb?!0:a.i?!1:s(fb,a):s(fb,a)});\np(\"mori.is_seqable\",function(a){return a?a.i&8388608||a.hc?!0:a.i?!1:s(kb,a):s(kb,a)});p(\"mori.is_reversible\",dd);p(\"mori.union\",Dh);p(\"mori.intersection\",Eh);p(\"mori.difference\",Fh);p(\"mori.is_subset\",function(a,b){return O(a)<=O(b)&&Dd(function(a){return Oc(b,a)},a)});p(\"mori.is_superset\",function(a,b){return O(a)>=O(b)&&Dd(function(b){return Oc(a,b)},b)});p(\"mori.partial\",Id);p(\"mori.comp\",Hd);\np(\"mori.pipeline\",function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return C.a?C.a(function(a,b){return b.b?b.b(a):b.call(null,a)},a):C.call(null,function(a,b){return b.b?b.b(a):b.call(null,a)},a)}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}());\np(\"mori.curry\",function(){function a(a,d){var e=null;1<arguments.length&&(e=J(Array.prototype.slice.call(arguments,1),0));return b.call(this,a,e)}function b(a,b){return function(e){return S.a(a,M.a?M.a(e,b):M.call(null,e,b))}}a.k=1;a.f=function(a){var d=F(a);a=G(a);return b(d,a)};a.d=b;return a}());\np(\"mori.juxt\",function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return function(){function b(a){var c=null;0<arguments.length&&(c=J(Array.prototype.slice.call(arguments,0),0));return e.call(this,c)}function e(b){return xa.b?xa.b(Kd.a?Kd.a(function(a){return S.a(a,b)},a):Kd.call(null,function(a){return S.a(a,b)},a)):xa.call(null,Kd.a?Kd.a(function(a){return S.a(a,b)},a):Kd.call(null,function(a){return S.a(a,\nb)},a))}b.k=0;b.f=function(a){a=E(a);return e(a)};b.d=e;return b}()}a.k=0;a.f=function(a){a=E(a);return b(a)};a.d=b;return a}());\np(\"mori.knit\",function(){function a(a){var d=null;0<arguments.length&&(d=J(Array.prototype.slice.call(arguments,0),0));return b.call(this,d)}function b(a){return function(b){return xa.b?xa.b(Kd.c?Kd.c(function(a,b){return a.b?a.b(b):a.call(null,b)},a,b):Kd.call(null,function(a,b){return a.b?a.b(b):a.call(null,b)},a,b)):xa.call(null,Kd.c?Kd.c(function(a,b){return a.b?a.b(b):a.call(null,b)},a,b):Kd.call(null,function(a,b){return a.b?a.b(b):a.call(null,b)},a,b))}}a.k=0;a.f=function(a){a=E(a);return b(a)};\na.d=b;return a}());p(\"mori.diff\",Jh);p(\"mori.sum\",function(a,b){return a+b});p(\"mori.inc\",function(a){return a+1});p(\"mori.dec\",function(a){return a-1});p(\"mori.is_even\",function(a){return 0===(a%2+2)%2});p(\"mori.is_odd\",function(a){return 1===(a%2+2)%2});p(\"mori.each\",function(a,b){for(var c=E(a),d=null,e=0,f=0;;)if(f<e){var h=d.J(null,f);b.b?b.b(h):b.call(null,h);f+=1}else if(c=E(c))d=c,Ic(d)?(c=Hb(d),e=Ib(d),d=c,h=O(c),c=e,e=h):(h=F(d),b.b?b.b(h):b.call(null,h),c=I(d),d=null,e=0),f=0;else return null});\np(\"mori.identity\",Fd);p(\"mori.constantly\",function(a){return function(){function b(b){0<arguments.length&&J(Array.prototype.slice.call(arguments,0),0);return a}b.k=0;b.f=function(b){E(b);return a};b.d=function(){return a};return b}()});p(\"mori.clj_to_js\",Ng);\np(\"mori.js_to_clj\",function(){function a(a,b){return Sg.d(a,J([Rg,b],0))}function b(a){return Sg.b(a)}var c=null,c=function(c,e){switch(arguments.length){case 1:return b.call(this,c);case 2:return a.call(this,c,e)}throw Error(\"Invalid arity: \"+arguments.length);};c.b=b;c.a=a;return c}());p(\"mori.parse\",function(a){return hi(new Rh(a,[],-1),!1,null)});\np(\"mori.configure\",function(a,b){switch(a){case \"print-length\":return ia=b;case \"print-level\":return ja=b;default:throw Error(\"No matching clause: \"+A.b(a));}});\np(\"mori.proxy\",function(a){if(\"undefined\"!==typeof Proxy)return Proxy.create(function(){return{has:function(b){return Oc(a,b)},hasOwn:function(b){return Oc(a,b)},get:function(b,c){var d=Q.c?Q.c(a,c,hh):Q.call(null,a,c,hh);return hd(d,hh)?ic(a)&&\"length\"===c?O.b?O.b(a):O.call(null,a):null:u?d:null},set:function(){return null},enumerate:function(){return xa.b?xa.b(Ve.b?Ve.b(a):Ve.call(null,a)):xa.call(null,Ve.b?Ve.b(a):Ve.call(null,a))},keys:function(){return Gc(a)?xa.b?xa.b(Ve.b?Ve.b(a):Ve.call(null,\na)):xa.call(null,Ve.b?Ve.b(a):Ve.call(null,a)):Hc(a)?xa.b?xa.b(pg.b?pg.b(O.b?O.b(a):O.call(null,a)):pg.call(null,O.b?O.b(a):O.call(null,a))):xa.call(null,pg.b?pg.b(O.b?O.b(a):O.call(null,a)):pg.call(null,O.b?O.b(a):O.call(null,a))):null}}}());throw Error(\"ES6 Proxy not supported!\");});V.prototype.inspect=function(){return this.toString()};ac.prototype.inspect=function(){return this.toString()};kc.prototype.inspect=function(){return this.toString()};Bf.prototype.inspect=function(){return this.toString()};\nvf.prototype.inspect=function(){return this.toString()};wf.prototype.inspect=function(){return this.toString()};bd.prototype.inspect=function(){return this.toString()};gd.prototype.inspect=function(){return this.toString()};cd.prototype.inspect=function(){return this.toString()};W.prototype.inspect=function(){return this.toString()};od.prototype.inspect=function(){return this.toString()};ye.prototype.inspect=function(){return this.toString()};Ae.prototype.inspect=function(){return this.toString()};\n$.prototype.inspect=function(){return this.toString()};Y.prototype.inspect=function(){return this.toString()};la.prototype.inspect=function(){return this.toString()};xf.prototype.inspect=function(){return this.toString()};Qf.prototype.inspect=function(){return this.toString()};$f.prototype.inspect=function(){return this.toString()};cg.prototype.inspect=function(){return this.toString()};og.prototype.inspect=function(){return this.toString()};T.prototype.inspect=function(){return this.toString()};\nZb.prototype.inspect=function(){return this.toString()};Ie.prototype.inspect=function(){return this.toString()};He.prototype.inspect=function(){return this.toString()};p(\"mori._equiv\",function(a,b){return a.Hc(b)});p(\"mori._keys\",function(a){return a.keys()});p(\"mori._values\",function(a){return a.values()});p(\"mori._entries\",function(a){return a.entries()});p(\"mori._has\",function(a){return a.has()});p(\"mori._get\",function(a){return a.get()});p(\"mori._forEach\",function(a){return a.forEach()});\np(\"mori._next\",function(a){return a.next()});p(\"mori.mutable.thaw\",function(a){return yb(a)});p(\"mori.mutable.freeze\",vd);p(\"mori.mutable.conj1\",function(a,b){return a.Ka(null,b)});p(\"mori.mutable.conj\",wd);p(\"mori.mutable.assoc\",xd);p(\"mori.mutable.dissoc\",yd);p(\"mori.mutable.pop\",function(a){return Eb(a)});p(\"mori.mutable.disj\",zd);function Mi(a,b,c,d){return N(new W(null,2,5,X,[d,null],null),new la(null,3,[$g,c,Xg,b,Vg,a],null))}function Ni(a){return a.b?a.b(0):a.call(null,0)}function Oi(a){return Vg.b(xc(a)).call(null,Ni(a))}function Pi(a){if(r(Oi(a)))return Xg.b(xc(a)).call(null,Ni(a));throw\"called children on a leaf node\";}function Qi(a,b,c){return $g.b(xc(a)).call(null,b,c)}\nfunction Ri(a){if(r(Oi(a))){var b=P.c(a,0,null),c=P.c(a,1,null),d=Pi(a),e=P.c(d,0,null),f=$c(d);return r(d)?N(new W(null,2,5,X,[e,new la(null,4,[Zg,qe,ah,r(c)?pc.a(ah.b(c),b):new W(null,1,5,X,[b],null),Ug,c,Wg,f],null)],null),xc(a)):null}return null}\nfunction Si(a){var b=P.c(a,0,null),c=P.c(a,1,null),d=Mc(c)?S.a(Tf,c):c,c=Q.a(d,Zg),e=Q.a(d,Ug),f=Q.a(d,ah),h=Q.a(d,Wg),d=Q.a(d,bh);return r(f)?(f=yc(f),N(r(d)?new W(null,2,5,X,[Qi(a,f,td.a(c,M(b,h))),r(e)?R.c(e,bh,!0):e],null):new W(null,2,5,X,[f,e],null),xc(a))):null}function Ti(a){var b=P.c(a,0,null),c=P.c(a,1,null),c=Mc(c)?S.a(Tf,c):c,d=Q.a(c,Zg),e=Q.a(c,Wg),f=P.c(e,0,null),h=$c(e);return r(r(c)?e:c)?N(new W(null,2,5,X,[f,R.d(c,Zg,pc.a(d,b),J([Wg,h],0))],null),xc(a)):null}\nfunction Ui(a){var b=P.c(a,0,null),c=P.c(a,1,null),c=Mc(c)?S.a(Tf,c):c,d=Q.a(c,Zg),e=Q.a(c,Wg);return r(r(c)?e:c)?N(new W(null,2,5,X,[oc(e),R.d(c,Zg,S.n(pc,d,b,hg(e)),J([Wg,null],0))],null),xc(a)):a}function Vi(a){var b=P.c(a,0,null),c=P.c(a,1,null),c=Mc(c)?S.a(Tf,c):c,d=Q.a(c,Zg),e=Q.a(c,Wg);return r(r(c)?E(d):c)?N(new W(null,2,5,X,[yc(d),R.d(c,Zg,zc(d),J([Wg,M(b,e)],0))],null),xc(a)):null}\nfunction Wi(a,b){P.c(a,0,null);var c=P.c(a,1,null);return N(new W(null,2,5,X,[b,R.c(c,bh,!0)],null),xc(a))}var Xi=function(){function a(a,d,e){var f=null;2<arguments.length&&(f=J(Array.prototype.slice.call(arguments,2),0));return b.call(this,a,d,f)}function b(a,b,e){return Wi(a,S.c(b,Ni(a),e))}a.k=2;a.f=function(a){var d=F(a);a=I(a);var e=F(a);a=G(a);return b(d,e,a)};a.d=b;return a}();p(\"mori.zip.zipper\",Mi);p(\"mori.zip.seq_zip\",function(a){return Mi(Mc,Fd,function(a,c){return N(c,xc(a))},a)});p(\"mori.zip.vector_zip\",function(a){return Mi(Hc,E,function(a,c){return N(we(c),xc(a))},a)});p(\"mori.zip.node\",Ni);p(\"mori.zip.is_branch\",{}.xc);p(\"mori.zip.children\",Pi);p(\"mori.zip.make_node\",Qi);p(\"mori.zip.path\",function(a){return ah.b(a.b?a.b(1):a.call(null,1))});p(\"mori.zip.lefts\",function(a){return E(Zg.b(a.b?a.b(1):a.call(null,1)))});\np(\"mori.zip.rights\",function(a){return Wg.b(a.b?a.b(1):a.call(null,1))});p(\"mori.zip.down\",Ri);p(\"mori.zip.up\",Si);p(\"mori.zip.root\",function(a){for(;;){if(Wb.a(eh,a.b?a.b(1):a.call(null,1)))return Ni(a);var b=Si(a);if(r(b))a=b;else return Ni(a)}});p(\"mori.zip.right\",Ti);p(\"mori.zip.rightmost\",Ui);p(\"mori.zip.left\",Vi);\np(\"mori.zip.leftmost\",function(a){var b=P.c(a,0,null),c=P.c(a,1,null),c=Mc(c)?S.a(Tf,c):c,d=Q.a(c,Zg),e=Q.a(c,Wg);return r(r(c)?E(d):c)?N(new W(null,2,5,X,[F(d),R.d(c,Zg,qe,J([Wg,td.d(G(d),new W(null,1,5,X,[b],null),J([e],0))],0))],null),xc(a)):a});p(\"mori.zip.insert_left\",function(a,b){var c=P.c(a,0,null),d=P.c(a,1,null),d=Mc(d)?S.a(Tf,d):d,e=Q.a(d,Zg);if(null==d)throw\"Insert at top\";return N(new W(null,2,5,X,[c,R.d(d,Zg,pc.a(e,b),J([bh,!0],0))],null),xc(a))});\np(\"mori.zip.insert_right\",function(a,b){var c=P.c(a,0,null),d=P.c(a,1,null),d=Mc(d)?S.a(Tf,d):d,e=Q.a(d,Wg);if(null==d)throw\"Insert at top\";return N(new W(null,2,5,X,[c,R.d(d,Wg,M(b,e),J([bh,!0],0))],null),xc(a))});p(\"mori.zip.replace\",Wi);p(\"mori.zip.edit\",Xi);p(\"mori.zip.insert_child\",function(a,b){return Wi(a,Qi(a,Ni(a),M(b,Pi(a))))});p(\"mori.zip.append_child\",function(a,b){return Wi(a,Qi(a,Ni(a),td.a(Pi(a),new W(null,1,5,X,[b],null))))});\np(\"mori.zip.next\",function(a){if(Wb.a(eh,a.b?a.b(1):a.call(null,1)))return a;var b;b=Oi(a);b=r(b)?Ri(a):b;if(r(b))return b;b=Ti(a);if(r(b))return b;for(;;)if(r(Si(a))){b=Ti(Si(a));if(r(b))return b;a=Si(a)}else return new W(null,2,5,X,[Ni(a),eh],null)});p(\"mori.zip.prev\",function(a){var b=Vi(a);if(r(b))for(a=b;;)if(b=Oi(a),b=r(b)?Ri(a):b,r(b))a=Ui(b);else return a;else return Si(a)});p(\"mori.zip.is_end\",function(a){return Wb.a(eh,a.b?a.b(1):a.call(null,1))});\np(\"mori.zip.remove\",function(a){P.c(a,0,null);var b=P.c(a,1,null),b=Mc(b)?S.a(Tf,b):b,c=Q.a(b,Zg),d=Q.a(b,Ug),e=Q.a(b,ah),f=Q.a(b,Wg);if(null==b)throw\"Remove at top\";if(0<O(c))for(a=N(new W(null,2,5,X,[yc(c),R.d(b,Zg,zc(c),J([bh,!0],0))],null),xc(a));;)if(b=Oi(a),b=r(b)?Ri(a):b,r(b))a=Ui(b);else return a;else return N(new W(null,2,5,X,[Qi(a,yc(e),f),r(d)?R.c(d,bh,!0):d],null),xc(a))});;return this.mori;}.call({});});\n\n},{}],172:[function(require,module,exports){\n(function (process){\n// info about each config option.\n\nvar debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG\n  ? function () { console.error.apply(console, arguments) }\n  : function () {}\n\nvar url = require(\"url\")\n  , path = require(\"path\")\n  , Stream = require(\"stream\").Stream\n  , abbrev = require(\"abbrev\")\n\nmodule.exports = exports = nopt\nexports.clean = clean\n\nexports.typeDefs =\n  { String  : { type: String,  validate: validateString  }\n  , Boolean : { type: Boolean, validate: validateBoolean }\n  , url     : { type: url,     validate: validateUrl     }\n  , Number  : { type: Number,  validate: validateNumber  }\n  , path    : { type: path,    validate: validatePath    }\n  , Stream  : { type: Stream,  validate: validateStream  }\n  , Date    : { type: Date,    validate: validateDate    }\n  }\n\nfunction nopt (types, shorthands, args, slice) {\n  args = args || process.argv\n  types = types || {}\n  shorthands = shorthands || {}\n  if (typeof slice !== \"number\") slice = 2\n\n  debug(types, shorthands, args, slice)\n\n  args = args.slice(slice)\n  var data = {}\n    , key\n    , remain = []\n    , cooked = args\n    , original = args.slice(0)\n\n  parse(args, data, remain, types, shorthands)\n  // now data is full\n  clean(data, types, exports.typeDefs)\n  data.argv = {remain:remain,cooked:cooked,original:original}\n  Object.defineProperty(data.argv, 'toString', { value: function () {\n    return this.original.map(JSON.stringify).join(\" \")\n  }, enumerable: false })\n  return data\n}\n\nfunction clean (data, types, typeDefs) {\n  typeDefs = typeDefs || exports.typeDefs\n  var remove = {}\n    , typeDefault = [false, true, null, String, Array]\n\n  Object.keys(data).forEach(function (k) {\n    if (k === \"argv\") return\n    var val = data[k]\n      , isArray = Array.isArray(val)\n      , type = types[k]\n    if (!isArray) val = [val]\n    if (!type) type = typeDefault\n    if (type === Array) type = typeDefault.concat(Array)\n    if (!Array.isArray(type)) type = [type]\n\n    debug(\"val=%j\", val)\n    debug(\"types=\", type)\n    val = val.map(function (val) {\n      // if it's an unknown value, then parse false/true/null/numbers/dates\n      if (typeof val === \"string\") {\n        debug(\"string %j\", val)\n        val = val.trim()\n        if ((val === \"null\" && ~type.indexOf(null))\n            || (val === \"true\" &&\n               (~type.indexOf(true) || ~type.indexOf(Boolean)))\n            || (val === \"false\" &&\n               (~type.indexOf(false) || ~type.indexOf(Boolean)))) {\n          val = JSON.parse(val)\n          debug(\"jsonable %j\", val)\n        } else if (~type.indexOf(Number) && !isNaN(val)) {\n          debug(\"convert to number\", val)\n          val = +val\n        } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {\n          debug(\"convert to date\", val)\n          val = new Date(val)\n        }\n      }\n\n      if (!types.hasOwnProperty(k)) {\n        return val\n      }\n\n      // allow `--no-blah` to set 'blah' to null if null is allowed\n      if (val === false && ~type.indexOf(null) &&\n          !(~type.indexOf(false) || ~type.indexOf(Boolean))) {\n        val = null\n      }\n\n      var d = {}\n      d[k] = val\n      debug(\"prevalidated val\", d, val, types[k])\n      if (!validate(d, k, val, types[k], typeDefs)) {\n        if (exports.invalidHandler) {\n          exports.invalidHandler(k, val, types[k], data)\n        } else if (exports.invalidHandler !== false) {\n          debug(\"invalid: \"+k+\"=\"+val, types[k])\n        }\n        return remove\n      }\n      debug(\"validated val\", d, val, types[k])\n      return d[k]\n    }).filter(function (val) { return val !== remove })\n\n    if (!val.length) delete data[k]\n    else if (isArray) {\n      debug(isArray, data[k], val)\n      data[k] = val\n    } else data[k] = val[0]\n\n    debug(\"k=%s val=%j\", k, val, data[k])\n  })\n}\n\nfunction validateString (data, k, val) {\n  data[k] = String(val)\n}\n\nfunction validatePath (data, k, val) {\n  if (val === true) return false\n  if (val === null) return true\n\n  val = String(val)\n  var homePattern = process.platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//\n  if (val.match(homePattern) && process.env.HOME) {\n    val = path.resolve(process.env.HOME, val.substr(2))\n  }\n  data[k] = path.resolve(String(val))\n  return true\n}\n\nfunction validateNumber (data, k, val) {\n  debug(\"validate Number %j %j %j\", k, val, isNaN(val))\n  if (isNaN(val)) return false\n  data[k] = +val\n}\n\nfunction validateDate (data, k, val) {\n  debug(\"validate Date %j %j %j\", k, val, Date.parse(val))\n  var s = Date.parse(val)\n  if (isNaN(s)) return false\n  data[k] = new Date(val)\n}\n\nfunction validateBoolean (data, k, val) {\n  if (val instanceof Boolean) val = val.valueOf()\n  else if (typeof val === \"string\") {\n    if (!isNaN(val)) val = !!(+val)\n    else if (val === \"null\" || val === \"false\") val = false\n    else val = true\n  } else val = !!val\n  data[k] = val\n}\n\nfunction validateUrl (data, k, val) {\n  val = url.parse(String(val))\n  if (!val.host) return false\n  data[k] = val.href\n}\n\nfunction validateStream (data, k, val) {\n  if (!(val instanceof Stream)) return false\n  data[k] = val\n}\n\nfunction validate (data, k, val, type, typeDefs) {\n  // arrays are lists of types.\n  if (Array.isArray(type)) {\n    for (var i = 0, l = type.length; i < l; i ++) {\n      if (type[i] === Array) continue\n      if (validate(data, k, val, type[i], typeDefs)) return true\n    }\n    delete data[k]\n    return false\n  }\n\n  // an array of anything?\n  if (type === Array) return true\n\n  // NaN is poisonous.  Means that something is not allowed.\n  if (type !== type) {\n    debug(\"Poison NaN\", k, val, type)\n    delete data[k]\n    return false\n  }\n\n  // explicit list of values\n  if (val === type) {\n    debug(\"Explicitly allowed %j\", val)\n    // if (isArray) (data[k] = data[k] || []).push(val)\n    // else data[k] = val\n    data[k] = val\n    return true\n  }\n\n  // now go through the list of typeDefs, validate against each one.\n  var ok = false\n    , types = Object.keys(typeDefs)\n  for (var i = 0, l = types.length; i < l; i ++) {\n    debug(\"test type %j %j %j\", k, val, types[i])\n    var t = typeDefs[types[i]]\n    if (t && type === t.type) {\n      var d = {}\n      ok = false !== t.validate(d, k, val)\n      val = d[k]\n      if (ok) {\n        // if (isArray) (data[k] = data[k] || []).push(val)\n        // else data[k] = val\n        data[k] = val\n        break\n      }\n    }\n  }\n  debug(\"OK? %j (%j %j %j)\", ok, k, val, types[i])\n\n  if (!ok) delete data[k]\n  return ok\n}\n\nfunction parse (args, data, remain, types, shorthands) {\n  debug(\"parse\", args, data, remain)\n\n  var key = null\n    , abbrevs = abbrev(Object.keys(types))\n    , shortAbbr = abbrev(Object.keys(shorthands))\n\n  for (var i = 0; i < args.length; i ++) {\n    var arg = args[i]\n    debug(\"arg\", arg)\n\n    if (arg.match(/^-{2,}$/)) {\n      // done with keys.\n      // the rest are args.\n      remain.push.apply(remain, args.slice(i + 1))\n      args[i] = \"--\"\n      break\n    }\n    var hadEq = false\n    if (arg.charAt(0) === \"-\" && arg.length > 1) {\n      if (arg.indexOf(\"=\") !== -1) {\n        hadEq = true\n        var v = arg.split(\"=\")\n        arg = v.shift()\n        v = v.join(\"=\")\n        args.splice.apply(args, [i, 1].concat([arg, v]))\n      }\n\n      // see if it's a shorthand\n      // if so, splice and back up to re-parse it.\n      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)\n      debug(\"arg=%j shRes=%j\", arg, shRes)\n      if (shRes) {\n        debug(arg, shRes)\n        args.splice.apply(args, [i, 1].concat(shRes))\n        if (arg !== shRes[0]) {\n          i --\n          continue\n        }\n      }\n      arg = arg.replace(/^-+/, \"\")\n      var no = null\n      while (arg.toLowerCase().indexOf(\"no-\") === 0) {\n        no = !no\n        arg = arg.substr(3)\n      }\n\n      if (abbrevs[arg]) arg = abbrevs[arg]\n\n      var isArray = types[arg] === Array ||\n        Array.isArray(types[arg]) && types[arg].indexOf(Array) !== -1\n\n      // allow unknown things to be arrays if specified multiple times.\n      if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {\n        if (!Array.isArray(data[arg]))\n          data[arg] = [data[arg]]\n        isArray = true\n      }\n\n      var val\n        , la = args[i + 1]\n\n      var isBool = typeof no === 'boolean' ||\n        types[arg] === Boolean ||\n        Array.isArray(types[arg]) && types[arg].indexOf(Boolean) !== -1 ||\n        (typeof types[arg] === 'undefined' && !hadEq) ||\n        (la === \"false\" &&\n         (types[arg] === null ||\n          Array.isArray(types[arg]) && ~types[arg].indexOf(null)))\n\n      if (isBool) {\n        // just set and move along\n        val = !no\n        // however, also support --bool true or --bool false\n        if (la === \"true\" || la === \"false\") {\n          val = JSON.parse(la)\n          la = null\n          if (no) val = !val\n          i ++\n        }\n\n        // also support \"foo\":[Boolean, \"bar\"] and \"--foo bar\"\n        if (Array.isArray(types[arg]) && la) {\n          if (~types[arg].indexOf(la)) {\n            // an explicit type\n            val = la\n            i ++\n          } else if ( la === \"null\" && ~types[arg].indexOf(null) ) {\n            // null allowed\n            val = null\n            i ++\n          } else if ( !la.match(/^-{2,}[^-]/) &&\n                      !isNaN(la) &&\n                      ~types[arg].indexOf(Number) ) {\n            // number\n            val = +la\n            i ++\n          } else if ( !la.match(/^-[^-]/) && ~types[arg].indexOf(String) ) {\n            // string\n            val = la\n            i ++\n          }\n        }\n\n        if (isArray) (data[arg] = data[arg] || []).push(val)\n        else data[arg] = val\n\n        continue\n      }\n\n      if (types[arg] === String && la === undefined)\n        la = \"\"\n\n      if (la && la.match(/^-{2,}$/)) {\n        la = undefined\n        i --\n      }\n\n      val = la === undefined ? true : la\n      if (isArray) (data[arg] = data[arg] || []).push(val)\n      else data[arg] = val\n\n      i ++\n      continue\n    }\n    remain.push(arg)\n  }\n}\n\nfunction resolveShort (arg, shorthands, shortAbbr, abbrevs) {\n  // handle single-char shorthands glommed together, like\n  // npm ls -glp, but only if there is one dash, and only if\n  // all of the chars are single-char shorthands, and it's\n  // not a match to some other abbrev.\n  arg = arg.replace(/^-+/, '')\n\n  // if it's an exact known option, then don't go any further\n  if (abbrevs[arg] === arg)\n    return null\n\n  // if it's an exact known shortopt, same deal\n  if (shorthands[arg]) {\n    // make it an array, if it's a list of words\n    if (shorthands[arg] && !Array.isArray(shorthands[arg]))\n      shorthands[arg] = shorthands[arg].split(/\\s+/)\n\n    return shorthands[arg]\n  }\n\n  // first check to see if this arg is a set of single-char shorthands\n  var singles = shorthands.___singles\n  if (!singles) {\n    singles = Object.keys(shorthands).filter(function (s) {\n      return s.length === 1\n    }).reduce(function (l,r) {\n      l[r] = true\n      return l\n    }, {})\n    shorthands.___singles = singles\n    debug('shorthand singles', singles)\n  }\n\n  var chrs = arg.split(\"\").filter(function (c) {\n    return singles[c]\n  })\n\n  if (chrs.join(\"\") === arg) return chrs.map(function (c) {\n    return shorthands[c]\n  }).reduce(function (l, r) {\n    return l.concat(r)\n  }, [])\n\n\n  // if it's an arg abbrev, and not a literal shorthand, then prefer the arg\n  if (abbrevs[arg] && !shorthands[arg])\n    return null\n\n  // if it's an abbr for a shorthand, then use that\n  if (shortAbbr[arg])\n    arg = shortAbbr[arg]\n\n  // make it an array, if it's a list of words\n  if (shorthands[arg] && !Array.isArray(shorthands[arg]))\n    shorthands[arg] = shorthands[arg].split(/\\s+/)\n\n  return shorthands[arg]\n}\n\n}).call(this,require('_process'))\n},{\"_process\":11,\"abbrev\":173,\"path\":10,\"stream\":27,\"url\":29}],173:[function(require,module,exports){\n\nmodule.exports = exports = abbrev.abbrev = abbrev\n\nabbrev.monkeyPatch = monkeyPatch\n\nfunction monkeyPatch () {\n  Object.defineProperty(Array.prototype, 'abbrev', {\n    value: function () { return abbrev(this) },\n    enumerable: false, configurable: true, writable: true\n  })\n\n  Object.defineProperty(Object.prototype, 'abbrev', {\n    value: function () { return abbrev(Object.keys(this)) },\n    enumerable: false, configurable: true, writable: true\n  })\n}\n\nfunction abbrev (list) {\n  if (arguments.length !== 1 || !Array.isArray(list)) {\n    list = Array.prototype.slice.call(arguments, 0)\n  }\n  for (var i = 0, l = list.length, args = [] ; i < l ; i ++) {\n    args[i] = typeof list[i] === \"string\" ? list[i] : String(list[i])\n  }\n\n  // sort them lexicographically, so that they're next to their nearest kin\n  args = args.sort(lexSort)\n\n  // walk through each, seeing how much it has in common with the next and previous\n  var abbrevs = {}\n    , prev = \"\"\n  for (var i = 0, l = args.length ; i < l ; i ++) {\n    var current = args[i]\n      , next = args[i + 1] || \"\"\n      , nextMatches = true\n      , prevMatches = true\n    if (current === next) continue\n    for (var j = 0, cl = current.length ; j < cl ; j ++) {\n      var curChar = current.charAt(j)\n      nextMatches = nextMatches && curChar === next.charAt(j)\n      prevMatches = prevMatches && curChar === prev.charAt(j)\n      if (!nextMatches && !prevMatches) {\n        j ++\n        break\n      }\n    }\n    prev = current\n    if (j === cl) {\n      abbrevs[current] = current\n      continue\n    }\n    for (var a = current.substr(0, j) ; j <= cl ; j ++) {\n      abbrevs[a] = current\n      a += current.charAt(j)\n    }\n  }\n  return abbrevs\n}\n\nfunction lexSort (a, b) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\n},{}],174:[function(require,module,exports){\n//     Underscore.js 1.7.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.7.0';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var createCallback = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result  either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  _.iteratee = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return createCallback(value, context, argCount);\n    if (_.isObject(value)) return _.matches(value);\n    return _.property(value);\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    if (obj == null) return obj;\n    iteratee = createCallback(iteratee, context);\n    var i, length = obj.length;\n    if (length === +length) {\n      for (i = 0; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    if (obj == null) return [];\n    iteratee = _.iteratee(iteratee, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length),\n        currentKey;\n    for (var index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index = 0, currentKey;\n    if (arguments.length < 3) {\n      if (!length) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[index++] : index++];\n    }\n    for (; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== + obj.length && _.keys(obj),\n        index = (keys || obj).length,\n        currentKey;\n    if (arguments.length < 3) {\n      if (!index) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[--index] : --index];\n    }\n    while (index--) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    predicate = _.iteratee(predicate, context);\n    _.some(obj, function(value, index, list) {\n      if (predicate(value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    predicate = _.iteratee(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(_.iteratee(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    if (obj == null) return true;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    if (obj == null) return false;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (obj.length !== +obj.length) obj = _.values(obj);\n    return _.indexOf(obj, target) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).\n  _.shuffle = function(obj) {\n    var set = obj && obj.length === +obj.length ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = low + high >>> 1;\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return obj.length === +obj.length ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = _.iteratee(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    for (var i = 0, length = input.length; i < length; i++) {\n      var value = input[i];\n      if (!_.isArray(value) && !_.isArguments(value)) {\n        if (!strict) output.push(value);\n      } else if (shallow) {\n        push.apply(output, value);\n      } else {\n        flatten(value, shallow, strict, output);\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (array == null) return [];\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = _.iteratee(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = array.length; i < length; i++) {\n      var value = array[i];\n      if (isSorted) {\n        if (!i || seen !== value) result.push(value);\n        seen = value;\n      } else if (iteratee) {\n        var computed = iteratee(value, i, array);\n        if (_.indexOf(seen, computed) < 0) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (_.indexOf(result, value) < 0) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true, []));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    if (array == null) return [];\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = array.length; i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(slice.call(arguments, 1), true, true, []);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function(array) {\n    if (array == null) return [];\n    var length = _.max(arguments, 'length').length;\n    var results = Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var idx = array.length;\n    if (typeof from == 'number') {\n      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n    }\n    while (--idx >= 0) if (array[idx] === item) return idx;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var Ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    args = slice.call(arguments, 2);\n    bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      Ctor.prototype = func.prototype;\n      var self = new Ctor;\n      Ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (_.isObject(result)) return result;\n      return self;\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = hasher ? hasher.apply(this, arguments) : key;\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last > 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed before being called N times.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      } else {\n        func = null;\n      }\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      source = arguments[i];\n      for (prop in source) {\n        if (hasOwnProperty.call(source, prop)) {\n            obj[prop] = source[prop];\n        }\n      }\n    }\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj, iteratee, context) {\n    var result = {}, key;\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      iteratee = createCallback(iteratee, context);\n      for (key in obj) {\n        var value = obj[key];\n        if (iteratee(value, key, obj)) result[key] = value;\n      }\n    } else {\n      var keys = concat.apply([], slice.call(arguments, 1));\n      obj = new Object(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        key = keys[i];\n        if (key in obj) result[key] = obj[key];\n      }\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      var source = arguments[i];\n      for (var prop in source) {\n        if (obj[prop] === void 0) obj[prop] = source[prop];\n      }\n    }\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (\n      aCtor !== bCtor &&\n      // Handle Object.create(x) cases\n      'constructor' in a && 'constructor' in b &&\n      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n        _.isFunction(bCtor) && bCtor instanceof bCtor)\n    ) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size, result;\n    // Recursively compare objects and arrays.\n    if (className === '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size === b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      size = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      result = _.keys(b).length === size;\n      if (result) {\n        while (size--) {\n          // Deep compare each member\n          key = keys[size];\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.\n  if (typeof /./ !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    var pairs = _.pairs(attrs), length = pairs.length;\n    return function(obj) {\n      if (obj == null) return !length;\n      obj = new Object(obj);\n      for (var i = 0; i < length; i++) {\n        var pair = pairs[i], key = pair[0];\n        if (pair[1] !== obj[key] || !(key in obj)) return false;\n      }\n      return true;\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = createCallback(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? object[property]() : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n\n},{}],175:[function(require,module,exports){\nvar React = require('react')\nvar ExplicitProps = require('react_explicit_prop_declaration')\nvar isFunction = require('lodash/lang/isFunction')\nvar cuid = require('cuid')\nvar Draggable = require('react-draggable')\n\nvar Slider = React.createClass({\n    displayName: 'nw-slider',\n\n    mixins: [ExplicitProps],\n\n    propTypes: {\n      value: React.PropTypes.number,\n      min: React.PropTypes.number,\n      max: React.PropTypes.number,\n      ticks: React.PropTypes.bool,\n      onChange: React.PropTypes.func,\n      snapToTick: React.PropTypes.bool\n    },\n\n    getDefaultProps: function () {\n      return {\n        value: this.props.min,\n        min: 0,\n        max: 10,\n        ticks: true,\n        snapToTick: true\n      }\n    },\n\n    getInitialState: function () {\n      return {\n        uniqueID: cuid(),\n        steps: [0],\n        position: 0,\n        value: this.props.value,\n        handleWidth: 0\n      }\n    },\n\n    componentDidMount: function () {\n      var handleWidth = React.findDOMNode(this.refs.handle).offsetWidth\n      this.setState({handleWidth: handleWidth})\n      var initialPosition = (React.findDOMNode(this).offsetWidth / (this.props.max - this.props.min) * this.props.value) - handleWidth / 2\n      this.setState({position: initialPosition})\n    },\n\n    setClosestPosition: function (currentPosition) {\n      var newPosition = this.getClosestPosition(currentPosition)\n      this.setState({position: newPosition - this.state.handleWidth / 2})\n    },\n\n    getClosestPosition: function (currentPosition) {\n      var steps = this.state.steps\n      var sliderWidth = React.findDOMNode(this).offsetWidth\n      var currentPercent = currentPosition / sliderWidth * 100\n\n      var bestMatch = steps[0]\n      var bestMatchIndex = 0\n      steps.forEach(function (element, index, array) {\n        if (Math.abs(currentPercent - element) < Math.abs(currentPercent - bestMatch)) {\n          bestMatch = element\n          bestMatchIndex = index\n        }\n      })\n      this.setState({value: (this.props.min + bestMatchIndex)})\n      this.onChange((this.props.min + bestMatchIndex))\n      var newPosition = sliderWidth * (bestMatch / 100)\n      return newPosition\n    },\n\n    clickOnTrack: function (event) {\n      var handle = React.findDOMNode(this.refs.handle)\n      var clickFromLeft = event.clientX - this.cumulativeOffset(event.target).left\n\n      handle.style.transition = 'transform .2s ease'\n      if (this.props.snapToTick) {\n        this.setClosestPosition(clickFromLeft)\n      }else {\n        this.setState({position: clickFromLeft - this.state.handleWidth / 2})\n        this.getClosestPosition(clickFromLeft)\n      }\n    },\n\n    handleUp: function (event, ui) {\n      if (this.props.snapToTick) {\n        var handle = React.findDOMNode(this.refs.handle)\n        handle.style.transition = 'transform .2s ease'\n        this.setClosestPosition(ui.position.left + this.state.handleWidth / 2)\n      }else {\n        this.setState({position: ui.position.left})\n        this.getClosestPosition(ui.position.left + this.state.handleWidth / 2)\n      }\n    },\n\n    handleDown: function (event, ui) {\n      var handle = React.findDOMNode(this.refs.handle)\n      handle.style.transition = ''\n    },\n\n    dragging: function (event, ui) {\n    },\n\n    onChange: function (value) {\n      if (isFunction(this.props.onChange)) {\n        this.props.onChange(value)\n      }\n    },\n\n    cumulativeOffset: function (element) {\n      var top = 0\n      var left = 0\n      do {\n        top += element.offsetTop || 0\n        left += element.offsetLeft || 0\n        element = element.offsetParent\n      } while (element)\n\n      return {\n          top: top,\n          left: left\n      }\n    },\n\n    fillSteps: function () {\n      var steps = this.state.steps\n      var min = this.props.min\n      var max = this.props.max\n      var percentStep = 100 / max\n      var cummulativeStep = 0\n      for (var i = min; i < max; i++) {\n        cummulativeStep += percentStep\n        steps.push(cummulativeStep)\n      }\n    },\n\n    renderTicks: function () {\n      var elements = []\n      var min = this.props.min\n      var max = this.props.max\n      var percentStep = 100 / max\n      for (var i = min + 1; i < max; i++) {\n        var style = {\n          left: (percentStep * i) + '%'\n        }\n        var key = 'tick' + i\n        elements.push(React.createElement(\"span\", {key: key, className: \"tick\", style: style}))\n      }\n      return (\n        React.createElement(\"div\", {key: \"ticks\", className: \"ticks\", style: {cursor: 'pointer'}, onClick: this.clickOnTrack}, elements)\n      )\n    },\n\n    render: function () {\n\n      React.initializeTouchEvents(true)\n      var ticks = this.props.ticks ? this.renderTicks() : ''\n      this.fillSteps()\n      return (\n        React.createElement(\"div\", {key: \"slider\", className: \"slider\", style: {position: 'relative'}}, \n          React.createElement(Draggable, {\n            axis: \"x\", \n            handle: '#' + this.state.uniqueID, \n            bounds: \"parent\", \n            start: {x: this.state.position}, \n            moveOnStartChange: true, \n            onStop: this.handleUp, \n            onStart: this.handleDown, \n            onDrag: this.dragging, \n            key: \"draggable\"\n            }, \n            React.createElement(\"span\", {key: \"handle\", ref: \"handle\", className: \"handle\", id: this.state.uniqueID})\n          ), \n          ticks, \n          React.createElement(\"div\", {key: \"track\", className: \"track\", style: {cursor: 'pointer'}, onClick: this.clickOnTrack})\n        )\n      )\n    }\n})\n\nmodule.exports = Slider\n\n},{\"cuid\":30,\"lodash/lang/isFunction\":35,\"react\":undefined,\"react-draggable\":38,\"react_explicit_prop_declaration\":42}]},{},[175]);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/greg-slider/dist/slider.js\n ** module id = 3\n ** module chunks = 1\n **/\n//# sourceURL=webpack:///./bower_components/greg-slider/dist/slider.js?");

/***/ }
/******/ ])
});
;
